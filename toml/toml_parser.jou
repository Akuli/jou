# TOML spec: https://toml.io/en/v1.1.0

import "stdlib/ascii.jou"
import "stdlib/assert.jou"
import "stdlib/io.jou"
import "stdlib/json.jou"
import "stdlib/limits.jou"
import "stdlib/list.jou"
import "stdlib/mem.jou"
import "stdlib/process.jou"
import "stdlib/str.jou"
import "stdlib/utf8.jou"


def joutest_error(msg: byte*) -> noreturn:
    fprintf(get_stderr(), "joutest error: %s\n", msg)
    exit(1)


class TOMLKeyVal:
    key: byte*
    value: TOMLValue

class TOMLTable:
    # TODO: hash table? or is that not needed?
    items: List[TOMLKeyVal]

    def find(self, key: byte*) -> TOMLValue*:
        for p = self.items.ptr; p < self.items.end(); p++:
            if strcmp(key, p.key) == 0:
                return &p.value
        return NULL

    def free(self) -> None:
        for i = 0; i < self.items.len; i++:
            kv = self.items.ptr[i]
            free(kv.key)
            kv.value.free()
        free(self.items.ptr)


enum TOMLValueKind:
    Unset  # must be first, so initializes to this
    Table
    Array
    String
    Boolean
    Integer

class TOMLValue:
    kind: TOMLValueKind
    union:
        table: TOMLTable
        array: List[TOMLValue]
        string: byte*
        boolean: bool
        integer: int64

    def free(self) -> None:
        match self.kind:
            case TOMLValueKind.Table:
                self.table.free()
            case TOMLValueKind.Array:
                for i = 0; i < self.array.len; i++:
                    self.array.ptr[i].free()
                free(self.array.ptr)
            case TOMLValueKind.String:
                free(self.string)
            case TOMLValueKind.Boolean | TOMLValueKind.Integer | TOMLValueKind.Unset:
                pass

def hexdigit_value(b: byte) -> int:
    if '0' <= b and b <= '9':
        return b - '0'
    if 'A' <= b and b <= 'F':
        return 10 + (b - 'A')
    if 'a' <= b and b <= 'f':
        return 10 + (b - 'a')
    return -1


class TOMLParser:
    path: byte*
    file_content_start: byte*
    ptr: byte*
    target: TOMLValue*
    root: TOMLValue

    def fail(self, message: byte*) -> noreturn:
        fprintf(get_stderr(), "%s", self.ptr)
        # Work out line number
        assert self.ptr >= self.file_content_start
        lineno = 1
        for p = self.file_content_start; p < self.ptr; p++:
            if *p == '\n':
                lineno++

        message_with_location: byte[500]
        snprintf(
            message_with_location,
            sizeof(message_with_location),
            "invalid TOML syntax in file \"%s\", line %d%s%s\n",
            self.path,
            lineno,
            "" if message == NULL else ": ",
            "" if message == NULL else message,
        )
        joutest_error(message_with_location)

    # Names of many methods are according to this:
    # https://github.com/toml-lang/toml/blob/bcbbd1c1f03473ffe97b8bf26a0fc945efe2b4a1/toml.abnf

    def toml(self) -> None:
        self.expression()
        while *self.ptr != '\0':
            self.newline()
            self.expression()

    def expression(self) -> None:
        self.ws()
        match *self.ptr:
            case '[':
                self.table()
                self.ws()
                if *self.ptr == '#':
                    self.comment()
            case '\n' | '\0':
                pass
            case '#':
                self.comment()
            case '\0':
                return
            case _:
                self.keyval()
                self.ws()
                if *self.ptr == '#':
                    self.comment()

    def ws(self) -> None:
        while *self.ptr == ' ' or *self.ptr == '\t':
            self.ptr++

    def newline(self) -> None:
        if *self.ptr != '\n':
            self.fail(NULL)
        self.ptr++

    def comment(self) -> None:
        assert *self.ptr == '#'
        while *self.ptr != '\0' and *self.ptr != '\n':
            b = *self.ptr
            if not (b >= 128 or b == '\t' or (32 <= b and b <= 126)):
                self.fail("invalid character in comment")
            self.ptr++

    def keyval(self) -> None:
        old_target = self.target
        self.key()
        self.ws()
        if *self.ptr != '=':
            self.fail(NULL)
        self.ptr++
        self.ws()
        self.val()
        self.target = old_target

    # Not exactly right according to the spec, because this ends with a call to
    # .ws() but a key shouldn't include trailing whitespace. We'll see if that
    # matters, maybe not...
    def key(self) -> None:
        self.simple_key()
        self.ws()
        while *self.ptr == '.':
            self.ptr++
            self.ws()
            self.simple_key()
            self.ws()

    def simple_key(self) -> None:
        key: byte*
        match *self.ptr:
            case '"':
                key = self.basic_string()
            case '\'':
                key = self.literal_string()
            case _:
                n = 0
                while (
                    is_ascii_letter(self.ptr[n])
                    or is_ascii_digit(self.ptr[n])
                    or self.ptr[n] == '-'
                    or self.ptr[n] == '_'
                ):
                    n++
                if n == 0:
                    self.fail(NULL)
                key = NULL
                asprintf(&key, "%.*s", n, self.ptr)
                assert key != NULL
                self.ptr = &self.ptr[n]

        assert self.target.kind == TOMLValueKind.Table

        # Does this key already exists? If it exists, let's go there
        found = self.target.table.find(key)
        if found != NULL:
            free(key)
            self.target = found
            return

        # Key not found --> create new table
        self.target.table.items.append(TOMLKeyVal{
            key = key,
            value = TOMLValue{kind = TOMLValueKind.Table},
        })
        self.target = &self.target.table.items.end()[-1].value

    def val(self) -> None:
        # TODO: why is this needed?
        self.target.free()
        *self.target = TOMLValue{}

        match *self.ptr:
            case '"':
                if starts_with(self.ptr, "\"\"\""):
                    s = self.ml_basic_string()
                else:
                    s = self.basic_string()
                assert s != NULL
                *self.target = TOMLValue{kind = TOMLValueKind.String, string = s}
            case '\'':
                if starts_with(self.ptr, "'''"):
                    s = self.ml_literal_string()
                else:
                    s = self.literal_string()
                assert s != NULL
                *self.target = TOMLValue{kind = TOMLValueKind.String, string = s}
            case 't':
                if not starts_with(self.ptr, "true"):
                    self.fail(NULL)
                *self.target = TOMLValue{kind = TOMLValueKind.Boolean, boolean = True}
                self.ptr = &self.ptr[4]
            case '+' | '-' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9':
                n = self.integer()
                *self.target = TOMLValue{kind = TOMLValueKind.Integer, integer = n}
            case '[':
                self.array()
            case _:
                # TODO: support other types of values
                msg: byte[100]
                snprintf(msg, sizeof(msg), "unknown value: %.*s", strcspn(self.ptr,"\n") as int, self.ptr)
                self.fail(msg)

    def unsigned_integer_in_base(self, base: int) -> uint64:
        first_digit_value = hexdigit_value(*self.ptr)
        if first_digit_value != -1 and first_digit_value < base:
            result: uint64 = first_digit_value as uint64
            self.ptr++
            while True:
                if *self.ptr == '_':
                    self.ptr++
                    continue
                v = hexdigit_value(*self.ptr)
                if v == -1:
                    return result
                if v >= base:
                    break  # show error message
                # Don't allow 01, 001 etc
                if base == 10 and first_digit_value == 0:
                    self.fail("integer starts with an unnecessary zero")
                new_result = result*(base as uint64) + (v as uint64)
                if new_result/base != result:
                    # it overflowed
                    return UINT64_MAX
                result = new_result
                self.ptr++

        match base:
            case 2:
                self.fail("invalid binary number")
            case 8:
                self.fail("invalid octal number")
            case 10:
                self.fail("invalid number")
            case 16:
                self.fail("invalid hexadecimal number")
            case _:
                assert False

    def integer(self) -> int64:
        sign = 1
        if starts_with(self.ptr, "0b"):
            base = 2
        elif starts_with(self.ptr, "0o"):
            base = 8
        elif starts_with(self.ptr, "0x"):
            base = 16
        else:
            base = 10
            # Only base 10 numbers can be negative in TOML!
            if *self.ptr == '-':
                sign = -1
            if *self.ptr == '+' or *self.ptr == '-':
                self.ptr++

        if base != 10:
            self.ptr = &self.ptr[2]

        u = self.unsigned_integer_in_base(base)

        # Special casing to make sure the most negative int64 value works.
        # Its absolute value doesn't fit in int64.
        # TODO: this needed?
        if sign == -1 and u == (INT64_MAX as uint64) + 1:
            return INT64_MIN

        if u > INT64_MAX:
            self.fail("integer doesn't fit in a Jou int64")
        return sign*(u as int64)

    def basic_string(self) -> byte*:
        assert *self.ptr == '"'
        self.ptr++

        result = List[byte]{}
        while *self.ptr != '"' and *self.ptr != '\0':
            self.basic_char(&result)
        self.ptr++

        result.append('\0')
        return result.ptr

    def basic_char(self, out: List[byte]*) -> None:
        if *self.ptr == '\\':
            self.escaped(out)
        else:
            out.append(self.basic_unescaped())

    def basic_unescaped(self) -> byte:
        if (
            *self.ptr == '\t'
            or *self.ptr == ' '
            or *self.ptr == '!'
            or (*self.ptr >= 0x23 and *self.ptr <= 0x5b)
            or (*self.ptr >= 0x5d and *self.ptr <= 0x7e)
            or *self.ptr >= 128  # TODO: reject invalid UTF-8
        ):
            return *self.ptr++

        message: byte[200]
        if is_ascii_printable(*self.ptr):
            sprintf(message, "unexpected byte '%c' (%#02x)", *self.ptr, *self.ptr)
        else:
            sprintf(message, "unexpected byte %#02x", *self.ptr)
        self.fail(message)

    def read_escaped_char(self, prefix_char: byte, num_hex_digits: int) -> byte[5]:
        msg: byte[100]

        codepoint: uint32 = 0
        for i = 0; i < num_hex_digits; i++:
            v = hexdigit_value(self.ptr[i])
            if v == -1:
                snprintf(msg, sizeof(msg), "invalid \\%c escape in string", prefix_char)
                self.fail(msg)
            codepoint <<= 4
            codepoint |= v as uint32

        if codepoint == 0:
            snprintf(msg, sizeof(msg), "zero bytes (%.*s) are not supported in strings", num_hex_digits + 2, &self.ptr[-2])
            self.fail(msg)

        result = utf8_encode_char(codepoint)
        if result[0] == '\0':
            snprintf(msg, sizeof(msg), "invalid Unicode codepoint in string: %.*s", num_hex_digits + 2, &self.ptr[-2])

        self.ptr = &self.ptr[num_hex_digits]
        return result

    def escaped(self, out: List[byte]*) -> None:
        assert *self.ptr == '\\'
        self.ptr++
        msg: byte[100]
        match *self.ptr++:
            case '"':
                out.append('"')
            case '\\':
                out.append('\\')
            case 'b':
                out.append(0x08)  # Jou doesn't have \b
            case 'e':
                out.append(0x1b)  # Jou doesn't have \e
            case 'f':
                out.append(0x0c)  # Jou doesn't have \f
            case 'n':
                out.append('\n')
            case 'r':
                out.append('\r')
            case 't':
                out.append('\t')
            case 'x':
                s = self.read_escaped_char('x', 2)
                out.extend_from_ptr(s, strlen(s))
            case 'u':
                s = self.read_escaped_char('u', 4)
                out.extend_from_ptr(s, strlen(s))
            case 'U':
                s = self.read_escaped_char('U', 8)
                out.extend_from_ptr(s, strlen(s))
            case _:
                self.fail("bad backslash escape in string")

    def literal_string(self) -> byte*:
        assert *self.ptr == '\''
        self.ptr++
        result = List[byte]{}
        while *self.ptr != '\'':
            result.append(self.literal_char())
        self.ptr++
        result.append('\0')
        return result.ptr

    def literal_char(self) -> byte:
        if (
            *self.ptr == '\t'
            or (0x20 <= *self.ptr and *self.ptr <= 0x26)
            or (0x28 <= *self.ptr and *self.ptr <= 0x7e)
            or *self.ptr >= 128  # TODO: reject invalid UTF-8
        ):
            return *self.ptr++
        self.fail("bad character inside string")

    def ml_basic_string(self) -> byte*:
        assert starts_with(self.ptr, "\"\"\"")
        self.ptr = &self.ptr[3]
        if *self.ptr == '\n':
            self.ptr++
        result = List[byte]{}
        while not (starts_with(self.ptr, "\"\"\"") and not starts_with(self.ptr, "\"\"\"\"")):
            if *self.ptr == '\n':
                self.ptr++
                result.append('\n')
            elif *self.ptr == '"':
                self.ptr++
                result.append('"')
            elif *self.ptr == '\\' and self.ptr[1 + strspn(&self.ptr[1], " \t")] == '\n':
                # Line continuation backslash causes all whitespace to be
                # trimmed after the backslash. TOML is weird :)
                self.ptr++
                while *self.ptr == ' ' or *self.ptr == '\t' or *self.ptr == '\n':
                    self.ptr++
            else:
                self.basic_char(&result)
        self.ptr = &self.ptr[3]
        result.append('\0')
        return result.ptr

    def ml_literal_string(self) -> byte*:
        assert starts_with(self.ptr, "'''")
        self.ptr = &self.ptr[3]
        if *self.ptr == '\n':
            self.ptr++
        result = List[byte]{}
        while not (starts_with(self.ptr, "'''") and not starts_with(self.ptr, "''''")):
            if *self.ptr == '\n':
                self.ptr++
                result.append('\n')
            elif *self.ptr == '\'':
                self.ptr++
                result.append('\'')
            else:
                result.append(self.literal_char())
        self.ptr = &self.ptr[3]
        result.append('\0')
        return result.ptr

    def table(self) -> None:
        assert *self.ptr == '['
        if starts_with(self.ptr, "[["):
            self.array_table()
        else:
            self.std_table()

    def std_table(self) -> None:
        assert starts_with(self.ptr, "[")
        self.ptr++
        self.ws()
        self.target = &self.root
        self.key()
        self.ws()
        if *self.ptr != ']':
            self.fail("missing ]")
        self.ptr++

    def array_table(self) -> None:
        assert False

    def array(self) -> None:
        array_value = self.target
        assert array_value != NULL
        assert array_value.kind == TOMLValueKind.Unset
        *array_value = TOMLValue{kind = TOMLValueKind.Array}

        assert *self.ptr == '['
        self.ptr++
        self.ws_comment_newline()
        while *self.ptr != ']':
            array_value.array.append(TOMLValue{})
            self.target = &array_value.array.end()[-1]
            self.val()
            self.ws_comment_newline()
            if *self.ptr == ']':
                break
            if *self.ptr != ',':
                self.fail("invalid array")
            self.ptr++
            self.ws_comment_newline()

        assert *self.ptr == ']'
        self.ptr++
        self.target = NULL

    def ws_comment_newline(self) -> None:
        while *self.ptr == ' ' or *self.ptr == '\t' or *self.ptr == '\n' or *self.ptr == '#':
            if *self.ptr == '#':
                self.comment()
            else:
                self.ptr++


def print_toml_value(value: TOMLValue, depth: int) -> None:
    match value.kind:
        case TOMLValueKind.Unset:
            puts("UNSET")
        case TOMLValueKind.Array:
            printf("array:\n")
            for p = value.array.ptr; p < value.array.end(); p++:
                printf("%*s", 2*(depth + 1), "")
                print_toml_value(*p, depth + 1)
        case TOMLValueKind.Table:
            printf("table:\n")
            for i = 0; i < value.table.items.len; i++:
                kv = value.table.items.ptr[i]
                printf("%*s", 2*(depth + 1), "")
                printf("%s = ", kv.key)
                print_toml_value(kv.value, depth + 1)
        case TOMLValueKind.String:
            printf("string: %s\n", value.string)
        case TOMLValueKind.Boolean:
            puts("boolean: true" if value.boolean else "boolean: false")
        case TOMLValueKind.Integer:
            printf("integer: %lld\n", value.integer)


def read_file_to_string(path: byte*) -> byte*:
    msg: byte[500]

    file = fopen(path, "rb")
    if file == NULL:
        snprintf(msg, sizeof(msg), "reading file \"%s\" failed", path)
        joutest_error(msg)

    bytes_list = List[byte]{}

    buf: byte[4096]
    while True:
        num_read = fread(buf, 1, sizeof buf, file)
        if num_read == 0:
            if ferror(file) != 0:
                snprintf(msg, sizeof(msg), "reading file \"%s\" failed", path)
                joutest_error(msg)
            break
        bytes_list.extend_from_ptr(buf, num_read)

    fclose(file)

    lineno = 1
    for p = bytes_list.ptr; p < bytes_list.end(); p++:
        match *p:
            case '\n':
                lineno++
            case '\0':
                snprintf(msg, sizeof(msg), "file \"%s\" contains a zero byte on line %d\n", path, lineno)
                joutest_error(msg)

    bytes_list.append('\0')
    return bytes_list.ptr


# Replaces \r\n with \n in-place
def fix_newlines(s: byte*) -> None:
    out = s
    while *s != '\0':
        if starts_with(s, "\r\n"):
            s++
        *out++ = *s++
    *out = '\0'


def parse_toml(path: byte*) -> TOMLTable:
    file_content = read_file_to_string(path)
    fix_newlines(file_content)
    # TODO: ensure it's valid UTF-8

    parser = TOMLParser{
        path = path,
        file_content_start = file_content,
        ptr = file_content,
        root = TOMLValue{kind = TOMLValueKind.Table},
    }
    parser.target = &parser.root  # the "default section"
    parser.toml()
    free(file_content)

    assert parser.root.kind == TOMLValueKind.Table
    return parser.root.table


# TODO: take value as pointer
def toml_to_json(value: TOMLValue, jb: JSONBuilder*) -> None:
    match value.kind:
        case TOMLValueKind.Unset:
            jb.string("THIS SHOULD NEVER HAPPEN!!!!")
        case TOMLValueKind.Array:
            jb.begin_array()
            for p = value.array.ptr; p < value.array.end(); p++:
                toml_to_json(*p, jb)
            jb.end_array()
        case TOMLValueKind.Table:
            jb.begin_object()
            for kv = value.table.items.ptr; kv < value.table.items.end(); kv++:
                jb.key(kv.key)
                toml_to_json(kv.value, jb)
            jb.end_object()
        case TOMLValueKind.String:
            jb.begin_object()
            jb.key("type").string("string")
            jb.key("value").string(value.string)
            jb.end_object()
        case TOMLValueKind.Boolean:
            jb.string("TODO boolean")
        case TOMLValueKind.Integer:
            jb.begin_object()
            jb.key("type").string("integer")
            s: byte[100]
            sprintf(s, "%lld", value.integer)
            jb.key("value").string(s)
            jb.end_object()


# For testing with the official TOML test suite and experimenting.
# Reads TOML from stdin and prints JSON compatible with the TOML test suite.
def main() -> int:
    toml = parse_toml("/dev/stdin")

    jb = JSONBuilder{pretty_print = 4}
    toml_to_json(TOMLValue{kind = TOMLValueKind.Table, table = toml}, &jb)
    toml.free()

    json = jb.finish()
    puts(json)
    free(json)
    return 0
