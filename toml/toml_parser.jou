# TOML spec: https://toml.io/en/v1.1.0

import "stdlib/ascii.jou"
import "stdlib/assert.jou"
import "stdlib/io.jou"
import "stdlib/json.jou"
import "stdlib/limits.jou"
import "stdlib/list.jou"
import "stdlib/mem.jou"
import "stdlib/process.jou"
import "stdlib/str.jou"
import "stdlib/utf8.jou"


class TOMLKeyVal:
    key: byte*
    value: TOMLValue

    def free(self) -> None:
        free(self.key)
        self.value.free()


enum TOMLValueKind:
    Unset  # must be first, so initializes to this
    Table
    Array
    String
    Boolean
    Integer

class TOMLValue:
    kind: TOMLValueKind
    union:
        table: List[TOMLKeyVal]
        array: List[TOMLValue]
        string: byte*
        boolean: bool
        integer: int64

    def free(self) -> None:
        match self.kind:
            case TOMLValueKind.Table:
                for kv = self.table.ptr; kv < self.table.end(); kv++:
                    kv.free()
                free(self.table.ptr)
            case TOMLValueKind.Array:
                for p = self.array.ptr; p < self.array.end(); p++:
                    p.free()
                free(self.array.ptr)
            case TOMLValueKind.String:
                free(self.string)
            case TOMLValueKind.Boolean | TOMLValueKind.Integer | TOMLValueKind.Unset:
                pass

def hexdigit_value(b: byte) -> int:
    if '0' <= b and b <= '9':
        return b - '0'
    if 'A' <= b and b <= 'F':
        return 10 + (b - 'A')
    if 'a' <= b and b <= 'f':
        return 10 + (b - 'a')
    return -1


class TOMLParseResult:
    parsed: List[TOMLKeyVal]
    failed: bool
    error_lineno: int

    def free(self) -> None:
        for kv = self.parsed.ptr; kv < self.parsed.end(); kv++:
            kv.free()
        free(self.parsed.ptr)
        self.parsed = List[TOMLKeyVal]{}


def looks_like_end_of_line(s: byte*) -> bool:
    while *s == ' ' or *s == '\t':
        s++
    return *s == '\n' or *s == '\0' or *s == '#'  # allow comments at end of line


class TOMLParser:
    failed: bool
    ptr: byte*
    root_table: List[TOMLKeyVal]
    current_table: List[TOMLKeyVal]*

    # Names of many methods are according to this:
    # https://github.com/toml-lang/toml/blob/bcbbd1c1f03473ffe97b8bf26a0fc945efe2b4a1/toml.abnf

    # Always advances self.ptr or fails. Called repeatedly.
    def parse(self) -> None:
        while (not self.failed) and *self.ptr != '\0':
            match *self.ptr:
                case ' ' | '\t' | '\n':
                    self.ptr++
                case '#':
                    self.comment()
                case '[':
                    if starts_with(self.ptr, "[["):
                        self.array_table()
                    else:
                        self.std_table()
                    if not self.failed and not looks_like_end_of_line(self.ptr):
                        self.failed = True
                case _:
                    self.keyval()
                    if not self.failed and not looks_like_end_of_line(self.ptr):
                        self.failed = True

    def ws(self) -> None:
        while *self.ptr == ' ' or *self.ptr == '\t':
            self.ptr++

    def comment(self) -> None:
        assert not self.failed
        assert *self.ptr == '#'
        while *self.ptr != '\0' and *self.ptr != '\n':
            b = *self.ptr
            if not (b >= 128 or b == '\t' or (32 <= b and b <= 126)):
                self.failed = True
                return
            self.ptr++

    def keyval(self) -> None:
        value_dest_ptr = self.key()
        self.ws()
        if *self.ptr != '=':
            self.failed = True
            return
        self.ptr++
        self.ws()
        *value_dest_ptr = self.val()

    # Returns a pointer where the corresponding value should be stored.
    #
    # Not exactly right according to the spec, because this ends with a call to
    # .ws() but a key shouldn't include trailing whitespace. We'll see if that
    # matters, maybe not...
    def key(self) -> TOMLValue*:
        value_ptr = self.simple_key(NULL)
        if self.failed:
            return NULL
        assert value_ptr != NULL
        self.ws()
        while *self.ptr == '.':
            self.ptr++
            self.ws()
            value_ptr = self.simple_key(value_ptr)
            if self.failed:
                return NULL
            assert value_ptr != NULL
            self.ws()
        return value_ptr

    def simple_key(self, parent_value: TOMLValue*) -> TOMLValue*:
        key: byte*
        match *self.ptr:
            case '"':
                key = self.basic_string()
            case '\'':
                key = self.literal_string()
            case _:
                n = 0
                while (
                    is_ascii_letter(self.ptr[n])
                    or is_ascii_digit(self.ptr[n])
                    or self.ptr[n] == '-'
                    or self.ptr[n] == '_'
                ):
                    n++
                if n == 0:
                    self.failed = True
                    return NULL
                key = NULL
                asprintf(&key, "%.*s", n, self.ptr)
                assert key != NULL
                self.ptr = &self.ptr[n]

        if parent_value == NULL:
            # The first part of the key (the foo of foo.bar.baz)
            target_table = self.current_table
        else:
            # Go to a part within an already chosen key
            # TODO: what exactly should happen here?
            assert parent_value.kind == TOMLValueKind.Unset or parent_value.kind == TOMLValueKind.Table
            parent_value.kind = TOMLValueKind.Table
            target_table = &parent_value.table

        # Does this key already exists? If it exists, value will go there
        for p = target_table.ptr; p < target_table.end(); p++:
            if strcmp(p.key, key) == 0:
                free(key)
                return &p.value

        # Key not found --> create new table
        target_table.append(TOMLKeyVal{key = key})
        return &target_table.end()[-1].value

    def val(self) -> TOMLValue:
        assert not self.failed

        match *self.ptr:
            case '"':
                if starts_with(self.ptr, "\"\"\""):
                    s = self.ml_basic_string()
                else:
                    s = self.basic_string()
                assert s != NULL
                return TOMLValue{kind = TOMLValueKind.String, string = s}
            case '\'':
                if starts_with(self.ptr, "'''"):
                    s = self.ml_literal_string()
                else:
                    s = self.literal_string()
                assert s != NULL
                return TOMLValue{kind = TOMLValueKind.String, string = s}
            case 't':
                if not starts_with(self.ptr, "true"):
                    self.failed = True
                    return TOMLValue{}
                self.ptr = &self.ptr[4]
                return TOMLValue{kind = TOMLValueKind.Boolean, boolean = True}
            case '+' | '-' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9':
                return TOMLValue{kind = TOMLValueKind.Integer, integer = self.integer()}
            case '[':
                return self.array()
            case _:
                self.failed = True
                return TOMLValue{}

    def unsigned_integer_in_base(self, base: int) -> uint64:
        first_digit_value = hexdigit_value(*self.ptr)
        if first_digit_value == -1 or first_digit_value >= base:
            self.failed = True
            return 0

        result: uint64 = first_digit_value as uint64
        self.ptr++
        while True:
            if *self.ptr == '_':
                self.ptr++
                continue
            v = hexdigit_value(*self.ptr)
            if v == -1:
                # TODO: ending with _ shouldn't be allowed
                return result
            if v >= base:
                self.failed = True
                return 0
            # Don't allow 01, 001 etc
            if base == 10 and first_digit_value == 0:
                self.failed = True
                return 0
            new_result = result*(base as uint64) + (v as uint64)
            if new_result/base != result:
                # it overflowed
                self.failed = True
                return 0
            result = new_result
            self.ptr++

    def integer(self) -> int64:
        assert not self.failed

        sign = 1
        if starts_with(self.ptr, "0b"):
            base = 2
        elif starts_with(self.ptr, "0o"):
            base = 8
        elif starts_with(self.ptr, "0x"):
            base = 16
        else:
            base = 10
            # Only base 10 numbers can be negative in TOML!
            if *self.ptr == '-':
                sign = -1
            if *self.ptr == '+' or *self.ptr == '-':
                self.ptr++

        if base != 10:
            self.ptr = &self.ptr[2]

        u = self.unsigned_integer_in_base(base)
        # Special casing to make sure the most negative int64 value works.
        # Its absolute value doesn't fit in int64.
        # TODO: this needed?
        if sign == -1 and u == (INT64_MAX as uint64) + 1:
            return INT64_MIN
        return sign*(u as int64)

    def basic_string(self) -> byte*:
        assert *self.ptr == '"'
        self.ptr++

        result = List[byte]{}
        while *self.ptr != '"' and *self.ptr != '\0' and not self.failed:
            self.basic_char(&result)
        self.ptr++

        result.append('\0')
        return result.ptr

    def basic_char(self, out: List[byte]*) -> None:
        assert not self.failed
        if *self.ptr == '\\':
            self.escaped(out)
        else:
            out.append(self.basic_unescaped())

    def basic_unescaped(self) -> byte:
        assert not self.failed

        if (
            *self.ptr == '\t'
            or *self.ptr == ' '
            or *self.ptr == '!'
            or (*self.ptr >= 0x23 and *self.ptr <= 0x5b)
            or (*self.ptr >= 0x5d and *self.ptr <= 0x7e)
            or *self.ptr >= 128  # TODO: reject invalid UTF-8
        ):
            return *self.ptr++
        self.failed = True
        return '\0'

    def read_escaped_char(self, prefix_char: byte, num_hex_digits: int) -> byte[5]:
        assert not self.failed

        codepoint: uint32 = 0
        for i = 0; i < num_hex_digits; i++:
            v = hexdigit_value(self.ptr[i])
            if v == -1:
                self.failed = True
                return ""
            codepoint <<= 4
            codepoint |= v as uint32

        if codepoint == 0:
            self.failed = True
            return ""

        result = utf8_encode_char(codepoint)
        if result[0] == '\0':
            self.failed = True
            return ""

        self.ptr = &self.ptr[num_hex_digits]
        return result

    def escaped(self, out: List[byte]*) -> None:
        assert not self.failed
        assert *self.ptr == '\\'
        self.ptr++
        match *self.ptr++:
            case '"':
                out.append('"')
            case '\\':
                out.append('\\')
            case 'b':
                out.append(0x08)  # Jou doesn't have \b
            case 'e':
                out.append(0x1b)  # Jou doesn't have \e
            case 'f':
                out.append(0x0c)  # Jou doesn't have \f
            case 'n':
                out.append('\n')
            case 'r':
                out.append('\r')
            case 't':
                out.append('\t')
            case 'x':
                s = self.read_escaped_char('x', 2)
                out.extend_from_ptr(s, strlen(s))
            case 'u':
                s = self.read_escaped_char('u', 4)
                out.extend_from_ptr(s, strlen(s))
            case 'U':
                s = self.read_escaped_char('U', 8)
                out.extend_from_ptr(s, strlen(s))
            case _:
                self.failed = True

    def literal_string(self) -> byte*:
        assert *self.ptr == '\''
        self.ptr++
        result = List[byte]{}
        while *self.ptr != '\'':
            result.append(self.literal_char())
            if self.failed:
                free(result.ptr)
                return NULL
        self.ptr++
        result.append('\0')
        return result.ptr

    def literal_char(self) -> byte:
        if (
            *self.ptr == '\t'
            or (0x20 <= *self.ptr and *self.ptr <= 0x26)
            or (0x28 <= *self.ptr and *self.ptr <= 0x7e)
            or *self.ptr >= 128  # TODO: reject invalid UTF-8
        ):
            return *self.ptr++
        self.failed = True
        return '\0'

    def ml_basic_string(self) -> byte*:
        assert starts_with(self.ptr, "\"\"\"")
        self.ptr = &self.ptr[3]
        if *self.ptr == '\n':
            self.ptr++
        result = List[byte]{}
        while not (starts_with(self.ptr, "\"\"\"") and not starts_with(self.ptr, "\"\"\"\"")) and not self.failed:
            if *self.ptr == '\n':
                self.ptr++
                result.append('\n')
            elif *self.ptr == '"':
                self.ptr++
                result.append('"')
            elif *self.ptr == '\\' and self.ptr[1 + strspn(&self.ptr[1], " \t")] == '\n':
                # Line continuation backslash causes all whitespace to be
                # trimmed after the backslash. TOML is weird :)
                self.ptr++
                while *self.ptr == ' ' or *self.ptr == '\t' or *self.ptr == '\n':
                    self.ptr++
            else:
                self.basic_char(&result)
        self.ptr = &self.ptr[3]
        result.append('\0')
        return result.ptr

    def ml_literal_string(self) -> byte*:
        assert starts_with(self.ptr, "'''")
        self.ptr = &self.ptr[3]
        if *self.ptr == '\n':
            self.ptr++
        result = List[byte]{}
        while not (starts_with(self.ptr, "'''") and not starts_with(self.ptr, "''''")) and not self.failed:
            if *self.ptr == '\n':
                self.ptr++
                result.append('\n')
            elif *self.ptr == '\'':
                self.ptr++
                result.append('\'')
            else:
                result.append(self.literal_char())
        self.ptr = &self.ptr[3]
        result.append('\0')
        return result.ptr

    def std_table(self) -> None:
        assert starts_with(self.ptr, "[")
        self.ptr++
        self.ws()

        self.current_table = &self.root_table
        value_ptr = self.key()
        if self.failed:
            return

        assert value_ptr != NULL
        match value_ptr.kind:
            case TOMLValueKind.Unset:
                # Just created for this
                *value_ptr = TOMLValue{kind = TOMLValueKind.Table}
            case TOMLValueKind.Table:
                # Add more stuff to an existing table
                # TODO: should only be allowed for automatically created tables
                pass
            case _:
                self.failed = True
                return

        self.current_table = &value_ptr.table

        self.ws()
        if *self.ptr != ']':
            self.failed = True
            return
        self.ptr++

    def array_table(self) -> None:
        assert False

    def array(self) -> TOMLValue:
        assert not self.failed
        result = List[TOMLValue]{}

        assert *self.ptr == '['
        self.ptr++
        self.ws_comment_newline()
        while *self.ptr != ']':
            result.append(self.val())
            if self.failed:
                for p = result.ptr; p < result.end(); p++:
                    p.free()
                free(result.ptr)
                return TOMLValue{}
            self.ws_comment_newline()
            if *self.ptr == ']':
                break
            if *self.ptr != ',':
                self.failed = True
            self.ptr++
            self.ws_comment_newline()

        assert *self.ptr == ']'
        self.ptr++
        return TOMLValue{kind = TOMLValueKind.Array, array = result}

    def ws_comment_newline(self) -> None:
        while *self.ptr == ' ' or *self.ptr == '\t' or *self.ptr == '\n' or *self.ptr == '#':
            if *self.ptr == '#':
                self.comment()
            else:
                self.ptr++


def print_toml_value(value: TOMLValue, depth: int) -> None:
    match value.kind:
        case TOMLValueKind.Unset:
            puts("UNSET")
        case TOMLValueKind.Array:
            printf("array:\n")
            for p = value.array.ptr; p < value.array.end(); p++:
                printf("%*s", 2*(depth + 1), "")
                print_toml_value(*p, depth + 1)
        case TOMLValueKind.Table:
            printf("table:\n")
            for kv = value.table.ptr; kv < value.table.end(); kv++:
                printf("%*s", 2*(depth + 1), "")
                printf("%s = ", kv.key)
                print_toml_value(kv.value, depth + 1)
        case TOMLValueKind.String:
            printf("string: %s\n", value.string)
        case TOMLValueKind.Boolean:
            puts("boolean: true" if value.boolean else "boolean: false")
        case TOMLValueKind.Integer:
            printf("integer: %lld\n", value.integer)


def read_stdin_to_string() -> byte*:
    bytes_list = List[byte]{}

    buf: byte[4096]
    while True:
        num_read = fread(buf, 1, sizeof buf, get_stdin())
        if num_read == 0:
            assert ferror(get_stdin()) == 0
            break
        bytes_list.extend_from_ptr(buf, num_read)

    lineno = 1
    for p = bytes_list.ptr; p < bytes_list.end(); p++:
        match *p:
            case '\n':
                lineno++
            case '\0':
                fprintf(get_stderr(), "got zero byte from stdin, would be invalid TOML\n")
                exit(1)

    bytes_list.append('\0')
    return bytes_list.ptr


# Replaces \r\n with \n in-place
def fix_newlines(s: byte*) -> None:
    out = s
    while *s != '\0':
        if starts_with(s, "\r\n"):
            s++
        *out++ = *s++
    *out = '\0'


def parse_toml(string: byte*) -> TOMLParseResult:
    assert string != NULL
    string = strdup(string)
    assert string != NULL
    fix_newlines(string)

    # TODO: ensure it's valid UTF-8

    parser = TOMLParser{ptr = string}
    parser.current_table = &parser.root_table  # the "default section"
    parser.parse()

    if parser.failed:
        for p = parser.root_table.ptr; p < parser.root_table.end(); p++:
            p.free()
        free(parser.root_table.ptr)

        # Figure out the line number where it failed
        result = TOMLParseResult{failed = True, error_lineno = 1}
        while parser.ptr --> string:
            if *parser.ptr == '\n':
                result.error_lineno++
    else:
        result = TOMLParseResult{parsed = parser.root_table}

    free(string)
    return result


# TODO: take value as pointer
def toml_to_json(value: TOMLValue, jb: JSONBuilder*) -> None:
    match value.kind:
        case TOMLValueKind.Unset:
            jb.string("THIS SHOULD NEVER HAPPEN!!!!")
        case TOMLValueKind.Array:
            jb.begin_array()
            for p = value.array.ptr; p < value.array.end(); p++:
                toml_to_json(*p, jb)
            jb.end_array()
        case TOMLValueKind.Table:
            jb.begin_object()
            for kv = value.table.ptr; kv < value.table.end(); kv++:
                jb.key(kv.key)
                toml_to_json(kv.value, jb)
            jb.end_object()
        case TOMLValueKind.String:
            jb.begin_object()
            jb.key("type").string("string")
            jb.key("value").string(value.string)
            jb.end_object()
        case TOMLValueKind.Boolean:
            jb.string("TODO boolean")
        case TOMLValueKind.Integer:
            jb.begin_object()
            jb.key("type").string("integer")
            s: byte[100]
            sprintf(s, "%lld", value.integer)
            jb.key("value").string(s)
            jb.end_object()


# For testing with the official TOML test suite and experimenting.
# Reads TOML from stdin and prints JSON compatible with the TOML test suite.
def main() -> int:
    string = read_stdin_to_string()
    result = parse_toml(string)
    free(string)

    if result.failed:
        fprintf(get_stderr(), "TOML syntax error on line %d\n", result.error_lineno)
        return 1

    jb = JSONBuilder{pretty_print = 4}
    toml_to_json(TOMLValue{kind = TOMLValueKind.Table, table = result.parsed}, &jb)
    result.free()

    json = jb.finish()
    puts(json)
    free(json)

    return 0
