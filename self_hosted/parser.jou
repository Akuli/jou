import "stdlib/str.jou"
import "stdlib/mem.jou"
import "./token.jou"
import "./ast.jou"
import "./errors_and_warnings.jou"

def parse_type(tokens: Token**) -> AstType:
    if not (
        (*tokens)->kind == TokenKind::Name
        or (*tokens)->is_keyword("int")
        or (*tokens)->is_keyword("long")
        or (*tokens)->is_keyword("bool")
        or (*tokens)->is_keyword("byte")
        or (*tokens)->is_keyword("void")
        or (*tokens)->is_keyword("noreturn")
    ):
        (*tokens)->fail_expected_got("a type")

    result = AstType{
        kind = AstTypeKind::Named,
        location = (*tokens)->location,
        name = (*tokens)->short_string,
    }
    ++*tokens

    while (*tokens)->is_operator("*"):
        p: AstType* = malloc(sizeof *p)
        *p = result
        result = AstType{
            location = ((*tokens)++)->location,  # TODO: shouldn't need all the parentheses
            kind = AstTypeKind::Pointer,
            value_type = p,
        }

    return result

def parse_name_type_value(tokens: Token**, expected_what_for_name: byte*) -> AstNameTypeValue:
    if (*tokens)->kind != TokenKind::Name:
        assert(expected_what_for_name != NULL)
        (*tokens)->fail_expected_got(expected_what_for_name)

    result = AstNameTypeValue{name = (*tokens)->short_string, name_location = (*tokens)->location}
    ++*tokens

    if not (*tokens)->is_operator(":"):
        (*tokens)->fail_expected_got("':' and a type after it (example: \"foo: int\")")
    ++*tokens
    result.type = parse_type(tokens)

    if (*tokens)->is_operator("="):
        ++*tokens
        p: AstExpression* = malloc(sizeof *p)
        *p = parse_expression(tokens)
        result.value = p

    return result

def parse_function_signature(tokens: Token**) -> AstSignature:
    if (*tokens)->kind != TokenKind::Name:
        (*tokens)->fail_expected_got("a function name")

    result = AstSignature{
        name_location = (*tokens)->location,
        name = (*tokens)->short_string,
    }
    ++*tokens

    if not (*tokens)->is_operator("("):
        (*tokens)->fail_expected_got("a '(' to denote the start of function arguments")
    ++*tokens

    while not (*tokens)->is_operator(")"):
        if result.takes_varargs:
            fail((*tokens)->location, "if '...' is used, it must be the last parameter")

        if (*tokens)->is_operator("..."):
            result.takes_varargs = True
            ++*tokens
        else:
            arg = parse_name_type_value(tokens, "an argument name")
            if arg.value != NULL:
                fail(arg.value->location, "arguments cannot have default values")

            result.args = realloc(result.args, sizeof result.args[0] * (result.nargs+1))
            result.args[result.nargs++] = arg

        if not (*tokens)->is_operator(","):
            break
        ++*tokens

    if not (*tokens)->is_operator(")"):
        (*tokens)->fail_expected_got("a ')'")
    ++*tokens

    # Special case for common typo:   def foo():
    if (*tokens)->is_operator(":"):
        fail((*tokens)->location, "return type must be specified with '->', or with '-> void' if the function doesn't return anything")
    if not (*tokens)->is_operator("->"):
        (*tokens)->fail_expected_got("a '->'")
    ++*tokens

    result.return_type = parse_type(tokens)
    return result

def get_actual_import_path(path_token: Token*, stdlib_path: byte*) -> byte*:
    assert(path_token->kind == TokenKind::String)
    assert(starts_with(path_token->long_string, "stdlib/"))

    path = malloc(strlen(path_token->long_string) + 100)
    sprintf(path, "%s/%s", stdlib_path, &path_token->long_string[7])
    return path

def parse_call(tokens: Token**, open_paren: byte*, close_paren: byte*) -> AstCall:
    assert((*tokens)->kind == TokenKind::Name)  # must be checked when calling this function
    result = AstCall{location = (*tokens)->location, called_name = (*tokens)->short_string}
    ++*tokens

    if not (*tokens)->is_operator(open_paren):
        expected = malloc(100)
        sprintf(expected, "a '%c' to denote the start of arguments", open_paren)
        (*tokens)->fail_expected_got(expected)
    ++*tokens

    while not (*tokens)->is_operator(close_paren):
        result.args = realloc(result.args, sizeof result.args[0] * (result.nargs+1))
        result.args[result.nargs++] = parse_expression(tokens)
        if not (*tokens)->is_operator(","):
            break
        ++*tokens

    if not (*tokens)->is_operator(close_paren):
        expected = malloc(100)
        sprintf(expected, "a '%c'", close_paren)
        (*tokens)->fail_expected_got(expected)
    ++*tokens

    return result

def parse_elementary_expression(tokens: Token**) -> AstExpression:
    expr = AstExpression{location = (*tokens)->location}

    if (*tokens)->kind == TokenKind::Int:
        expr.kind = AstExpressionKind::Int
        expr.int_value = (*tokens)->int_value
        ++*tokens
    elif (*tokens)->kind == TokenKind::Long:
        expr.kind = AstExpressionKind::Long
        expr.long_value = (*tokens)->long_value
        ++*tokens
    elif (*tokens)->kind == TokenKind::Byte:
        expr.kind = AstExpressionKind::Byte
        expr.byte_value = (*tokens)->byte_value
        ++*tokens
    elif (*tokens)->kind == TokenKind::String:
        expr.kind = AstExpressionKind::String
        expr.string = strdup((*tokens)->long_string)
        ++*tokens
    elif (*tokens)->is_keyword("True"):
        expr.kind = AstExpressionKind::Bool
        expr.bool_value = True
        ++*tokens
    elif (*tokens)->is_keyword("False"):
        expr.kind = AstExpressionKind::Bool
        expr.bool_value = False
        ++*tokens
    elif (*tokens)->is_keyword("NULL"):
        expr.kind = AstExpressionKind::Null
        ++*tokens
    elif (*tokens)->kind == TokenKind::Name and (*tokens)[1].is_operator("("):
        expr.kind = AstExpressionKind::FunctionCall
        expr.call = parse_call(tokens, "(", ")")
    elif (*tokens)->kind == TokenKind::Name and (*tokens)[1].is_operator("::") and (*tokens)[2].kind == TokenKind::Name:
        expr.kind = AstExpressionKind::GetEnumMember
        expr.enum_member = malloc(sizeof *expr.enum_member)
        *expr.enum_member = AstEnumMember{
            enum_name = (*tokens)->short_string,
            member_name = (*tokens)[2].short_string,
        }
        ++*tokens
        ++*tokens
        ++*tokens
    elif (*tokens)->kind == TokenKind::Name:
        expr.kind = AstExpressionKind::GetVariable
        expr.varname = (*tokens)->short_string
        ++*tokens
    elif (*tokens)->is_operator("("):
        ++*tokens
        expr = parse_expression(tokens)
        if not (*tokens)->is_operator(")"):
            (*tokens)->fail_expected_got("a ')'")
        ++*tokens
    else:
        (*tokens)->fail_expected_got("an expression")

    return expr

# arity = number of operands, e.g. 2 for a binary operator such as "+"
#
# This cannot be used for ++ and --, because with them we can't know the kind from
# just the token (e.g. ++ could mean pre-increment or post-increment).
def build_operator_expression(t: Token*, arity: int, operands: AstExpression*) -> AstExpression:
    assert(arity == 1 or arity == 2)
    nbytes = arity * sizeof operands[0]
    ptr = malloc(nbytes)
    memcpy(ptr, operands, nbytes)

    result = AstExpression{location = t->location, operands = ptr}

    if t->is_operator("&"):
        assert(arity == 1)
        result.kind = AstExpressionKind::AddressOf
    elif t->is_operator("["):
        assert(arity == 2)
        result.kind = AstExpressionKind::Indexing
    elif t->is_operator("=="):
        assert(arity == 2)
        result.kind = AstExpressionKind::Eq
    elif t->is_operator("!="):
        assert(arity == 2)
        result.kind = AstExpressionKind::Ne
    elif t->is_operator(">"):
        assert(arity == 2)
        result.kind = AstExpressionKind::Gt
    elif t->is_operator(">="):
        assert(arity == 2)
        result.kind = AstExpressionKind::Ge
    elif t->is_operator("<"):
        assert(arity == 2)
        result.kind = AstExpressionKind::Lt
    elif t->is_operator("<="):
        assert(arity == 2)
        result.kind = AstExpressionKind::Le
    elif t->is_operator("+"):
        assert(arity == 2)
        result.kind = AstExpressionKind::Add
    elif t->is_operator("-"):
        if arity == 2:
            result.kind = AstExpressionKind::Subtract
        else:
            result.kind = AstExpressionKind::Negate
    elif t->is_operator("*"):
        if arity == 2:
            result.kind = AstExpressionKind::Multiply
        else:
            result.kind = AstExpressionKind::Dereference
    elif t->is_operator("/"):
        assert(arity == 2)
        result.kind = AstExpressionKind::Divide
    elif t->is_operator("%"):
        assert(arity == 2)
        result.kind = AstExpressionKind::Modulo
    elif t->is_keyword("and"):
        assert(arity == 2)
        result.kind = AstExpressionKind::And
    elif t->is_keyword("or"):
        assert(arity == 2)
        result.kind = AstExpressionKind::Or
    elif t->is_keyword("not"):
        assert(arity == 1)
        result.kind = AstExpressionKind::Not
    else:
        assert(False)

    assert(result.get_arity() == arity)
    return result

def parse_expression_with_unary_operators(tokens: Token**) -> AstExpression:
    # prefix = sequneces of 0 or more unary operator tokens: start,start+1,...,end-1
    prefix_start = *tokens
    while (
        (*tokens)->is_operator("++")
        or (*tokens)->is_operator("--")
        or (*tokens)->is_operator("&")
        or (*tokens)->is_operator("*")
        or (*tokens)->is_keyword("sizeof")
    ):
        ++*tokens
    prefix_end = *tokens

    result = parse_elementary_expression(tokens)

    suffix_start = *tokens
    while (*tokens)->is_operator("++") or (*tokens)->is_operator("--"):
        ++*tokens
    suffix_end = *tokens

    while prefix_start != prefix_end or suffix_start != suffix_end:
        # ++ and -- "bind tighter", so *foo++ is equivalent to *(foo++)
        # It is implemented by always consuming ++/-- prefixes and suffixes when they exist.
        if prefix_start != prefix_end and prefix_end[-1].is_operator("++"):
            token = --prefix_end
            kind = AstExpressionKind::PreIncr
        elif prefix_start != prefix_end and prefix_end[-1].is_operator("--"):
            token = --prefix_end
            kind = AstExpressionKind::PreDecr
        elif suffix_start != suffix_end and suffix_start[0].is_operator("++"):
            token = suffix_start++
            kind = AstExpressionKind::PostIncr
        elif suffix_start != suffix_end and suffix_start[0].is_operator("--"):
            token = suffix_start++
            kind = AstExpressionKind::PostDecr
        else:
            # We don't have ++ or --, so it must be something in the prefix
            assert(prefix_start != prefix_end and suffix_start == suffix_end)
            token = --prefix_end
            if token->is_operator("*"):
                kind = AstExpressionKind::Dereference
            elif token->is_operator("&"):
                kind = AstExpressionKind::AddressOf
            elif token->is_keyword("sizeof"):
                kind = AstExpressionKind::SizeOf
            else:
                assert(False)
                kind = AstExpressionKind::SizeOf  # dummy value to silence compiler warning

        p: AstExpression* = malloc(sizeof(*p))
        *p = result
        result = AstExpression{location = token->location, kind = kind, operands = p}

    return result

def parse_expression_with_mul_and_div(tokens: Token**) -> AstExpression:
    result = parse_expression_with_unary_operators(tokens)
    while (*tokens)->is_operator("*") or (*tokens)->is_operator("/") or (*tokens)->is_operator("%"):
        t = (*tokens)++
        lhs_rhs = [result, parse_expression_with_unary_operators(tokens)]
        result = build_operator_expression(t, 2, &lhs_rhs[0])
    return result

def parse_expression_with_add(tokens: Token**) -> AstExpression:
    if (*tokens)->is_operator("-"):
        minus = (*tokens)++
    else:
        minus = NULL

    result = parse_expression_with_mul_and_div(tokens)
    if minus != NULL:
        result = build_operator_expression(minus, 1, &result)

    while (*tokens)->is_operator("+") or (*tokens)->is_operator("-"):
        t = (*tokens)++
        lhs_rhs = [result, parse_expression_with_mul_and_div(tokens)]
        result = build_operator_expression(t, 2, &lhs_rhs[0])

    return result

# "as" operator has somewhat low precedence, so that "1+2 as float" works as expected
def parse_expression_with_as(tokens: Token**) -> AstExpression:
    result = parse_expression_with_add(tokens)
    while (*tokens)->is_keyword("as"):
        as_location = ((*tokens)++)->location  # TODO: shouldn't need so many parentheses
        p: AstAsExpression* = malloc(sizeof(*p))
        *p = AstAsExpression{type = parse_type(tokens), value = result}
        result = AstExpression{
            location = as_location,
            kind = AstExpressionKind::As,
            as_expression = p,
        }
    return result

def parse_expression_with_comparisons(tokens: Token**) -> AstExpression:
    result = parse_expression_with_as(tokens)
    if (*tokens)->is_comparison():
        t = (*tokens)++
        lhs_rhs = [result, parse_expression_with_as(tokens)]
        result = build_operator_expression(t, 2, &lhs_rhs[0])
    if (*tokens)->is_comparison():
        fail((*tokens)->location, "comparisons cannot be chained")
    return result

def parse_expression_with_not(tokens: Token**) -> AstExpression:
    if (*tokens)->is_keyword("not"):
        not_token = *tokens
        ++*tokens
    else:
        not_token = NULL

    if (*tokens)->is_keyword("not"):
        fail((*tokens)->location, "'not' cannot be repeated")

    result = parse_expression_with_comparisons(tokens)
    if not_token != NULL:
        result = build_operator_expression(not_token, 1, &result)
    return result

def parse_expression_with_and_or(tokens: Token**) -> AstExpression:
    result = parse_expression_with_not(tokens)
    got_and = False
    got_or = False

    while True:
        if (*tokens)->is_keyword("and"):
            got_and = True
        elif (*tokens)->is_keyword("or"):
            got_or = True
        else:
            break
        if got_and and got_or:
            fail((*tokens)->location, "'and' cannot be chained with 'or', you need more parentheses")

        t = (*tokens)++
        lhs_rhs = [result, parse_expression_with_not(tokens)]
        result = build_operator_expression(t, 2, &lhs_rhs[0])

    return result

def parse_expression(tokens: Token**) -> AstExpression:
    return parse_expression_with_and_or(tokens)

# reverse code golfing: https://xkcd.com/1960/
def determine_the_kind_of_a_statement_that_starts_with_an_expression(
    this_token_is_after_that_initial_expression: Token*
) -> AstStatementKind:
    if this_token_is_after_that_initial_expression->is_operator("="):
        return AstStatementKind::Assign
    if this_token_is_after_that_initial_expression->is_operator("+="):
        return AstStatementKind::InPlaceAdd
    if this_token_is_after_that_initial_expression->is_operator("-="):
        return AstStatementKind::InPlaceSubtract
    if this_token_is_after_that_initial_expression->is_operator("*="):
        return AstStatementKind::InPlaceMultiply
    if this_token_is_after_that_initial_expression->is_operator("/="):
        return AstStatementKind::InPlaceDivide
    if this_token_is_after_that_initial_expression->is_operator("%="):
        return AstStatementKind::InPlaceModulo
    return AstStatementKind::ExpressionStatement

# does not eat a trailing newline
def parse_oneline_statement(tokens: Token**) -> AstStatement:
    result = AstStatement{ location = (*tokens)->location }
    if (*tokens)->is_keyword("return"):
        ++*tokens
        result.kind = AstStatementKind::Return
        if (*tokens)->kind != TokenKind::Newline:
            result.return_value = malloc(sizeof *result.return_value)
            *result.return_value = parse_expression(tokens)
    elif (*tokens)->is_keyword("break"):
        ++*tokens
        result.kind = AstStatementKind::Break
    elif (*tokens)->is_keyword("continue"):
        ++*tokens
        result.kind = AstStatementKind::Continue
    elif (*tokens)->kind == TokenKind::Name and (*tokens)[1].is_operator(":"):
        # "foo: int" creates a variable "foo" of type "int"
        result.kind = AstStatementKind::DeclareLocalVar
        result.var_declaration = parse_name_type_value(tokens, NULL)
    else:
        expr = parse_expression(tokens)
        result.kind = determine_the_kind_of_a_statement_that_starts_with_an_expression(*tokens)
        if result.kind == AstStatementKind::ExpressionStatement:
            if not expr.can_have_side_effects():
                fail(expr.location, "not a valid statement")
            result.expression = expr
        else:
            ++*tokens
            result.assignment = AstAssignment{target = expr, value = parse_expression(tokens)}
            if (*tokens)->is_operator("="):
                # Would fail elsewhere anyway, but let's make the error message clear
                fail((*tokens)->location, "only one variable can be assigned at a time")

    return result

def parse_if_statement(tokens: Token**) -> AstIfStatement:
    ifs_and_elifs: AstConditionAndBody* = NULL
    n = 0

    assert((*tokens)->is_keyword("if"))
    while True:
        ++*tokens
        cond = parse_expression(tokens)
        body = parse_body(tokens)
        ifs_and_elifs = realloc(ifs_and_elifs, sizeof ifs_and_elifs[0] * (n+1))
        ifs_and_elifs[n++] = AstConditionAndBody{condition = cond, body = body}
        if not (*tokens)->is_keyword("elif"):
            break

    if (*tokens)->is_keyword("else"):
        ++*tokens
        else_body = parse_body(tokens)
    else:
        else_body = AstBody{}

    return AstIfStatement{
        if_and_elifs = ifs_and_elifs,
        n_if_and_elifs = n,
        else_body = else_body,
    }

def parse_while_loop(tokens: Token**) -> AstConditionAndBody:
    assert((*tokens)->is_keyword("while"))
    ++*tokens
    cond = parse_expression(tokens)
    body = parse_body(tokens)
    return AstConditionAndBody{condition = cond, body = body}

def parse_for_loop(tokens: Token**) -> AstForLoop:
    assert((*tokens)->is_keyword("for"))
    ++*tokens

    init: AstStatement* = malloc(sizeof *init)
    incr: AstStatement* = malloc(sizeof *incr)

    *init = parse_oneline_statement(tokens)
    if not (*tokens)->is_operator(";"):
        (*tokens)->fail_expected_got("a ';'")
    ++*tokens
    cond = parse_expression(tokens)
    if not (*tokens)->is_operator(";"):
        (*tokens)->fail_expected_got("a ';'")
    ++*tokens
    *incr = parse_oneline_statement(tokens)

    return AstForLoop{
        init = init,
        cond = cond,
        incr = incr,
        body = parse_body(tokens),
    }

def eat_newline(tokens: Token**) -> void:
    if (*tokens)->kind != TokenKind::Newline:
        (*tokens)->fail_expected_got("end of line")
    ++*tokens

def parse_statement(tokens: Token**) -> AstStatement:
    if (*tokens)->is_keyword("if"):
        return AstStatement{
            location = (*tokens)->location,
            kind = AstStatementKind::If,
            if_statement = parse_if_statement(tokens),
        }
    if (*tokens)->is_keyword("for"):
        return AstStatement{
            location = (*tokens)->location,
            kind = AstStatementKind::ForLoop,
            for_loop = parse_for_loop(tokens),
        }
    if (*tokens)->is_keyword("while"):
        return AstStatement{
            location = (*tokens)->location,
            kind = AstStatementKind::WhileLoop,
            while_loop = parse_while_loop(tokens),
        }
    result = parse_oneline_statement(tokens)
    eat_newline(tokens)
    return result

def parse_start_of_body(tokens: Token**) -> void:
    if not (*tokens)->is_operator(":"):
        (*tokens)->fail_expected_got("':' followed by a new line with more indentation")
    ++*tokens

    if (*tokens)->kind != TokenKind::Newline:
        (*tokens)->fail_expected_got("a new line with more indentation after ':'")
    ++*tokens

    if (*tokens)->kind != TokenKind::Indent:
        (*tokens)->fail_expected_got("more indentation after ':'")
    ++*tokens

def parse_body(tokens: Token**) -> AstBody:
    parse_start_of_body(tokens)

    result: AstStatement* = NULL
    n = 0
    while (*tokens)->kind != TokenKind::Dedent:
        result = realloc(result, sizeof result[0] * (n+1))
        result[n++] = parse_statement(tokens)
    ++*tokens

    return AstBody{ statements = result, nstatements = n }

def parse_funcdef(tokens: Token**) -> AstFunction:
    return AstFunction{
        signature = parse_function_signature(tokens),
        body = parse_body(tokens),
    }

def parse_classdef(tokens: Token**) -> AstClassDef:
    if (*tokens)->kind != TokenKind::Name:
        (*tokens)->fail_expected_got("a name for the class")

    result = AstClassDef{name = ((*tokens)++)->short_string}

    parse_start_of_body(tokens)
    while (*tokens)->kind != TokenKind::Dedent:
        if (*tokens)->is_keyword("def"):
            result.methods = realloc(result.methods, sizeof result.methods[0] * (result.nmethods + 1))
            result.methods[result.nmethods++] = parse_funcdef(tokens)
        else:
            field = parse_name_type_value(tokens, "a method or a class field")
            if field.value != NULL:
                fail(field.value->location, "class fields cannot have default values")
            result.fields = realloc(result.fields, sizeof result.fields[0] * (result.nfields + 1))
            result.fields[result.nfields++] = field
            eat_newline(tokens)

    ++*tokens
    return result

def parse_toplevel_node(dest: AstFile*, tokens: Token**, stdlib_path: byte*) -> void:
    ts = AstToplevelStatement{location = (*tokens)->location}

    if (*tokens)->is_keyword("import"):
        ++*tokens
        ts.the_import.specified_path = strdup((*tokens)->long_string)
        ts.the_import.resolved_path = get_actual_import_path(*tokens, stdlib_path)
        ++*tokens
        eat_newline(tokens)

    elif (*tokens)->is_keyword("def"):
        ++*tokens
        ts.kind = AstToplevelStatementKind::Function
        ts.function = parse_funcdef(tokens)

    elif (*tokens)->is_keyword("declare"):
        ++*tokens
        if (*tokens)->is_keyword("global"):
            ++*tokens
            ts.kind = AstToplevelStatementKind::GlobalVariableDeclaration
            ts.global_var = parse_name_type_value(tokens, "a variable name")
            if ts.global_var.value != NULL:
                fail(
                    ts.global_var.value->location,
                    "a value cannot be given when declaring a global variable",
                )
        else:
            ts.kind = AstToplevelStatementKind::Function
            ts.function.signature = parse_function_signature(tokens)
        eat_newline(tokens)

    elif (*tokens)->is_keyword("class"):
        ++*tokens
        ts.kind = AstToplevelStatementKind::ClassDefinition
        ts.classdef = parse_classdef(tokens)

    else:
        (*tokens)->fail_expected_got("a definition or declaration")

    dest->body = realloc(dest->body, sizeof dest->body[0] * (dest->body_len + 1))
    dest->body[dest->body_len++] = ts

def parse(tokens: Token*, stdlib_path: byte*) -> AstFile:
    result = AstFile{path = tokens[0].location.path}
    while tokens->kind != TokenKind::EndOfFile:
        parse_toplevel_node(&result, &tokens, stdlib_path)
    return result
