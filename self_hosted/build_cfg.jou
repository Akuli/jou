#include "jou_compiler.h"

class State:
    filetypes: FileTypes*
    fomtypes: FunctionOrMethodTypes*
    cfg: CfGraph*
    current_block: CfBlock*
    breakstack: CfBlock**
    continuestack: CfBlock**
    nloops: int


def find_local_var_cf(st: State*, name: byte*) -> LocalVariable*:
    for var = st->cfg->locals; var < &st->cfg->locals[st->cfg->nlocals]; var++:
        if strcmp((*var)->name, name) == 0:
            return *var
    return NULL

def add_local_var(st: State*, t: Type*) -> LocalVariable*:
    var: LocalVariable* = calloc(1, sizeof *var)
    var->id = st->cfg->nlocals
    var->type = t

    st->cfg->locals = realloc(st->cfg->locals, sizeof(st->cfg->locals[0]) * (st->cfg->nlocals + 1))
    assert st->cfg->locals != NULL
    st->cfg->locals[st->cfg->nlocals++] = var

    return var


def get_expr_types(st: State*, expr: AstExpression*) -> ExpressionTypes*:
    # TODO: a fancy binary search algorithm (need to add sorting)
    assert st->fomtypes != NULL
    for i = 0; i < st->fomtypes->n_expr_types; i++:
        if st->fomtypes->expr_types[i]->expr == expr:
            return st->fomtypes->expr_types[i]
    return NULL


def add_block(st: State*) -> CfBlock*:
    block: CfBlock* = calloc(1, sizeof *block)

    st->cfg->all_blocks = realloc(st->cfg->all_blocks, sizeof(st->cfg->all_blocks[0]) * (st->cfg->n_all_blocks + 1))
    assert st->cfg->all_blocks != NULL
    st->cfg->all_blocks[st->cfg->n_all_blocks++] = block

    return block


def add_jump(
    st: State*,
    branchvar: LocalVariable*,
    iftrue: CfBlock*,
    iffalse: CfBlock*,
    new_current_block: CfBlock*,
) -> None:
    assert (iftrue != NULL and iffalse != NULL) or (iftrue == NULL and iffalse == NULL and branchvar == NULL)
    if iftrue != iffalse:
        assert branchvar != NULL
        assert branchvar->type == boolType

    st->current_block->branchvar = branchvar;
    st->current_block->iftrue = iftrue;
    st->current_block->iffalse = iffalse;
    if new_current_block == NULL:
        st->current_block = add_block(st)
    else:
        st->current_block = new_current_block


# returned pointer is only valid until next call to add_instruction()
def add_instruction(
    st: State*,
#    location: Location,
#    k: CfInstructionKind,
    #const union CfInstructionData *dat,  # TODO: won't work
#    operands: LocalVariable**,  # NULL terminated, or NULL for empty
#    destvar: LocalVariable*,
    ins: CfInstruction,
) -> CfInstruction*:
    #ins = CfInstruction{location=location, kind=k, destvar=destvar}
    #if (dat)
    #    ins.data=*dat;
#
#    while operands != NULL and operands[ins.noperands] != NULL:
#        ins.noperands++
#    if ins.noperands > 0:
#        nbytes = sizeof(ins.operands[0]) * ins.noperands
#        ins.operands = malloc(nbytes)
#        memcpy(ins.operands, operands, nbytes)

    st->current_block->instructions = realloc(st->current_block->instructions, sizeof(st->current_block->instructions[0]) * (st->current_block->ninstructions + 1))
    assert st->current_block->instructions != NULL
    st->current_block->instructions[st->current_block->ninstructions++] = ins

    return &st->current_block->instructions[st->current_block->ninstructions - 1]


# TODO: do we need this?
def add_unary_op(
    st: State*,
    location: Location,
    op: CfInstructionKind,
    arg: LocalVariable*,
    target: LocalVariable*,
) -> None:
    ins = CfInstruction{location = location, kind = op, destvar = target}
    operands = [arg, NULL as LocalVariable*]
    ins.set_operands(operands)
    add_instruction(st, ins)


# TODO: do we need this?
def add_binary_op(
    st: State*,
    location: Location,
    op: CfInstructionKind,
    lhs: LocalVariable*,
    rhs: LocalVariable*,
    target: LocalVariable*,
) -> None:
    ins = CfInstruction{location = location, kind = op, destvar = target}
    operands = [lhs, rhs, NULL as LocalVariable*]
    ins.set_operands(operands)
    add_instruction(st, ins)


# TODO: do we need this?
def add_constant(st: State*, loc: Location, c: Constant, target: LocalVariable*) -> None:
    ins = CfInstruction{location = location, kind = op, constant = copy_constant(c), destvar = target}
    add_instruction(st, ins)


def build_bool_to_int_conversion(
    st: State*,
    boolvar: LocalVariable*,
    location: Location,
    t: Type*,
) -> LocalVariable*:
    assert is_integer_type(t)
    result: LocalVariable* = add_local_var(st, t)

    set1 = add_block(st)
    set0 = add_block(st)
    done = add_block(st)

    add_jump(st, boolvar, set1, set0, set1)
    add_constant(st, location, int_constant(t, 1), result)->hide_unreachable_warning = True
    add_jump(st, NULL, done, done, set0)
    add_constant(st, location, int_constant(t, 0), result)->hide_unreachable_warning = True
    add_jump(st, NULL, done, done, done)

    return result


def build_cast(
    st: State*,
    obj: LocalVariable*,
    to: Type *,
    location: Location,
) -> LocalVariable*:
    if obj->type == to:
        return obj

    if is_pointer_type(obj->type) and is_pointer_type(to):
        result = add_local_var(st, to)
        add_unary_op(st, location, CfInstructionKind::PtrCast, obj, result)
        return result

    if is_number_type(obj->type) and is_number_type(to):
        result = add_local_var(st, to)
        add_unary_op(st, location, CfInstructionKind::NumCast, obj, result)
        return result

    if is_number_type(obj->type) and obj->type->data.width_in_bits == 64 and is_pointer_type(to):
        result = add_local_var(st, to)
        add_unary_op(st, location, CfInstructionKind::Int64ToPtr, obj, result)
        return result

    if is_integer_type(obj->type) or to->kind == TypeKind::Enum:
        i32var = add_local_var(st, intType)
        result = add_local_var(st, to)
        add_unary_op(st, location, CfInstructionKind::NumCast, obj, i32var)
        add_unary_op(st, location, CfInstructionKind::Int32ToEnum, i32var, result)
        return result

    if obj->type->kind == TypeKind::Enum and is_integer_type(to):
        i32var = add_local_var(st, intType)
        result = add_local_var(st, to)
        add_unary_op(st, location, CfInstructionKind::EnumToInt32, obj, i32var)
        add_unary_op(st, location, CfInstructionKind::NumCast, i32var, result)
        return result

    if obj->type == boolType and is_integer_type(to):
        return build_bool_to_int_conversion(st, obj, location, to)

    if is_pointer_type(obj->type) and is_integer_type(to) and to->data.width_in_bits == 64:
        result = add_local_var(st, to)
        add_unary_op(st, location, CfInstructionKind::PtrToInt64, obj, result)
        return result

    assert False


def build_bool_eq(st: State*, location: Location, a: LocalVariable*, b: LocalVariable*) -> LocalVariable*:
    assert a->type == boolType
    assert b->type == boolType

    # Pseudo code:
    #
    #    if a:
    #        result = b
    #    else:
    #        result = not b
    result = add_local_var(st, boolType)

    atrue = add_block(st)
    afalse = add_block(st)
    done = add_block(st)

    # if a:
    add_jump(st, a, atrue, afalse, atrue)

    # result = b
    add_unary_op(st, location, CfInstructionKind::VarCpy, b, result)

    # else:
    add_jump(st, NULL, done, done, afalse)

    # result = not b
    add_unary_op(st, location, CF_BOOL_NEGATE, b, result)

    add_jump(st, NULL, done, done, done)
    return result


static const LocalVariable *build_binop(
    st: State*,
    op: AstExpressionKind,
    location: Location,
    lhs: LocalVariable*,
    rhs: LocalVariable*,
    result_type: Type*,
) -> LocalVariable*:
    got_bools = lhs->type == boolType and rhs->type == boolType
    got_numbers = is_number_type(lhs->type) and is_number_type(rhs->type)
    got_pointers = is_pointer_type(lhs->type) and is_pointer_type(rhs->type)
    assert got_bools or got_numbers or got_pointers

    negate = False
    swap = False

    destvar: LocalVariable*
    if got_bools:
        assert result_type == boolType
        destvar = build_bool_eq(st, location, lhs, rhs)
        assert op == AstExpressionKind::Eq or op == AstExpressionKind::Ne
        negate = (op == AstExpressionKind::Ne)
    else:
        destvar = add_local_var(st, result_type)
        k: CfInstructionKind
        if op == AstExpressionKind::Add:
            k = CfInstructionKind::NumAdd
        elif op == AstExpressionKind::Sub:
            k = CF_NUM_SUB
        elif op == AstExpressionKind::Mul:
            k = CF_NUM_MUL
        elif op == AstExpressionKind::Div:
            k = CF_NUM_DIV
        elif op == AstExpressionKind::Mod:
            k = CF_NUM_MOD
        elif op == AstExpressionKind::Eq:
            k = CF_NUM_EQ
        elif op == AstExpressionKind::Ne:
            k = CF_NUM_EQ
            negate = True
        elif op == AstExpressionKind::Lt:
            k = CF_NUM_LT
        elif op == AstExpressionKind::Gt:
            k = CF_NUM_LT
            swap = True
        elif op == AstExpressionKind::Le:
            k = CF_NUM_LT
            negate = True
            swap = True
        elif op == AstExpressionKind::Ge:
            k = CF_NUM_LT
            negate = True
        else:
            assert False

        if swap:
            add_binary_op(st, location, k, rhs, lhs, destvar)
        else:
            add_binary_op(st, location, k, lhs, rhs, destvar)

    if not negate:
        return destvar;

    negated = add_local_var(st, boolType)
    add_unary_op(st, location, CF_BOOL_NEGATE, destvar, negated)
    return negated


def build_class_field_pointer(
    st: State*, instance: LocalVariable*, fieldname: byte*, location: Location
) -> LocalVariable*:
    assert instance->type->kind == TypeKind::Pointer
    assert instance->type->valuetype->kind == TypeKind::Class
    class_type = instance->type->data.valuetype;

    for f = class_type->classdata.fields; f < &class_type->classdata.fields[class_type->classdata.nfields]; f++:
        if strcmp(f->name, fieldname) == 0:
            ins = CfInstruction{
                location: location,
                kind: CfInstructionKind::PtrClassField,
            }

            assert sizeof(ins.fieldname) == sizeof(f->name)
            strcpy(ins.fieldname, f->name)

            operands = [instance, NULL]
            ins.set_operands(operands)

            result = add_local_var(st, get_pointer_type(f->type))
            add_instruction(st, ins)
            return result

    assert False


def build_class_field(
    st: State*,
    instance: LocalVariable*,
    fieldname: byte*,
    location: Location,
) -> LocalVariable*:
    ptr = add_local_var(st, get_pointer_type(instance->type))
    add_unary_op(st, location, CfInstructionKind::AddressOfLocalVar, instance, ptr)
    field_ptr = build_class_field_pointer(st, ptr, fieldname, location)
    field = add_local_var(st, field_ptr->type->data.valuetype)
    add_unary_op(st, location, CfInstructionKind::PtrLoad, field_ptr, field)
    return field


enum PreOrPost:
    Pre
    Post


def build_increment_or_decrement(
    st: State*,
    location: Location,
    inner: AstExpression*,
    pop: PreOrPost,
    diff: int,
) -> LocalVariable*:
    assert diff == 1 or diff == -1  # 1=increment, -1=decrement

    addr = build_address_of_expression(st, inner)
    assert addr->type->kind == TypeKind::Pointer
    t = addr->type->data.valuetype

    if not is_integer_type(t) and not is_pointer_type(t):
        msg: byte[500]
        if diff == 1:
            snprintf(msg, sizeof(msg),  "cannot increment a value of type %s", t->name)
        else:
            snprintf(msg, sizeof(msg),  "cannot decrement a value of type %s", t->name)
        fail(location, msg)

    old_value = add_local_var(st, t)
    new_value = add_local_var(st, t)
    if is_integer_type(t):
        diffvar = add_local_var(st, t)
    else:
        diffvar = add_local_var(st, intType)

    add_constant(st, location, int_constant(diffvar->type, diff), diffvar)
    add_unary_op(st, location, CfInstructionKind::PtrLoad, addr, old_value)
    if is_number_type(t):
        add_binary_op(st, location, CfInstructionKind::NumAdd, old_value, diffvar, new_value)
    else:
        add_binary_op(st, location, CfInstructionKind::PtrAddInt, old_value, diffvar, new_value)
    add_binary_op(st, location, CfInstructionKind::PtrStore, addr, new_value, NULL)

    if pop == PreOrPost::Pre:
        return new_value
    elif pop == PreOrPost::Post:
        return old_value
    else:
        assert False


enum AndOr:
    And
    Or


def build_and_or(
    st: State*,
    lhsexpr: AstExpression*,
    rhsexpr: AstExpression*,
    andor: AndOr,
) -> LocalVariable*:
    # Must be careful with side effects.
    #
    # and:
    #    # lhs returning False means we don't evaluate rhs
    #    if lhs:
    #        result = rhs
    #    else:
    #        result = False
    #
    # or:
    #    # lhs returning True means we don't evaluate rhs
    #    if lhs:
    #        result = True
    #    else:
    #        result = rhs
    lhs = build_expression(st, lhsexpr);
    result = add_local_var(st, boolType)

    lhstrue = add_block(st)
    lhsfalse = add_block(st)
    done = add_block(st)

    # if lhs:
    add_jump(st, lhs, lhstrue, lhsfalse, lhstrue)

    if andor == AndOr::And:
        # result = rhs
        rhs = build_expression(st, rhsexpr)
        add_unary_op(st, rhsexpr->location, CfInstructionKind::VarCpy, rhs, result)
    elif andor == AndOr::Or:
        # result = True
        ins = add_constant(st, lhsexpr->location, Constant{kind = ConstantKind::Bool, boolean = True}, result)
        ins->hide_unreachable_warning = True
    else:
        assert False

    # else:
    add_jump(st, NULL, done, done, lhsfalse);

    if andor == AndOr::And:
        # result = False
        ins = add_constant(st, lhsexpr->location, Constant{kind = ConstantKind::Bool, boolean = False, result)
        ins->hide_unreachable_warning = True
    elif andor == AndOr::Or:
        # result = rhs
        rhs = build_expression(st, rhsexpr)
        add_unary_op(st, rhsexpr->location, CfInstructionKind::VarCpy, rhs, result)
    else:
        assert False

    add_jump(st, NULL, done, done, done)
    return result


def build_address_of_expression(st: State*, address_of_what: AstExpression*) -> LocalVariable*:
{
    if address_of_what->kind == AstExpressionKind::GetVariable:
        ptrtype = get_pointer_type(get_expr_types(st, address_of_what)->type)
        addr = add_local_var(st, ptrtype)

        local_var = find_local_var_cf(st, address_of_what->data.varname)
        if local_var == NULL:
            # Global variable (possibly imported from another file)
            ins = CfInstruction {
                location = address_of_what->location,
                kind = CfInstructionKind::AddressOfGlobalVar,
                destvar = addr,
            }
            assert sizeof(ins.globalname) == sizeof(address_of_what->short_string)
            strcpy(ins.globalname, address_of_what->short_string)
            add_instruction(st, ins)
        else:
            add_unary_op(st, address_of_what->location, CfInstructionKind::AddressOfLocalVar, local_var, addr)
        return addr

    if address_of_what->kind == AstExpressionKind::Dereference:
        # &*foo --> just evaluate foo
        return build_expression(st, &address_of_what->data.operands[0])

    if address_of_what->kind == AstExpressionKind::DerefAndGetField:
        # &obj->field aka &(obj->field)
        obj = build_expression(st, address_of_what->data.classfield.obj)
        assert obj->type->kind == TypeKind::Pointer
        assert obj->type->data.valuetype->kind == TypeKind::Class
        return build_class_field_pointer(st, obj, address_of_what->data.classfield.fieldname, address_of_what->location)

    if address_of_what->kind == AstExpressionKind::GetField:
        # &obj.field aka &(obj.field), evaluate as &(&obj)->field
        obj = build_address_of_expression(st, address_of_what->data.classfield.obj);
        assert obj->type->kind == TypeKind::Pointer
        return build_class_field_pointer(st, obj, address_of_what->data.classfield.fieldname, address_of_what->location)

    if address_of_what->kind == AstExpressionKind::Indexing:
        ptr = build_expression(st, &address_of_what->data.operands[0]);
        assert ptr->type->kind == TypeKind::Pointer

        index = build_expression(st, &address_of_what->data.operands[1])
        assert is_integer_type(index->type)

        result = add_local_var(st, ptr->type)
        add_binary_op(st, address_of_what->location, CfInstructionKind::PtrAddInt, ptr, index, result)
        return result

    assert False


def build_function_or_method_call(
    st: State*,
    location: Location,
    call: AstCall*,
) -> LocalVariable*:
    sig: Signature* = NULL

    if self_expr != NULL:
        selfclass = get_expr_types(st, self_expr)->type
        if self_is_a_pointer:
            assert selfclass->kind == TypeKind::Pointer
            selfclass = selfclass->value_type;
        assert selfclass->kind == TypeKind::Class

        for s = selfclass->classdata.methods; s < &selfclass->classdata.methods[selfclass->classdata.nmethods]; s++:
            assert get_self_class(s) == selfclass
            if strcmp(s->name, call->calledname) == 0:
                sig = s
                break
    else:
        for f = st->filetypes->functions.ptr; f < &st->filetypes->functions[st->filetypes->nfunctions]; f++:
            if strcmp(f->signature.name, call->calledname) == 0:
                sig = &f->signature
                break

    assert sig != NULL

    args: LocalVariable** = calloc(call->nargs + 2, sizeof(args[0]))
    k = 0

    if self_expr != NULL:
        if is_pointer_type(sig->argtypes[0]) and not self_is_a_pointer:
            args[k++] = build_address_of_expression(st, self_expr)
        elif (not is_pointer_type(sig->argtypes[0])) and self_is_a_pointer:
            self_ptr = build_expression(st, self_expr)
            assert self_ptr->type->kind == TypeKind::Pointer

            # dereference the pointer
            val = add_local_var(st, self_ptr->type->valuetype)
            add_unary_op(st, self_expr->location, CfInstructionKind::PtrLoad, self_ptr, val)
            args[k++] = val
        else:
            args[k++] = build_expression(st, self_expr)

    for i = 0; i < call->nargs; i++:
        args[k++] = build_expression(st, &call->args[i])

    if sig->returntype != NULL
        return_value = add_local_var(st, sig->returntype);
    else
        return_value = NULL

    CfInstruction ins = CfInstruction{
        location = location,
        kind = CfInstructionKind::Call,
        signature = copy_signature(sig),
        operands = args,
        destvar = return_value,
    }
    add_instruction(st, ins)

    if sig->is_noreturn:
        # Place the remaining code into an unreachable block, so you will get a warning if there is any
        add_jump(st, NULL, NULL, NULL, NULL)

    free(args)
    return return_value


def build_struct_init(st: State*, type: Type*, inst: AstInstantiation*, location: Location) -> LocalVariable*:
    instance = add_local_var(st, type)
    instanceptr = add_local_var(st, get_pointer_type(type))

    add_unary_op(st, location, CfInstructionKind::AddressOfLocalVar, instance, instanceptr)
    add_unary_op(st, location, CfInstructionKind::PtrMemsetToZero, instanceptr, NULL)

    for i = 0; i < call->nfields; i++:
        fieldptr = build_class_field_pointer(st, instanceptr, call->field_names[i], call->field_values[i].location)
        fieldval = build_expression(st, &call->field_values[i])
        add_binary_op(st, location, CfInstructionKind::PtrStore, fieldptr, fieldval, NULL)

    return instance


def build_array(st: State*, type: Type*, items: AstExpression*, location: Location) -> LocalVariable*:
    assert type->kind == TypeKind::Array

    arr = add_local_var(st, type)
    arrptr = add_local_var(st, get_pointer_type(type))
    add_unary_op(st, location, CfInstructionKind::AddressOfLocalVar, arr, arrptr)
    first_item_ptr = add_local_var(st, get_pointer_type(type->data.array.membertype))
    add_unary_op(st, location, CfInstructionKind::PtrCast, arrptr, first_item_ptr)

    for i = 0; i < type->data.array.len; i++:
        value = build_expression(st, &items[i])

        ivar = add_local_var(st, intType)
        add_constant(st, location, int_constant(intType, i), ivar)

        destptr = add_local_var(st, first_item_ptr->type)
        add_binary_op(st, location, CfInstructionKind::PtrAddInt, first_item_ptr, ivar, destptr)
        add_binary_op(st, location, CfInstructionKind::PtrStore, destptr, value, NULL)

    return arr


def find_enum_member(enumtype: Type*, name: byte*) -> int:
    for i = 0; i < enumtype->enummembers.count; i++:
        if strcmp(enumtype->enummembers.names[i], name) == 0:
            return i
    assert False


def build_expression(st: State*, expr: AstExpression*) -> LocalVariable*:
    types = get_expr_types(st, expr)

    if types != NULL and types->implicit_array_to_pointer_cast:
        arrptr = build_address_of_expression(st, expr)
        memberptr = add_local_var(st, types->implicit_cast_type)
        add_unary_op(st, expr->location, CfInstructionKind::PtrCast, arrptr, memberptr)
        return memberptr

    if types != NULL and types->implicit_string_to_array_cast:
        assert types->implicit_cast_type != NULL
        assert types->implicit_cast_type->kind == TypeKind::Array
        assert expr->kind == AstExpressionKind::String

        array_size = types->implicit_cast_type->array.len
        assert strlen(expr->str) < array_size
        padded: byte* = calloc(1, array_size)
        assert padded != NULL
        strcpy(padded, expr->data.str)

        result = add_local_var(st, types->implicit_cast_type)
        ins = CfInstruction{
            location = expr->location,
            kind = CfInstructionKind::StringArray,
            strarray = CfStringArray{
                str = padded,
                len = array_size,
            }
            destvar = result,
        }
        add_instruction(st, ins)
        return result

    if expr->kind == AstExpressionKind::Call:
        result = build_function_or_method_call(st, expr->location, &expr->call)
        if result == NULL:
            # called function/method has no return value
            return NULL
    elif expr->kind == AstExpressionKind::Instantiate:
        result = build_struct_init(st, types->type, &expr->instantiation, expr->location)
    elif expr->kind == AstExpressionKind::Array:
        assert types->type->kind == TypeKind::Array
        assert types->type->data.array.len == expr->data.array.count
        result = build_array(st, types->type, expr->data.array.items, expr->location)
    elif expr->kind == AstExpressionKind::GetField:
        temp = build_expression(st, expr->data.classfield.obj)
        result = build_class_field(st, temp, expr->data.classfield.fieldname, expr->location)
    elif expr->kind == AstExpressionKind::GetEnumMember:
        result = add_local_var(st, types->type)
        c = Constant{
            kind = ConstantKind::EnumMember,
            enum_member = EnumMemberConstant{
                .enumtype = types->type,
                .memberidx = find_enum_member(types->type, expr->data.enummember.membername),
            }
        }
        add_constant(st, expr->location, c, result)
    elif expr->kind == AstExpressionKind::GetVariable:
        if get_special_constant(expr->data.varname) != -1:
            result = add_local_var(st, boolType);
            union CfInstructionData data;
            safe_strcpy(data.scname, expr->data.varname);
            add_instruction(st, expr->location, CF_SPECIAL_CONSTANT, &data, NULL, result)
        else:
            temp = find_local_var_cf(st, expr->data.varname)
            if temp != NULL:
                if types->implicit_cast_type == NULL or types->type == types->implicit_cast_type:
                    # Must take a "snapshot" of this variable, as it may change soon.
                    result = add_local_var(st, temp->type)
                    add_unary_op(st, expr->location, CfInstructionKind::VarCpy, temp, result)
                else:
                    result = temp
            else:
                # For other than local variables we can evaluate as &*variable.
                # Would also work for locals, but it would confuse simplify_cfg.
                temp = build_address_of_expression(st, expr);
                result = add_local_var(st, types->type);
                add_unary_op(st, expr->location, CfInstructionKind::PtrLoad, temp, result)
    elif (
        expr->kind == AstExpressionKind::DerefAndGetField
        or expr->kind == AstExpressionKind::Indexing
    ):
        # To evaluate foo->bar, we first evaluate &foo->bar and then dereference.
        # We can similarly evaluate &foo[bar].
        #
        # This technique cannot be used with all expressions. For example, &(1+2)
        # doesn't work, and &foo.bar doesn't work either whenever &foo doesn't work.
        # But &foo->bar and &foo[bar] always work, because foo is already a pointer
        # and we only add a memory offset to it.
        temp = build_address_of_expression(st, expr)
        result = add_local_var(st, types->type)
        add_unary_op(st, expr->location, CfInstructionKind::PtrLoad, temp, result)
    elif expr->kind == AstExpressionKind::AddressOf:
        result = build_address_of_expression(st, &expr->data.operands[0])
    elif expr->kind == AstExpressionKind::SizeOf:
        result = add_local_var(st, longType);
        ins = CfInstruction{
            location = expr->location,
            kind = CfInstructionKind::SizeOf,
            type = get_expr_types(st, &expr->data.operands[0])->type,
            destvar = result,
        }
        add_instruction(st, ins)
    elif expr->kind == AstExpressionKind::Dereference:
        temp = build_expression(st, &expr->data.operands[0])
        result = add_local_var(st, types->type)
        add_unary_op(st, expr->location, CfInstructionKind::PtrLoad, temp, result)
    elif expr->kind == AstExpressionKind::Constant:
        # TODO: doesn't exist, needs more work
        result = add_local_var(st, types->type)
        add_constant(st, expr->location, expr->data.constant, result)
    elif expr->kind == AstExpressionKind::And:
        result = build_and_or(st, &expr->data.operands[0], &expr->data.operands[1], AND)
    elif expr->kind == AstExpressionKind::Or:
        result = build_and_or(st, &expr->data.operands[0], &expr->data.operands[1], OR)
    elif expr->kind == AstExpressionKind::Not:
        temp = build_expression(st, &expr->data.operands[0])
        result = add_local_var(st, boolType)
        add_unary_op(st, expr->location, CF_BOOL_NEGATE, temp, result)
    elif expr->kind == AstExpressionKind::Neg:
        temp = build_expression(st, &expr->data.operands[0])
        const LocalVariable *zero = add_local_var(st, temp->type)
        result = add_local_var(st, temp->type)
        if temp->type == doubleType:
            c = Constant{kind = ConstantKind::Double, double_or_float_text = "0"}
        elif temp->type == floatType:
            c = Constant{kind = ConstantKind::Float, double_or_float_text = "0"}
        else:
            c = int_constant(temp->type, 0)
        add_constant(st, expr->location, c, zero)
        add_binary_op(st, expr->location, CF_NUM_SUB, zero, temp, result)
    elif (
        expr->kind == AstExpressionKind::Add
        or expr->kind == AstExpressionKind::Sub
        or expr->kind == AstExpressionKind::Mul
        or expr->kind == AstExpressionKind::Div
        or expr->kind == AstExpressionKind::Mod
        or expr->kind == AstExpressionKind::Eq
        or expr->kind == AstExpressionKind::Ne
        or expr->kind == AstExpressionKind::Gt
        or expr->kind == AstExpressionKind::Ge
        or expr->kind == AstExpressionKind::Lt
        or expr->kind == AstExpressionKind::Le
    ):
        # Refactoring note: If you rewrite this in another language, like C, make sure to
        # evaluate lhs first. C doesn't guarantee evaluation order of function arguments.
        lhs = build_expression(st, &expr->data.operands[0])
        rhs = build_expression(st, &expr->data.operands[1])
        result = build_binop(st, expr->kind, expr->location, lhs, rhs, types->type)
    elif (
        expr->kind == AstExpressionKind::PreIncrement
        or expr->kind == AstExpressionKind::PreDecrement
        or expr->kind == AstExpressionKind::PostIncrement
        or expr->kind == AstExpressionKind::PostDecrement
    ):
        if expr->kind == AstExpressionKind::PreIncrement:
            pop = PreOrPost::Pre
            diff = 1
        elif expr->kind == AstExpressionKind::PreDecrement:
            pop = PreOrPost::Pre
            diff = -1
        elif expr->kind == AstExpressionKind::PostIncrement:
            pop = PreOrPost::Post
            diff = 1
        elif expr->kind == AstExpressionKind::PostDecrement:
            pop = PreOrPost::Post
            diff = -1
        else:
            assert False
        result = build_increment_or_decrement(st, expr->location, &expr->data.operands[0], pop, diff)
    elif expr->kind == AstExpressionKind::As:
        temp = build_expression(st, expr->as_.obj);
        result = build_cast(st, temp, types->type, expr->location);
    else:
        assert False

    assert types != NULL
    assert result->type == types->type
    if types->implicit_cast_type == NULL:
        return result
    return build_cast(st, result, types->implicit_cast_type, expr->location)


def build_if_statement(st: State*, ifstmt: AstIfStatement*) -> None:
    assert ifstmt->n_if_and_elifs >= 1

    done = add_block(st)
    for i = 0; i < ifstmt->n_if_and_elifs; i++:
        cond: LocalVariable* = build_expression(st, &ifstmt->if_and_elifs[i].condition)
        then = add_block(st)
        otherwise = add_block(st)

        add_jump(st, cond, then, otherwise, then)
        build_body(st, &ifstmt->if_and_elifs[i].body)
        add_jump(st, NULL, done, done, otherwise)

    build_body(st, &ifstmt->elsebody)
    add_jump(st, NULL, done, done, done)


def build_assert(st: State*, assert_location: Location, assertion: AstAssert*) -> None:
    condvar = build_expression(st, &assertion->condition)

    # If the condition is true, we jump to a block where the rest of the code goes.
    # If the condition is false, we jump to a block that calls _jou_assert_fail().
    CfBlock *trueblock = add_block(st)
    CfBlock *falseblock = add_block(st)
    add_jump(st, condvar, trueblock, falseblock, falseblock);

    argnames: byte[100]* = malloc(3 * sizeof(argnames[0]))
    strcpy(argnames[0], "assertion")
    strcpy(argnames[1], "path")
    strcpy(argnames[2], "lineno")

    argtypes: Type** = malloc(3 * sizeof(argtypes[0]))
    argtypes[0] = get_pointer_type(byteType)
    argtypes[1] = get_pointer_type(byteType)
    argtypes[2] = intType

    args = [
        add_local_var(st, argtypes[0]),
        add_local_var(st, argtypes[1]),
        add_local_var(st, argtypes[2]),
        NULL,
    ]

    add_constant(st, assert_location, Constant{kind = ConstantKind::String, str = assertion->condition_str}, args[0])
    tmp = strdup(assertion->condition.location.filename)
    add_constant(st, assert_location, Constant{kind = ConstantKind::String, str = tmp}, args[1])
    free(tmp)
    add_constant(st, assert_location, int_constant(intType, assert_location.lineno), args[2])

    ins = CfInstruction{
        location = assert_location,
        kind = CfInstructionKind::Call,
        signature = Signature{
            name = "_jou_assert_fail",
            nargs = 3,
            argtypes = argtypes,
            argnames = argnames,
            takes_varargs = False,
            is_noreturn = True,
            returntype_location = assert_location,
        },
    }
    ins.set_operands(args)
    add_instruction(st, ins)

    st->current_block = trueblock


# for init; cond; incr:
#     ...body...
#
# While loop is basically a special case of for loop, so it uses this too.
def build_loop(
    st: State*,
    init: AstStatement*,
    cond: AstExpression*,
    incr: AstStatement*,
    body: AstBody*,
) -> None:
    condblock = add_block(st)  # evaluate condition and go to bodyblock or doneblock
    bodyblock = add_block(st)  # run loop body and go to incrblock
    incrblock = add_block(st)  # run incr and go to condblock
    doneblock = add_block(st)  # rest of the code goes here

    # TODO: can init be NULL?
    if init != NULL:
        build_statement(st, init);

    # Evaluate condition. Jump to loop body or skip to after loop.
    add_jump(st, NULL, condblock, condblock, condblock)
    condvar = build_expression(st, cond)
    add_jump(st, condvar, bodyblock, doneblock, bodyblock)

    # 'break' skips to after loop, 'continue' goes to incr.
    st->breakstack = realloc(st->breakstack, sizeof(st->breakstack[0]) * (st->nloops + 1))
    st->continuestack = realloc(st->continuestack, sizeof(st->continuestack[0]) * (st->nloops + 1))
    assert st->breakstack != NULL
    assert st->continuestack != NULL
    st->breakstack[st->nloops] = doneblock
    st->continuestack[st->nloops] = incrblock
    st->nloops++

    # Run loop body
    build_body(st, body);

    st->nloops--
    assert st->breakstack[st->nloops] == doneblock
    assert st->continuestack[st->nloops] == incrblock

    # Run incr and jump back to condition.
    add_jump(st, NULL, incrblock, incrblock, incrblock)
    if incr != NULL:  # TODO: can it ever be NULL?
        build_statement(st, incr)
    add_jump(st, NULL, condblock, condblock, doneblock)


def build_statement(st: State*, stmt: AstStatement*) -> None:
    if stmt->kind == AstStatementKind::If:
        build_if_statement(st, &stmt->data.ifstatement)
    elif stmt->kind == AstStatementKind::Assert:
        build_assert(st, stmt->location, &stmt->data.assertion)
    elif stmt->kind == AstStatementKind::Pass:
        pass
    elif stmt->kind == AstStatementKind::While:
        build_loop(
            st, NULL, &stmt->data.whileloop.condition, NULL,
            &stmt->data.whileloop.body)
    elif stmt->kind == AstStatementKind::For:
        build_loop(
            st, stmt->data.forloop.init, &stmt->data.forloop.cond, stmt->data.forloop.incr,
            &stmt->data.forloop.body)
    elif stmt->kind == AstStatementKind::Break:
        if st->nloops == 0:
            fail(stmt->location, "'break' can only be used inside a loop")
        add_jump(st, NULL, st->breakstack[st->nloops - 1], st->breakstack[st->nloops - 1], NULL)
    elif stmt->kind == AstStatementKind::Continue:
        if st->nloops == 0:
            fail(stmt->location, "'continue' can only be used inside a loop")
        add_jump(st, NULL, st->continuestack[st->nloops - 1], st->continuestack[st->nloops - 1], NULL)
    elif stmt->kind == AstStatementKind::Assign:
        targetexpr = &stmt->assignment.target
        valueexpr = &stmt->assignment.value

        if targetexpr->kind == AstExpressionKind::GetVariable:
            targetvar = find_local_var_cf(st, targetexpr->short_string)
        else:
            targetvar = NULL

        if target != NULL:
            # avoid pointers to help simplify_cfg
            value = build_expression(st, valueexpr)
            add_unary_op(st, stmt->location, CfInstructionKind::VarCpy, value, target);
        else:
            # TODO: is this evaluation order good?
            target = build_address_of_expression(st, targetexpr)
            value = build_expression(st, valueexpr)
            assert target->type->kind == TypeKind::Pointer
            add_binary_op(st, stmt->location, CfInstructionKind::PtrStore, target, value, NULL)

    elif (
        stmt->kind == AstStatementKind::InPlaceAdd
        or stmt->kind == AstStatementKind::InPlaceSub
        or stmt->kind == AstStatementKind::InPlaceMul
        or stmt->kind == AstStatementKind::InPlaceDiv
        or stmt->kind == AstStatementKind::InPlaceMod
    ):
        targetexpr = &stmt->assignment.target
        rhsexpr = &stmt->assignment.value

        targetptr = build_address_of_expression(st, targetexpr);
        rhs = build_expression(st, rhsexpr);
        assert targetptr->type->kind == TypeKind::Pointer
        oldvalue = add_local_var(st, targetptr->type->data.valuetype)
        add_unary_op(st, stmt->location, CfInstructionKind::PtrLoad, targetptr, oldvalue)

        op: AstExpressionKind;
        if stmt->kind == AstStatementKind::InPlaceAdd:
            op = AstExpressionKind::Add
        elif stmt->kind == AstStatementKind::InPlaceSub:
            op = AstExpressionKind::Sub
        elif stmt->kind == AstStatementKind::InPlaceMul:
            op = AstExpressionKind::Mul
        elif stmt->kind == AstStatementKind::InPlaceDiv:
            op = AstExpressionKind::Div
        elif stmt->kind == AstStatementKind::InPlaceMod:
            op = AstExpressionKind::Mod
        else:
            assert False

        newvalue = build_binop(st, op, stmt->location, oldvalue, rhs, targetptr->type->data.valuetype)
        add_binary_op(st, stmt->location, CfInstructionKind::PtrStore, targetptr, newvalue, NULL)

    elif stmt->kind == AstStatementKind::Return:
        if stmt->data.returnvalue != NULL:
            retvalue = build_expression(st, stmt->data.returnvalue)
            retvariable = find_local_var_cf(st, "return")
            assert retvariable != NULL
            add_unary_op(st, stmt->location, CfInstructionKind::VarCpy, retvalue, retvariable)

        st->current_block->iftrue = &st->cfg->end_block
        st->current_block->iffalse = &st->cfg->end_block
        st->current_block = add_block(st)  # an unreachable block

    elif stmt->kind == AstStatementKind::DeclareLocalVar:
        if stmt->vardecl.value != NULL:
            v = find_local_var_cf(st, stmt->data.vardecl.name);
            assert v != NULL
            cfvar = build_expression(st, stmt->data.vardecl.value)
            add_unary_op(st, stmt->location, CfInstructionKind::VarCpy, cfvar, v)

    elif stmt->kind == AstStatementKind::ExpressionStatement:
        build_expression(st, &stmt->data.expression);

    else:
        # other statements shouldn't occur inside functions/methods
        assert False


def build_body(st: State*, body: AstBody*) -> None:
    for i = 0; i < body->nstatements; i++:
        build_statement(st, &body->statements[i])


def build_function_or_method(
    st: State*,
    selfclass: Type*,
    name: byte*,
    body: AstBody*,
) -> CfGraph*:
    assert st->cfg == NULL

    assert st->fomtypes == NULL
    for f = st->filetypes->fomtypes; f < &st->filetypes->fomtypes[st->filetypes->nfomtypes]; f++:
        if strcmp(f->signature.name, name) == 0 and get_self_class(&f->signature) == selfclass:
            st->fomtypes = f
            break
    assert st->fomtypes != NULL

    st->cfg = calloc(1, sizeof *st->cfg)
    st->cfg->signature = copy_signature(&st->fomtypes->signature)

    # Copy local variables over from type checking.
    # Ownership of the variables changes, they will be freed when graphs are freed.
    st->cfg->nlocals = st->fomtypes->nlocals
    st->cfg->locals = malloc(st->cfg->nlocals * sizeof(st->cfg->locals[0]))
    assert st->cfg->locals != NULL
    memcpy(st->cfg->locals, st->fomtypes->locals, st->cfg->nlocals * sizeof(st->cfg->locals[0]))

    st->cfg->all_blocks = malloc(2 * sizeof(st->cfg->all_blocks[0]))
    assert st->cfg->all_blocks != NULL
    st->cfg->all_blocks[0] = &st->cfg->start_block
    st->cfg->all_blocks[1] = &st->cfg->start_block
    st->cfg->n_all_blocks = 2

    st->current_block = &st->cfg->start_block;

    assert st->nloops == 0
    build_body(st, body)
    assert st->nloops == 0

    # Implicit return at the end of the function
    st->current_block->iftrue = &st->cfg->end_block
    st->current_block->iffalse = &st->cfg->end_block

    cfg = st->cfg
    st->fomtypes = NULL
    st->cfg = NULL
    return cfg


# TODO: passing a type context here doesn't really make sense.
# It would be better to pass only the public symbols that have been imported.
def build_control_flow_graphs(ast: AstFile*, filetypes: FileTypes*) -> CfGraphFile:
    result = CfGraphFile{filename = ast->path}
    st = State{filetypes = filetypes}

    for i = 0; i < ast->body.nstatements; i++:
        stmt = &ast->body.statements[i]

        if stmt->kind == AstStatementKind::Function and stmt->data.function.body.nstatements > 0:
            g = build_function_or_method(&st, NULL, stmt->data.function.signature.name, &stmt->data.function.body)

            result.graphs = realloc(result.graphs, sizeof(result.graphs[0]) * (result.ngraphs + 1))
            assert result.graphs != NULL
            result.graphs[result.ngraphs++] = g

        if stmt->kind == AstStatementKind::DefineClass:
            class_type: Type* = NULL;
            for t = filetypes->owned_types; t < &filetypes->owned_types[filetypes->n_owned_types]; t++:
                if strcmp((*t)->name, stmt->classdef.name) == 0:
                    class_type = *t
                    break
            assert class_type != NULL

            for m = stmt->classdef.members; m < &stmt->classdef.members[stmt->classdef.nmembers]; m++:
                if m->kind == AstClassMemberKind::Method:
                    g = build_function_or_method(&st, class_type, m->data.method.signature.name, &m->data.method.body);

                    result.graphs = realloc(result.graphs, sizeof(result.graphs[0]) * (result.ngraphs + 1))
                    assert result.graphs != NULL
                    result.graphs[result.ngraphs++] = g

    free(st.breakstack)
    free(st.continuestack)
    return result
