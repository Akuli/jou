#include "jou_compiler.h"

class State:
    filetypes: FileTypes*
    fomtypes: FunctionOrMethodTypes*
    cfg: CfGraph*
    current_block: CfBlock*
    breakstack: CfBlock**
    breakstack_len: int
    continuestack: CfBlock**
    continuestack_len: int


def find_local_var_cf(st: State*, name: byte*) -> LocalVariable*:
    for var = st->cfg->locals; var < &st->cfg->locals[st->cfg->nlocals]; var++:
        if strcmp((*var)->name, name) == 0:
            return *var
    return NULL

def add_local_var(st: State*, t: Type*) -> LocalVariable*:
    var: LocalVariable* = calloc(1, sizeof *var)
    var->id = st->cfg->nlocals
    var->type = t

    st->cfg->locals = realloc(st->cfg->locals, sizeof(st->cfg->locals[0]) * (st->cfg->nlocals + 1))
    assert st->cfg->locals != NULL
    st->cfg->locals[st->cfg->nlocals++] = var

    return var


def get_expr_types(st: State*, expr: AstExpression*) -> ExpressionTypes*:
    # TODO: a fancy binary search algorithm (need to add sorting)
    assert st->fomtypes != NULL
    for i = 0; i < st->fomtypes->n_expr_types; i++:
        if st->fomtypes->expr_types[i]->expr == expr:
            return st->fomtypes->expr_types[i]
    return NULL


def add_block(st: State*) -> CfBlock*:
    block: CfBlock* = calloc(1, sizeof *block)

    st->cfg->all_blocks = realloc(st->cfg->all_blocks, sizeof(st->cfg->all_blocks[0]) * (st->cfg->n_all_blocks + 1))
    assert st->cfg->all_blocks != NULL
    st->cfg->all_blocks[st->cfg->n_all_blocks++] = block

    return block


def add_jump(
    st: State*,
    branchvar: LocalVariable*,
    iftrue: CfBlock*,
    iffalse: CfBlock*,
    new_current_block: CfBlock*,
) -> None:
    assert (iftrue != NULL and iffalse != NULL) or (iftrue == NULL and iffalse == NULL and branchvar == NULL)
    if iftrue != iffalse:
        assert branchvar != NULL
        assert branchvar->type == boolType

    st->current_block->branchvar = branchvar;
    st->current_block->iftrue = iftrue;
    st->current_block->iffalse = iffalse;
    if new_current_block == NULL:
        st->current_block = add_block(st)
    else:
        st->current_block = new_current_block


# returned pointer is only valid until next call to add_instruction()
def add_instruction(
    st: State*,
#    location: Location,
#    k: CfInstructionKind,
    #const union CfInstructionData *dat,  # TODO: won't work
#    operands: LocalVariable**,  # NULL terminated, or NULL for empty
#    destvar: LocalVariable*,
    ins: CfInstruction,
) -> CfInstruction*:
    #ins = CfInstruction{location=location, kind=k, destvar=destvar}
    #if (dat)
    #    ins.data=*dat;
#
#    while operands != NULL and operands[ins.noperands] != NULL:
#        ins.noperands++
#    if ins.noperands > 0:
#        nbytes = sizeof(ins.operands[0]) * ins.noperands
#        ins.operands = malloc(nbytes)
#        memcpy(ins.operands, operands, nbytes)

    st->current_block->instructions = realloc(st->current_block->instructions, sizeof(st->current_block->instructions[0]) * (st->current_block->ninstructions + 1))
    assert st->current_block->instructions != NULL
    st->current_block->instructions[st->current_block->ninstructions++] = ins

    return &st->current_block->instructions[st->current_block->ninstructions - 1]


# TODO: do we need this?
def add_unary_op(
    st: State*,
    location: Location,
    op: CfInstructionKind,
    arg: LocalVariable*,
    target: LocalVariable*,
) -> None:
    ins = CfInstruction{location = location, kind = op, destvar = target}
    operands = [arg, NULL as LocalVariable*]
    ins.set_operands(operands)
    add_instruction(st, ins)


# TODO: do we need this?
def add_binary_op(
    st: State*,
    location: Location,
    op: CfInstructionKind,
    lhs: LocalVariable*,
    rhs: LocalVariable*,
    target: LocalVariable*,
) -> None:
    ins = CfInstruction{location = location, kind = op, destvar = target}
    operands = [lhs, rhs, NULL as LocalVariable*]
    ins.set_operands(operands)
    add_instruction(st, ins)


# TODO: do we need this?
def add_constant(st: State*, loc: Location, c: Constant, target: LocalVariable*) -> None:
    ins = CfInstruction{location = location, kind = op, constant = copy_constant(c), destvar = target}
    add_instruction(st, ins)


def build_bool_to_int_conversion(
    st: State*,
    boolvar: LocalVariable*,
    location: Location,
    t: Type*,
) -> LocalVariable*:
    assert is_integer_type(t)
    result: LocalVariable* = add_local_var(st, t)

    set1 = add_block(st)
    set0 = add_block(st)
    done = add_block(st)

    add_jump(st, boolvar, set1, set0, set1)
    add_constant(st, location, int_constant(t, 1), result)->hide_unreachable_warning = True
    add_jump(st, NULL, done, done, set0)
    add_constant(st, location, int_constant(t, 0), result)->hide_unreachable_warning = True
    add_jump(st, NULL, done, done, done)

    return result


def build_cast(
    st: State*,
    obj: LocalVariable*,
    to: Type *,
    location: Location,
) -> LocalVariable*:
    if obj->type == to:
        return obj

    if is_pointer_type(obj->type) and is_pointer_type(to):
        result = add_local_var(st, to)
        add_unary_op(st, location, CfInstructionKind::PtrCast, obj, result)
        return result

    if is_number_type(obj->type) and is_number_type(to):
        result = add_local_var(st, to)
        add_unary_op(st, location, CfInstructionKind::NumCast, obj, result)
        return result

    if is_number_type(obj->type) and obj->type->data.width_in_bits == 64 and is_pointer_type(to):
        result = add_local_var(st, to)
        add_unary_op(st, location, CfInstructionKind::Int64ToPtr, obj, result)
        return result

    if is_integer_type(obj->type) or to->kind == TypeKind::Enum:
        i32var = add_local_var(st, intType)
        result = add_local_var(st, to)
        add_unary_op(st, location, CfInstructionKind::NumCast, obj, i32var)
        add_unary_op(st, location, CfInstructionKind::Int32ToEnum, i32var, result)
        return result

    if obj->type->kind == TypeKind::Enum and is_integer_type(to):
        i32var = add_local_var(st, intType)
        result = add_local_var(st, to)
        add_unary_op(st, location, CfInstructionKind::EnumToInt32, obj, i32var)
        add_unary_op(st, location, CfInstructionKind::NumCast, i32var, result)
        return result

    if obj->type == boolType and is_integer_type(to):
        return build_bool_to_int_conversion(st, obj, location, to)

    if is_pointer_type(obj->type) and is_integer_type(to) and to->data.width_in_bits == 64:
        result = add_local_var(st, to)
        add_unary_op(st, location, CfInstructionKind::PtrToInt64, obj, result)
        return result

    assert False


def build_bool_eq(st: State*, location: Location, a: LocalVariable*, b: LocalVariable*) -> LocalVariable*:
    assert a->type == boolType
    assert b->type == boolType

    # Pseudo code:
    #
    #    if a:
    #        result = b
    #    else:
    #        result = not b
    result = add_local_var(st, boolType)

    atrue = add_block(st)
    afalse = add_block(st)
    done = add_block(st)

    # if a:
    add_jump(st, a, atrue, afalse, atrue)

    # result = b
    add_unary_op(st, location, CfInstructionKind::VarCpy, b, result)

    # else:
    add_jump(st, NULL, done, done, afalse)

    # result = not b
    add_unary_op(st, location, CF_BOOL_NEGATE, b, result)

    add_jump(st, NULL, done, done, done)
    return result


static const LocalVariable *build_binop(
    st: State*,
    op: AstExpressionKind,
    location: Location,
    lhs: LocalVariable*,
    rhs: LocalVariable*,
    result_type: Type*,
) -> LocalVariable*:
    got_bools = lhs->type == boolType and rhs->type == boolType
    got_numbers = is_number_type(lhs->type) and is_number_type(rhs->type)
    got_pointers = is_pointer_type(lhs->type) and is_pointer_type(rhs->type)
    assert got_bools or got_numbers or got_pointers

    negate = False
    swap = False

    destvar: LocalVariable*
    if got_bools:
        assert result_type == boolType
        destvar = build_bool_eq(st, location, lhs, rhs)
        assert op == AstExpressionKind::Eq or op == AstExpressionKind::Ne
        negate = (op == AstExpressionKind::Ne)
    else:
        destvar = add_local_var(st, result_type)
        k: CfInstructionKind
        if op == AstExpressionKind::Add:
            k = CfInstructionKind::NumAdd
        elif op == AstExpressionKind::Sub:
            k = CF_NUM_SUB
        elif op == AstExpressionKind::Mul:
            k = CF_NUM_MUL
        elif op == AstExpressionKind::Div:
            k = CF_NUM_DIV
        elif op == AstExpressionKind::Mod:
            k = CF_NUM_MOD
        elif op == AstExpressionKind::Eq:
            k = CF_NUM_EQ
        elif op == AstExpressionKind::Ne:
            k = CF_NUM_EQ
            negate = True
        elif op == AstExpressionKind::Lt:
            k = CF_NUM_LT
        elif op == AstExpressionKind::Gt:
            k = CF_NUM_LT
            swap = True
        elif op == AstExpressionKind::Le:
            k = CF_NUM_LT
            negate = True
            swap = True
        elif op == AstExpressionKind::Ge:
            k = CF_NUM_LT
            negate = True
        else:
            assert False

        if swap:
            add_binary_op(st, location, k, rhs, lhs, destvar)
        else:
            add_binary_op(st, location, k, lhs, rhs, destvar)

    if not negate:
        return destvar;

    negated = add_local_var(st, boolType)
    add_unary_op(st, location, CF_BOOL_NEGATE, destvar, negated)
    return negated


def build_class_field_pointer(
    st: State*, instance: LocalVariable*, fieldname: byte*, location: Location
) -> LocalVariable*:
    assert instance->type->kind == TypeKind::Pointer
    assert instance->type->valuetype->kind == TypeKind::Class
    class_type = instance->type->data.valuetype;

    for f = class_type->classdata.fields; f < &class_type->classdata.fields[class_type->classdata.nfields]; f++:
        if strcmp(f->name, fieldname) == 0:
            ins = CfInstruction{
                location: location,
                kind: CfInstructionKind::PtrClassField,
            }

            assert sizeof(ins.fieldname) == sizeof(f->name)
            strcpy(ins.fieldname, f->name)

            operands = [instance, NULL]
            ins.set_operands(operands)

            result = add_local_var(st, get_pointer_type(f->type))
            add_instruction(st, ins)
            return result

    assert False


def build_class_field(
    st: State*,
    instance: LocalVariable*,
    fieldname: byte*,
    location: Location,
) -> LocalVariable*:
    ptr = add_local_var(st, get_pointer_type(instance->type))
    add_unary_op(st, location, CfInstructionKind::AddressOfLocalVar, instance, ptr)
    field_ptr = build_class_field_pointer(st, ptr, fieldname, location)
    field = add_local_var(st, field_ptr->type->data.valuetype)
    add_unary_op(st, location, CfInstructionKind::PtrLoad, field_ptr, field)
    return field


enum PreOrPost:
    Pre
    Post


def build_increment_or_decrement(
    st: State*,
    location: Location,
    inner: AstExpression*,
    pop: PreOrPost,
    diff: int,
) -> LocalVariable*:
    assert diff == 1 or diff == -1  # 1=increment, -1=decrement

    addr = build_address_of_expression(st, inner)
    assert addr->type->kind == TypeKind::Pointer
    t = addr->type->data.valuetype

    if not is_integer_type(t) and not is_pointer_type(t):
        msg: byte[500]
        if diff == 1:
            snprintf(msg, sizeof(msg),  "cannot increment a value of type %s", t->name)
        else:
            snprintf(msg, sizeof(msg),  "cannot decrement a value of type %s", t->name)
        fail(location, msg)

    old_value = add_local_var(st, t)
    new_value = add_local_var(st, t)
    if is_integer_type(t):
        diffvar = add_local_var(st, t)
    else:
        diffvar = add_local_var(st, intType)

    add_constant(st, location, int_constant(diffvar->type, diff), diffvar)
    add_unary_op(st, location, CfInstructionKind::PtrLoad, addr, old_value)
    if is_number_type(t):
        add_binary_op(st, location, CfInstructionKind::NumAdd, old_value, diffvar, new_value)
    else:
        add_binary_op(st, location, CfInstructionKind::PtrAddInt, old_value, diffvar, new_value)
    add_binary_op(st, location, CF_PTR_STORE, addr, new_value, NULL)

    if pop == PreOrPost::Pre:
        return new_value
    elif pop == PreOrPost::Post:
        return old_value
    else:
        assert False


enum AndOr:
    And
    Or


def build_and_or(
    st: State*,
    lhsexpr: AstExpression*,
    rhsexpr: AstExpression*,
    andor: AndOr,
) -> LocalVariable*:
    # Must be careful with side effects.
    #
    # and:
    #    # lhs returning False means we don't evaluate rhs
    #    if lhs:
    #        result = rhs
    #    else:
    #        result = False
    #
    # or:
    #    # lhs returning True means we don't evaluate rhs
    #    if lhs:
    #        result = True
    #    else:
    #        result = rhs
    lhs = build_expression(st, lhsexpr);
    result = add_local_var(st, boolType)

    lhstrue = add_block(st)
    lhsfalse = add_block(st)
    done = add_block(st)

    # if lhs:
    add_jump(st, lhs, lhstrue, lhsfalse, lhstrue)

    if andor == AndOr::And:
        # result = rhs
        rhs = build_expression(st, rhsexpr)
        add_unary_op(st, rhsexpr->location, CfInstructionKind::VarCpy, rhs, result)
    elif andor == AndOr::Or:
        # result = True
        ins = add_constant(st, lhsexpr->location, Constant{kind = ConstantKind::Bool, boolean = True}, result)
        ins->hide_unreachable_warning = True
    else:
        assert False

    # else:
    add_jump(st, NULL, done, done, lhsfalse);

    if andor == AndOr::And:
        # result = False
        ins = add_constant(st, lhsexpr->location, Constant{kind = ConstantKind::Bool, boolean = False, result)
        ins->hide_unreachable_warning = True
    elif andor == AndOr::Or:
        # result = rhs
        rhs = build_expression(st, rhsexpr)
        add_unary_op(st, rhsexpr->location, CfInstructionKind::VarCpy, rhs, result)
    else:
        assert False

    add_jump(st, NULL, done, done, done)
    return result


def build_address_of_expression(st: State*, address_of_what: AstExpression*) -> LocalVariable*:
{
    if address_of_what->kind == AstExpressionKind::GetVariable:
        ptrtype = get_pointer_type(get_expr_types(st, address_of_what)->type)
        addr = add_local_var(st, ptrtype)

        local_var = find_local_var_cf(st, address_of_what->data.varname)
        if local_var == NULL:
            # Global variable (possibly imported from another file)
            ins = CfInstruction {
                location = address_of_what->location,
                kind = CfInstructionKind::AddressOfGlobalVar,
                destvar = addr,
            }
            assert sizeof(ins.globalname) == sizeof(address_of_what->short_string)
            strcpy(ins.globalname, address_of_what->short_string)
            add_instruction(st, ins)
        else:
            add_unary_op(st, address_of_what->location, CfInstructionKind::AddressOfLocalVar, local_var, addr)
        return addr

    if address_of_what->kind == AstExpressionKind::Dereference:
        # &*foo --> just evaluate foo
        return build_expression(st, &address_of_what->data.operands[0])

    if address_of_what->kind == AstExpressionKind::DerefAndGetField:
        # &obj->field aka &(obj->field)
        obj = build_expression(st, address_of_what->data.classfield.obj)
        assert obj->type->kind == TypeKind::Pointer
        assert obj->type->data.valuetype->kind == TypeKind::Class
        return build_class_field_pointer(st, obj, address_of_what->data.classfield.fieldname, address_of_what->location)

    if address_of_what->kind == AstExpressionKind::GetField:
        # &obj.field aka &(obj.field), evaluate as &(&obj)->field
        obj = build_address_of_expression(st, address_of_what->data.classfield.obj);
        assert obj->type->kind == TypeKind::Pointer
        return build_class_field_pointer(st, obj, address_of_what->data.classfield.fieldname, address_of_what->location)

    if address_of_what->kind == AstExpressionKind::Indexing:
        ptr = build_expression(st, &address_of_what->data.operands[0]);
        assert ptr->type->kind == TypeKind::Pointer

        index = build_expression(st, &address_of_what->data.operands[1])
        assert is_integer_type(index->type)

        result = add_local_var(st, ptr->type)
        add_binary_op(st, address_of_what->location, CfInstructionKind::PtrAddInt, ptr, index, result)
        return result

    assert False


def build_function_or_method_call(
    st: State*,
    location: Location,
    call: AstCall*,
    self_expr: AstExpression*,
    self_is_a_pointer: bool,
) -> LocalVariable*:
    sig: Signature* = NULL

    if self_expr != NULL:
        selfclass = get_expr_types(st, self_expr)->type
        if self_is_a_pointer:
            assert selfclass->kind == TypeKind::Pointer
            selfclass = selfclass->value_type;
        assert selfclass->kind == TypeKind::Class

        for s = selfclass->classdata.methods; s < &selfclass->classdata.methods[selfclass->classdata.nmethods]; s++:
            assert get_self_class(s) == selfclass
            if strcmp(s->name, call->calledname) == 0:
                sig = s
                break
    else:
        for f = st->filetypes->functions.ptr; f < &st->filetypes->functions[st->filetypes->nfunctions]; f++:
            if strcmp(f->signature.name, call->calledname) == 0:
                sig = &f->signature
                break

    assert sig != NULL

    args: LocalVariable** = calloc(call->nargs + 2, sizeof(args[0]))
    k = 0

    if self_expr != NULL:
        if is_pointer_type(sig->argtypes[0]) and not self_is_a_pointer:
            args[k++] = build_address_of_expression(st, self_expr)
        elif (not is_pointer_type(sig->argtypes[0])) and self_is_a_pointer:
            self_ptr = build_expression(st, self_expr)
            assert self_ptr->type->kind == TypeKind::Pointer

            # dereference the pointer
            val = add_local_var(st, self_ptr->type->valuetype)
            add_unary_op(st, self_expr->location, CfInstructionKind::PtrLoad, self_ptr, val)
            args[k++] = val
        else:
            args[k++] = build_expression(st, self_expr)

    for i = 0; i < call->nargs; i++:
        args[k++] = build_expression(st, &call->args[i])

    if sig->returntype != NULL
        return_value = add_local_var(st, sig->returntype);
    else
        return_value = NULL

    CfInstruction ins = CfInstruction{
        location = location,
        kind = CfInstructionKind::Call,
        signature = copy_signature(sig),
        operands = args,
        destvar = return_value,
    }
    add_instruction(st, ins)

    if sig->is_noreturn:
        # Place the remaining code into an unreachable block, so you will get a warning if there is any
        add_jump(st, NULL, NULL, NULL, NULL)

    free(args)
    return return_value


def build_struct_init(st: State*, type: Type*, inst: AstInstantiation*, location: Location) -> LocalVariable*:
    instance = add_local_var(st, type)
    instanceptr = add_local_var(st, get_pointer_type(type))

    add_unary_op(st, location, CfInstructionKind::AddressOfLocalVar, instance, instanceptr)
    add_unary_op(st, location, CfInstructionKind::PtrMemsetToZero, instanceptr, NULL)

    for i = 0; i < call->nfields; i++:
        fieldptr = build_class_field_pointer(st, instanceptr, call->field_names[i], call->field_values[i].location)
        fieldval = build_expression(st, &call->field_values[i])
        add_binary_op(st, location, CF_PTR_STORE, fieldptr, fieldval, NULL)

    return instance


def build_array(st: State*, type: Type*, items: AstExpression*, location: Location) -> LocalVariable*:
    assert type->kind == TypeKind::Array

    arr = add_local_var(st, type)
    arrptr = add_local_var(st, get_pointer_type(type))
    add_unary_op(st, location, CfInstructionKind::AddressOfLocalVar, arr, arrptr)
    first_item_ptr = add_local_var(st, get_pointer_type(type->data.array.membertype))
    add_unary_op(st, location, CfInstructionKind::PtrCast, arrptr, first_item_ptr)

    for i = 0; i < type->data.array.len; i++:
        value = build_expression(st, &items[i])

        ivar = add_local_var(st, intType)
        add_constant(st, location, int_constant(intType, i), ivar)

        destptr = add_local_var(st, first_item_ptr->type)
        add_binary_op(st, location, CfInstructionKind::PtrAddInt, first_item_ptr, ivar, destptr)
        add_binary_op(st, location, CF_PTR_STORE, destptr, value, NULL)

    return arr


def find_enum_member(enumtype: Type*, name: byte*) -> int:
    for i = 0; i < enumtype->enummembers.count; i++:
        if strcmp(enumtype->enummembers.names[i], name) == 0:
            return i
    assert False


def build_expression(st: State*, expr: AstExpression*) -> LocalVariable*:
    types = get_expr_types(st, expr)

    if types != NULL and types->implicit_array_to_pointer_cast:
        arrptr = build_address_of_expression(st, expr)
        memberptr = add_local_var(st, types->implicit_cast_type)
        add_unary_op(st, expr->location, CfInstructionKind::PtrCast, arrptr, memberptr)
        return memberptr

    if types != NULL and types->implicit_string_to_array_cast:
        assert types->implicit_cast_type != NULL
        assert types->implicit_cast_type->kind == TypeKind::Array
        assert expr->kind == AstExpressionKind::String

        array_size = types->implicit_cast_type->array.len
        assert strlen(expr->str) < array_size
        padded: byte* = calloc(1, array_size)
        assert padded != NULL
        strcpy(padded, expr->data.str)

        result = add_local_var(st, types->implicit_cast_type)
        ins = CfInstruction{
            location = expr->location,
            kind = CfInstructionKind::StringArray,
            strarray = CfStringArray{
                str = padded,
                len = array_size,
            }
            destvar = result,
        }
        add_instruction(st, ins)
        return result

    switch(expr->kind) {
    case AstExpressionKind::DerefAndCallMethod:
        result = build_function_or_method_call(st, expr->location, &expr->data.methodcall.call, expr->data.methodcall.obj, true);
        if (!result)
            return NULL;
        break;
    case AstExpressionKind::CallMethod:
        result = build_function_or_method_call(st, expr->location, &expr->data.methodcall.call, expr->data.methodcall.obj, false);
        if (!result)
            return NULL;
        break;
    case AstExpressionKind::FunctionCall:
        result = build_function_or_method_call(st, expr->location, &expr->data.call, NULL, false);
        if (!result)
            return NULL;
        break;
    case AstExpressionKind::BraceInit:
        result = build_struct_init(st, types->type, &expr->data.call, expr->location);
        break;
    case AstExpressionKind::Array:
        assert(types->type->kind == TypeKind::Array);
        assert(types->type->data.array.len == expr->data.array.count);
        result = build_array(st, types->type, expr->data.array.items, expr->location);
        break;
    case AstExpressionKind::GetField:
        temp = build_expression(st, expr->data.classfield.obj);
        result = build_class_field(st, temp, expr->data.classfield.fieldname, expr->location);
        break;
    case AstExpressionKind::GetEnumMember:
        result = add_local_var(st, types->type);
        Constant c = { ConstantKind::EnumMember, {
            .enum_member.enumtype = types->type,
            .enum_member.memberidx = find_enum_member(types->type, expr->data.enummember.membername),
        }};
        add_constant(st, expr->location, c, result)
        break;
    case AstExpressionKind::GetVariable:
        if (get_special_constant(expr->data.varname) != -1) {
            result = add_local_var(st, boolType);
            union CfInstructionData data;
            safe_strcpy(data.scname, expr->data.varname);
            add_instruction(st, expr->location, CF_SPECIAL_CONSTANT, &data, NULL, result)
            break;
        }
        if ((temp = find_local_var_cf(st, expr->data.varname))) {
            if (types->implicit_cast_type == NULL or types->type == types->implicit_cast_type) {
                // Must take a "snapshot" of this variable, as it may change soon.
                result = add_local_var(st, temp->type);
                add_unary_op(st, expr->location, CfInstructionKind::VarCpy, temp, result)
            } else {
                result = temp;
            }
            break;
        }
        // For other than local variables we can evaluate as &*variable.
        // Would also work for locals, but it would confuse simplify_cfg.
        __attribute__((fallthrough));
    case AstExpressionKind::DerefAndGetField:
    case AstExpressionKind::Indexing:
        /*
        To evaluate foo->bar, we first evaluate &foo->bar and then dereference.
        We can similarly evaluate &foo[bar].

        This technique cannot be used with all expressions. For example, &(1+2)
        doesn't work, and &foo.bar doesn't work either whenever &foo doesn't work.
        But &foo->bar and &foo[bar] always work, because foo is already a pointer
        and we only add a memory offset to it.
        */
        temp = build_address_of_expression(st, expr);
        result = add_local_var(st, types->type);
        add_unary_op(st, expr->location, CfInstructionKind::PtrLoad, temp, result)
        break;
    case AstExpressionKind::AddressOf:
        result = build_address_of_expression(st, &expr->data.operands[0]);
        break;
    case AstExpressionKind::SizeOf:
        {
            result = add_local_var(st, longType);
            union CfInstructionData data = { .type = get_expr_types(st, &expr->data.operands[0])->type };
            add_instruction(st, expr->location, CF_SIZEOF, &data, NULL, result)
        }
        break;
    case AstExpressionKind::Dereference:
        temp = build_expression(st, &expr->data.operands[0]);
        result = add_local_var(st, types->type);
        add_unary_op(st, expr->location, CfInstructionKind::PtrLoad, temp, result)
        break;
    case AstExpressionKind::Constant:
        result = add_local_var(st, types->type);
        add_constant(st, expr->location, expr->data.constant, result)
        break;
    case AstExpressionKind::And:
        result = build_and_or(st, &expr->data.operands[0], &expr->data.operands[1], AND);
        break;
    case AstExpressionKind::Or:
        result = build_and_or(st, &expr->data.operands[0], &expr->data.operands[1], OR);
        break;
    case AstExpressionKind::Not:
        temp = build_expression(st, &expr->data.operands[0]);
        result = add_local_var(st, boolType);
        add_unary_op(st, expr->location, CF_BOOL_NEGATE, temp, result)
        break;
    case AstExpressionKind::Neg:
        temp = build_expression(st, &expr->data.operands[0]);
        const LocalVariable *zero = add_local_var(st, temp->type);
        result = add_local_var(st, temp->type);
        if (temp->type == doubleType)
            add_constant(st, expr->location, ((Constant){ ConstantKind::Double, {.double_or_float_text="0"} }), zero);
        else if (temp->type == floatType)
            add_constant(st, expr->location, ((Constant){ ConstantKind::Float, {.double_or_float_text="0"}}), zero);
        else
            add_constant(st, expr->location, int_constant(temp->type, 0), zero);
        add_binary_op(st, expr->location, CF_NUM_SUB, zero, temp, result)
        break;
    case AstExpressionKind::Add:
    case AstExpressionKind::Sub:
    case AstExpressionKind::Mul:
    case AstExpressionKind::Div:
    case AstExpressionKind::Mod:
    case AstExpressionKind::Eq:
    case AstExpressionKind::Ne:
    case AstExpressionKind::Gt:
    case AstExpressionKind::Ge:
    case AstExpressionKind::Lt:
    case AstExpressionKind::Le:
        {
            // Refactoring note: Make sure to evaluate lhs first. C doesn't guarantee evaluation
            // order of function arguments.
            lhs: LocalVariable* = build_expression(st, &expr->data.operands[0]);
            rhs: LocalVariable* = build_expression(st, &expr->data.operands[1]);
            result = build_binop(st, expr->kind, expr->location, lhs, rhs, types->type);
            break;
        }
    case AstExpressionKind::PreIncrement:
    case AstExpressionKind::PreDecrement:
    case AstExpressionKind::PostIncrement:
    case AstExpressionKind::PostDecrement:
        {
            pop: PreOrPost;
            int diff;

            switch(expr->kind) {
                case AstExpressionKind::PreIncrement: pop=PreOrPost::Pre; diff=1
                case AstExpressionKind::PreDecrement: pop=PreOrPost::Pre; diff=-1
                case AstExpressionKind::PostIncrement: pop=PreOrPost::Post; diff=1
                case AstExpressionKind::PostDecrement: pop=PreOrPost::Post; diff=-1
                default: assert(0);
            }
            result = build_increment_or_decrement(st, expr->location, &expr->data.operands[0], pop, diff);
            break;
        }
    case AstExpressionKind::As:
        temp = build_expression(st, expr->data.as.obj);
        result = build_cast(st, temp, types->type, expr->location);
        break;
    }

    assert(types);
    assert(result->type == types->type);
    if (types->implicit_cast_type)
        return build_cast(st, result, types->implicit_cast_type, expr->location);
    else
        return result
}

static void build_if_statement(st: State*, const AstIfStatement *ifstmt)
{
    assert(ifstmt->n_if_and_elifs >= 1);

    CfBlock *done = add_block(st)
    for (int i = 0; i < ifstmt->n_if_and_elifs; i++) {
        const LocalVariable *cond = build_expression(
            st, &ifstmt->if_and_elifs[i].condition);
        CfBlock *then = add_block(st)
        CfBlock *otherwise = add_block(st)

        add_jump(st, cond, then, otherwise, then);
        build_body(st, &ifstmt->if_and_elifs[i].body);
        add_jump(st, NULL, done, done, otherwise);
    }

    build_body(st, &ifstmt->elsebody);
    add_jump(st, NULL, done, done, done)
}

static void build_assert(st: State*, Location assert_location, const AstAssert *assertion)
{
    const LocalVariable *condvar = build_expression(st, &assertion->condition);

    // If the condition is true, we jump to a block where the rest of the code goes.
    // If the condition is false, we jump to a block that calls _jou_assert_fail().
    CfBlock *trueblock = add_block(st)
    CfBlock *falseblock = add_block(st)
    add_jump(st, condvar, trueblock, falseblock, falseblock);

    char (*argnames)[100] = malloc(3 * sizeof *argnames);
    strcpy(argnames[0], "assertion");
    strcpy(argnames[1], "path");
    strcpy(argnames[2], "lineno");

    const Type **argtypes = malloc(3 * sizeof(argtypes[0]));  // NOLINT
    argtypes[0] = get_pointer_type(byteType);
    argtypes[1] = get_pointer_type(byteType);
    argtypes[2] = intType;

    const LocalVariable *args[4];
    for (int i = 0; i < 3; i++)
        args[i] = add_local_var(st, argtypes[i]);
    args[3] = NULL;

    add_constant(st, assert_location, ((Constant){ConstantKind::String,{.str=assertion->condition_str}}), args[0]);
    char *tmp = strdup(assertion->condition.location.filename);
    add_constant(st, assert_location, ((Constant){ConstantKind::String,{.str=tmp}}), args[1]);
    free(tmp);
    add_constant(st, assert_location, int_constant(intType, assert_location.lineno), args[2]);

    union CfInstructionData data = { .signature = {
        .name = "_jou_assert_fail",
        .nargs = 3,
        .argtypes = argtypes,
        .argnames = argnames,
        .takes_varargs = false,
        .is_noreturn = true,
        .returntype_location = assert_location,
    } };
    add_instruction(st, assert_location, CfInstructionKind::Call, &data, args, NULL);

    st->current_block = trueblock;
}

static void build_statement(st: State*, const AstStatement *stmt);

// for init; cond; incr:
//     ...body...
//
// While loop is basically a special case of for loop, so it uses this too.
static void build_loop(
    st: State*,
    const AstStatement *init,
    const AstExpression *cond,
    const AstStatement *incr,
    const AstBody *body)
{
    CfBlock *condblock = add_block(st)  // evaluate condition and go to bodyblock or doneblock
    CfBlock *bodyblock = add_block(st)  // run loop body and go to incrblock
    CfBlock *incrblock = add_block(st)  // run incr and go to condblock
    CfBlock *doneblock = add_block(st)  // rest of the code goes here
    CfBlock *tmp;

    if (init)
        build_statement(st, init);

    // Evaluate condition. Jump to loop body or skip to after loop.
    add_jump(st, NULL, condblock, condblock, condblock);
    const LocalVariable *condvar = build_expression(st, cond);
    add_jump(st, condvar, bodyblock, doneblock, bodyblock);

    // Run loop body: 'break' skips to after loop, 'continue' goes to incr.
    Append(&st->breakstack, doneblock);
    Append(&st->continuestack, incrblock);
    build_body(st, body);
    tmp = Pop(&st->breakstack); assert(tmp == doneblock);
    tmp = Pop(&st->continuestack); assert(tmp == incrblock);

    // Run incr and jump back to condition.
    add_jump(st, NULL, incrblock, incrblock, incrblock);
    if (incr)
        build_statement(st, incr);
    add_jump(st, NULL, condblock, condblock, doneblock);
}

static void build_statement(st: State*, const AstStatement *stmt)
{
    switch(stmt->kind) {
    case AstStatementKind::If:
        build_if_statement(st, &stmt->data.ifstatement);
        break;

    case AstStatementKind::Assert:
        build_assert(st, stmt->location, &stmt->data.assertion);
        break;

    case AstStatementKind::Pass:
        break;

    case AstStatementKind::While:
        build_loop(
            st, NULL, &stmt->data.whileloop.condition, NULL,
            &stmt->data.whileloop.body);
        break;

    case AstStatementKind::For:
        build_loop(
            st, stmt->data.forloop.init, &stmt->data.forloop.cond, stmt->data.forloop.incr,
            &stmt->data.forloop.body);
        break;

    case AstStatementKind::Break:
        if (!st->breakstack.len)
            fail(stmt->location, "'break' can only be used inside a loop");
        add_jump(st, NULL, End(st->breakstack)[-1], End(st->breakstack)[-1], NULL);
        break;

    case AstStatementKind::Continue:
        if (!st->continuestack.len)
            fail(stmt->location, "'continue' can only be used inside a loop");
        add_jump(st, NULL, End(st->continuestack)[-1], End(st->continuestack)[-1], NULL);
        break;

    case AstStatementKind::Assign:
        {
            const AstExpression *targetexpr = &stmt->data.assignment.target;
            const AstExpression *valueexpr = &stmt->data.assignment.value;
            const LocalVariable *target;

            if (targetexpr->kind == AstExpressionKind::GetVariable
                and (target = find_local_var_cf(st, targetexpr->data.varname)))
            {
                // avoid pointers to help simplify_cfg
                const LocalVariable *value = build_expression(st, valueexpr);
                add_unary_op(st, stmt->location, CfInstructionKind::VarCpy, value, target);
            } else {
                // TODO: is this evaluation order good?
                target = build_address_of_expression(st, targetexpr);
                const LocalVariable *value = build_expression(st, valueexpr);
                assert(target->type->kind == TypeKind::Pointer);
                add_binary_op(st, stmt->location, CF_PTR_STORE, target, value, NULL);
            }
            break;
        }

    case AstStatementKind::InPlaceAdd:
    case AstStatementKind::InPlaceSub:
    case AstStatementKind::InPlaceMul:
    case AstStatementKind::InPlaceDiv:
    case AstStatementKind::InPlaceMod:
    {
        const AstExpression *targetexpr = &stmt->data.assignment.target;
        rhsexpr: AstExpression* = &stmt->data.assignment.value;

        const LocalVariable *targetptr = build_address_of_expression(st, targetexpr);
        rhs: LocalVariable* = build_expression(st, rhsexpr);
        assert(targetptr->type->kind == TypeKind::Pointer);
        const LocalVariable *oldvalue = add_local_var(st, targetptr->type->data.valuetype);
        add_unary_op(st, stmt->location, CfInstructionKind::PtrLoad, targetptr, oldvalue);
        op: AstExpressionKind;
        switch(stmt->kind){
            case AstStatementKind::InPlaceAdd: op=AstExpressionKind::Add
            case AstStatementKind::InPlaceSub: op=AstExpressionKind::Sub
            case AstStatementKind::InPlaceMul: op=AstExpressionKind::Mul
            case AstStatementKind::InPlaceDiv: op=AstExpressionKind::Div
            case AstStatementKind::InPlaceMod: op=AstExpressionKind::Mod
            default: assert(0);
        }
        const LocalVariable *newvalue = build_binop(st, op, stmt->location, oldvalue, rhs, targetptr->type->data.valuetype);
        add_binary_op(st, stmt->location, CF_PTR_STORE, targetptr, newvalue, NULL);
        break;
    }

    case AstStatementKind::Return:
        if (stmt->data.returnvalue) {
            const LocalVariable *retvalue = build_expression(st, stmt->data.returnvalue);
            const LocalVariable *retvariable = find_local_var_cf(st, "return");
            assert(retvariable);
            add_unary_op(st, stmt->location, CfInstructionKind::VarCpy, retvalue, retvariable);
        }
        st->current_block->iftrue = &st->cfg->end_block;
        st->current_block->iffalse = &st->cfg->end_block;
        st->current_block = add_block(st)  // an unreachable block
        break;

    case AstStatementKind::DeclareLocalVar:
        if (stmt->data.vardecl.value) {
            const LocalVariable *v = find_local_var_cf(st, stmt->data.vardecl.name);
            assert(v);
            const LocalVariable *cfvar = build_expression(st, stmt->data.vardecl.value);
            add_unary_op(st, stmt->location, CfInstructionKind::VarCpy, cfvar, v);
        }
        break;

    case AstStatementKind::ExpressionStatement:
        build_expression(st, &stmt->data.expression);
        break;

    case AstStatementKind::Function:
    case AstStatementKind::GlobalVariableDeclaration:
    case AstStatementKind::GlobalVariableDefinition:
    case AstStatementKind::DefineClass:
    case AstStatementKind::DefineEnum:
        assert(0);
    }
}

static void build_body(st: State*, const AstBody *body)
{
    for (int i = 0; i < body->nstatements; i++)
        build_statement(st, &body->statements[i]);
}

static CfGraph *build_function_or_method(st: State*, const Type *selfclass, const char *name, const AstBody *body)
{
    assert(!st->fomtypes);
    assert(!st->cfg);

    for (const FunctionOrMethodTypes *f = st->filetypes->fomtypes.ptr; f < End(st->filetypes->fomtypes); f++) {
        if (!strcmp(f->signature.name, name) and get_self_class(&f->signature) == selfclass) {
            st->fomtypes = f;
            break;
        }
    }
    assert(st->fomtypes);

    st->cfg = calloc(1, sizeof *st->cfg);
    st->cfg->signature = copy_signature(&st->fomtypes->signature);
    for (LocalVariable **v = st->fomtypes->locals.ptr; v < End(st->fomtypes->locals); v++)
        Append(&st->cfg->locals, *v);
    Append(&st->cfg->all_blocks, &st->cfg->start_block);
    Append(&st->cfg->all_blocks, &st->cfg->end_block);
    st->current_block = &st->cfg->start_block;

    assert(st->breakstack.len == 0 and st->continuestack.len == 0);
    build_body(st, body);
    assert(st->breakstack.len == 0 and st->continuestack.len == 0);

    // Implicit return at the end of the function
    st->current_block->iftrue = &st->cfg->end_block;
    st->current_block->iffalse = &st->cfg->end_block;

    CfGraph *cfg = st->cfg;
    st->fomtypes = NULL;
    st->cfg = NULL;
    return cfg;
}

// TODO: passing a type context here doesn't really make sense.
// It would be better to pass only the public symbols that have been imported.
CfGraphFile build_control_flow_graphs(const AstFile *ast, FileTypes *filetypes)
{
    CfGraphFile result = { .filename = ast->path };
    struct State st = { .filetypes = filetypes };

    for (int i = 0; i < ast->body.nstatements; i++) {
        const AstStatement *stmt = &ast->body.statements[i];
        if(stmt->kind == AstStatementKind::Function and stmt->data.function.body.nstatements > 0) {
            CfGraph *g = build_function_or_method(&st, NULL, stmt->data.function.signature.name, &stmt->data.function.body);
            Append(&result.graphs, g);
        }

        if (stmt->kind == AstStatementKind::DefineClass) {
            Type *class_type = NULL;
            for (Type **t = filetypes->owned_types.ptr; t < End(filetypes->owned_types); t++) {
                if (!strcmp((*t)->name, stmt->data.classdef.name)) {
                    class_type = *t;
                    break;
                }
            }
            assert(class_type);

            for (AstClassMember *m = stmt->data.classdef.members.ptr; m < End(stmt->data.classdef.members); m++) {
                if (m->kind == AstClassMemberKind::Method) {
                    CfGraph *g = build_function_or_method(&st, class_type, m->data.method.signature.name, &m->data.method.body);
                    Append(&result.graphs, g);
                }
            }
        }
    }

    free(st.breakstack.ptr);
    free(st.continuestack.ptr);
    return result
}
