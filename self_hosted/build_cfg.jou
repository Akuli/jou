#include "jou_compiler.h"

struct State {
    const FileTypes *filetypes;
    const FunctionOrMethodTypes *fomtypes;
    CfGraph *cfg;
    CfBlock *current_block;
    List(CfBlock *) breakstack;
    List(CfBlock *) continuestack;
};

static const LocalVariable *find_local_var(const struct State *st, const char *name)
{
    for (LocalVariable **var = st->cfg->locals.ptr; var < End(st->cfg->locals); var++)
        if (!strcmp((*var)->name, name))
            return *var;
    return NULL;
}

static LocalVariable *add_local_var(struct State *st, const Type *t)
{
    LocalVariable *var = calloc(1, sizeof *var);
    var->id = st->cfg->locals.len;
    var->type = t;
    Append(&st->cfg->locals, var);
    return var;
}

static const ExpressionTypes *get_expr_types(const struct State *st, const AstExpression *expr)
{
    // TODO: a fancy binary search algorithm (need to add sorting)
    assert(st->fomtypes);
    for (int i = 0; i < st->fomtypes->expr_types.len; i++)
        if (st->fomtypes->expr_types.ptr[i]->expr == expr)
            return st->fomtypes->expr_types.ptr[i];
    return NULL;
}

static CfBlock *add_block(const struct State *st)
{
    CfBlock *block = calloc(1, sizeof *block);
    Append(&st->cfg->all_blocks, block);
    return block;
}

static void add_jump(
    struct State *st,
    const LocalVariable *branchvar,
    CfBlock *iftrue,
    CfBlock *iffalse,
    CfBlock *new_current_block)
{
    assert((iftrue && iffalse) || (!iftrue && !iffalse && !branchvar));
    if (iftrue != iffalse) {
        assert(branchvar);
        assert(branchvar->type == boolType);
    }

    st->current_block->branchvar = branchvar;
    st->current_block->iftrue = iftrue;
    st->current_block->iffalse = iffalse;
    st->current_block = new_current_block ? new_current_block : add_block(st);
}

// returned pointer is only valid until next call to add_instruction()
static CfInstruction *add_instruction(
    const struct State *st,
    Location location,
    enum CfInstructionKind k,
    const union CfInstructionData *dat,
    const LocalVariable **operands, // NULL terminated, or NULL for empty
    const LocalVariable *destvar)
{
    CfInstruction ins = { .location=location, .kind=k, .destvar=destvar };
    if (dat)
        ins.data=*dat;

    while (operands && operands[ins.noperands])
        ins.noperands++;
    if (ins.noperands) {
        size_t nbytes = sizeof(ins.operands[0]) * ins.noperands;  // NOLINT
        ins.operands = malloc(nbytes);
        memcpy(ins.operands, operands, nbytes);
    }

    Append(&st->current_block->instructions, ins);
    return &st->current_block->instructions.ptr[st->current_block->instructions.len - 1];
}

// add_instruction() takes many arguments. Let's hide the mess a bit.
#define add_unary_op(st, loc, op, arg, target) \
    add_instruction((st), (loc), (op), NULL, (const LocalVariable*[]){(arg),NULL}, (target))
#define add_binary_op(st, loc, op, lhs, rhs, target) \
    add_instruction((st), (loc), (op), NULL, (const LocalVariable*[]){(lhs),(rhs),NULL}, (target))
#define add_constant(st, loc, c, target) \
    add_instruction((st), (loc), CfInstructionKind::Constant, &(union CfInstructionData){ .constant=copy_constant((Constant[]){c}) }, NULL, (target))


static const LocalVariable *build_bool_to_int_conversion(
    struct State *st, const LocalVariable *boolvar, const Location location, const Type *t)
{
    assert(is_integer_type(t));
    LocalVariable *result = add_local_var(st, t);

    CfBlock *set1 = add_block(st);
    CfBlock *set0 = add_block(st);
    CfBlock *done = add_block(st);

    add_jump(st, boolvar, set1, set0, set1);
    add_constant(st, location, int_constant(t, 1), result)->hide_unreachable_warning = true;
    add_jump(st, NULL, done, done, set0);
    add_constant(st, location, int_constant(t, 0), result)->hide_unreachable_warning = true;
    add_jump(st, NULL, done, done, done);

    return result;
}

static const LocalVariable *build_cast(
    struct State *st, const LocalVariable *obj, const Type *to, Location location)
{
    if (obj->type == to)
        return obj;

    if (is_pointer_type(obj->type) && is_pointer_type(to)) {
        const LocalVariable *result = add_local_var(st, to);
        add_unary_op(st, location, CF_PTR_CAST, obj, result);
        return result;
    }

    if (is_number_type(obj->type) && is_number_type(to)) {
        const LocalVariable *result = add_local_var(st, to);
        add_unary_op(st, location, CF_NUM_CAST, obj, result);
        return result;
    }

    if (is_number_type(obj->type) && obj->type->data.width_in_bits == 64 && is_pointer_type(to)) {
        const LocalVariable *result = add_local_var(st, to);
        add_unary_op(st, location, CF_INT64_TO_PTR, obj, result);
        return result;
    }

    if (is_integer_type(obj->type) || to->kind == TypeKind::Enum) {
        const LocalVariable *i32var = add_local_var(st, intType);
        const LocalVariable *result = add_local_var(st, to);
        add_unary_op(st, location, CF_NUM_CAST, obj, i32var);
        add_unary_op(st, location, CF_INT32_TO_ENUM, i32var, result);
        return result;
    }

    if (obj->type->kind == TypeKind::Enum && is_integer_type(to)) {
        const LocalVariable *i32var = add_local_var(st, intType);
        const LocalVariable *result = add_local_var(st, to);
        add_unary_op(st, location, CF_ENUM_TO_INT32, obj, i32var);
        add_unary_op(st, location, CF_NUM_CAST, i32var, result);
        return result;
    }

    if (obj->type == boolType && is_integer_type(to))
        return build_bool_to_int_conversion(st, obj, location, to);

    if (is_pointer_type(obj->type) && is_integer_type(to) && to->data.width_in_bits == 64) {
        const LocalVariable *result = add_local_var(st, to);
        add_unary_op(st, location, CF_PTR_TO_INT64, obj, result);
        return result;
    }

    assert(0);
}

static const LocalVariable *build_bool_eq(struct State *st, Location location, const LocalVariable *a, const LocalVariable *b)
{
    assert(a->type == boolType);
    assert(b->type == boolType);

    /*
    Pseudo code:

        if a:
            result = b
        else:
            result = not b
    */
    const LocalVariable *result = add_local_var(st, boolType);

    CfBlock *atrue = add_block(st);
    CfBlock *afalse = add_block(st);
    CfBlock *done = add_block(st);

    // if a:
    add_jump(st, a, atrue, afalse, atrue);

    // result = b
    add_unary_op(st, location, CF_VARCPY, b, result);

    // else:
    add_jump(st, NULL, done, done, afalse);

    // result = not b
    add_unary_op(st, location, CF_BOOL_NEGATE, b, result);

    add_jump(st, NULL, done, done, done);
    return result;
}

static const LocalVariable *build_binop(
    struct State *st,
    enum AstExpressionKind op,
    Location location,
    const LocalVariable *lhs,
    const LocalVariable *rhs,
    const Type *result_type)
{
    bool got_bools = lhs->type == boolType && rhs->type == boolType;
    bool got_numbers = is_number_type(lhs->type) && is_number_type(rhs->type);
    bool got_pointers = is_pointer_type(lhs->type) && is_pointer_type(rhs->type);
    assert(got_bools || got_numbers || got_pointers);

    bool negate = false;
    bool swap = false;

    const LocalVariable *destvar;
    if (got_bools) {
        assert(result_type == boolType);
        destvar = build_bool_eq(st, location, lhs, rhs);
        switch(op) {
            case AstExpressionKind::Eq: break;
            case AstExpressionKind::Ne: negate=true; break;
            default: assert(0); break;
        }
    } else {
        destvar = add_local_var(st, result_type);
        enum CfInstructionKind k;
        switch(op) {
            case AstExpressionKind::Add: k = CF_NUM_ADD; break;
            case AstExpressionKind::Sub: k = CF_NUM_SUB; break;
            case AstExpressionKind::Mul: k = CF_NUM_MUL; break;
            case AstExpressionKind::Div: k = CF_NUM_DIV; break;
            case AstExpressionKind::Mod: k = CF_NUM_MOD; break;
            case AstExpressionKind::Eq: k = CF_NUM_EQ; break;
            case AstExpressionKind::Ne: k = CF_NUM_EQ; negate=true; break;
            case AstExpressionKind::Lt: k = CF_NUM_LT; break;
            case AstExpressionKind::Gt: k = CF_NUM_LT; swap=true; break;
            case AstExpressionKind::Le: k = CF_NUM_LT; negate=true; swap=true; break;
            case AstExpressionKind::Ge: k = CF_NUM_LT; negate=true; break;
            default: assert(0);
        }
        add_binary_op(st, location, k, swap?rhs:lhs, swap?lhs:rhs, destvar);
    }

    if (!negate)
        return destvar;

    const LocalVariable *negated = add_local_var(st, boolType);
    add_unary_op(st, location, CF_BOOL_NEGATE, destvar, negated);
    return negated;
}

static const LocalVariable *build_class_field_pointer(
    struct State *st, const LocalVariable *instance, const char *fieldname, Location location)
{
    assert(instance->type->kind == TypeKind::Pointer);
    assert(instance->type->data.valuetype->kind == TypeKind::Class);
    const Type *classtype = instance->type->data.valuetype;

    for (struct ClassField *f = classtype->data.classdata.fields.ptr; f < End(classtype->data.classdata.fields); f++) {
        if (!strcmp(f->name, fieldname)) {
            union CfInstructionData dat;
            safe_strcpy(dat.fieldname, f->name);

            LocalVariable* result = add_local_var(st, get_pointer_type(f->type));
            add_instruction(st, location, CF_PTR_CLASS_FIELD, &dat, (const LocalVariable*[]){instance,NULL}, result);
            return result;
        }
    }

    assert(0);
}

static const LocalVariable *build_class_field(
    struct State *st, const LocalVariable *instance, const char *fieldname, Location location)
{
    const LocalVariable *ptr = add_local_var(st, get_pointer_type(instance->type));
    add_unary_op(st, location, CF_ADDRESS_OF_LOCAL_VAR, instance, ptr);
    const LocalVariable *field_ptr = build_class_field_pointer(st, ptr, fieldname, location);
    const LocalVariable *field = add_local_var(st, field_ptr->type->data.valuetype);
    add_unary_op(st, location, CF_PTR_LOAD, field_ptr, field);
    return field;
}

static const LocalVariable *build_expression(struct State *st, const AstExpression *expr);
static const LocalVariable *build_address_of_expression(struct State *st, const AstExpression *address_of_what);

enum PreOrPost { PRE, POST };

static const LocalVariable *build_increment_or_decrement(
    struct State *st,
    Location location,
    const AstExpression *inner,
    enum PreOrPost pop,
    int diff)
{
    assert(diff==1 || diff==-1);  // 1=increment, -1=decrement

    const LocalVariable *addr = build_address_of_expression(st, inner);
    assert(addr->type->kind == TypeKind::Pointer);
    const Type *t = addr->type->data.valuetype;
    if (!is_integer_type(t) && !is_pointer_type(t))
        fail(location, "cannot %s a value of type %s", diff==1?"increment":"decrement", t->name);

    const LocalVariable *old_value = add_local_var(st, t);
    const LocalVariable *new_value = add_local_var(st, t);
    const LocalVariable *diffvar = add_local_var(st, is_integer_type(t) ? t : intType);

    add_constant(st, location, int_constant(diffvar->type, diff), diffvar);
    add_unary_op(st, location, CF_PTR_LOAD, addr, old_value);
    add_binary_op(st, location, is_number_type(t)?CF_NUM_ADD:CF_PTR_ADD_INT, old_value, diffvar, new_value);
    add_binary_op(st, location, CF_PTR_STORE, addr, new_value, NULL);

    switch(pop) {
        case PRE: return new_value;
        case POST: return old_value;
    }
    assert(0);
}

enum AndOr { AND, OR };

static const LocalVariable *build_and_or(
    struct State *st, const AstExpression *lhsexpr, const AstExpression *rhsexpr, enum AndOr andor)
{
    /*
    Must be careful with side effects.

    and:
        # lhs returning False means we don't evaluate rhs
        if lhs:
            result = rhs
        else:
            result = False

    or:
        # lhs returning True means we don't evaluate rhs
        if lhs:
            result = True
        else:
            result = rhs
    */
    const LocalVariable *lhs = build_expression(st, lhsexpr);
    const LocalVariable *rhs;
    const LocalVariable *result = add_local_var(st, boolType);
    CfInstruction *ins;

    CfBlock *lhstrue = add_block(st);
    CfBlock *lhsfalse = add_block(st);
    CfBlock *done = add_block(st);

    // if lhs:
    add_jump(st, lhs, lhstrue, lhsfalse, lhstrue);

    switch(andor) {
    case AND:
        // result = rhs
        rhs = build_expression(st, rhsexpr);
        add_unary_op(st, rhsexpr->location, CF_VARCPY, rhs, result);
        break;
    case OR:
        // result = True
        ins = add_constant(st, lhsexpr->location, ((Constant){ConstantKind::Bool, {.boolean=true}}), result);
        ins->hide_unreachable_warning = true;
        break;
    }

    // else:
    add_jump(st, NULL, done, done, lhsfalse);

    switch(andor) {
    case AND:
        // result = False
        ins = add_constant(st, lhsexpr->location, ((Constant){ConstantKind::Bool, {.boolean=false}}), result);
        ins->hide_unreachable_warning = true;
        break;
    case OR:
        // result = rhs
        rhs = build_expression(st, rhsexpr);
        add_unary_op(st, rhsexpr->location, CF_VARCPY, rhs, result);
        break;
    }

    add_jump(st, NULL, done, done, done);
    return result;
}

static const LocalVariable *build_address_of_expression(struct State *st, const AstExpression *address_of_what)
{
    switch(address_of_what->kind) {
    case AstExpressionKind::GetVariable:
    {
        const Type *ptrtype = get_pointer_type(get_expr_types(st, address_of_what)->type);
        const LocalVariable *addr = add_local_var(st, ptrtype);

        const LocalVariable *local_var = find_local_var(st, address_of_what->data.varname);
        if (local_var) {
            add_unary_op(st, address_of_what->location, CF_ADDRESS_OF_LOCAL_VAR, local_var, addr);
        } else {
            // Global variable (possibly imported from another file)
            union CfInstructionData data;
            safe_strcpy(data.globalname, address_of_what->data.varname);
            add_instruction(st, address_of_what->location, CF_ADDRESS_OF_GLOBAL_VAR, &data, NULL, addr);
        }
        return addr;
    }
    case AstExpressionKind::Dereference:
    {
        // &*foo --> just evaluate foo
        return build_expression(st, &address_of_what->data.operands[0]);
    }
    case AstExpressionKind::DerefAndGetField:
    {
        // &obj->field aka &(obj->field)
        const LocalVariable *obj = build_expression(st, address_of_what->data.classfield.obj);
        assert(obj->type->kind == TypeKind::Pointer);
        assert(obj->type->data.valuetype->kind == TypeKind::Class);
        return build_class_field_pointer(st, obj, address_of_what->data.classfield.fieldname, address_of_what->location);
    }
    case AstExpressionKind::GetField:
    {
        // &obj.field aka &(obj.field), evaluate as &(&obj)->field
        const LocalVariable *obj = build_address_of_expression(st, address_of_what->data.classfield.obj);
        assert(obj->type->kind == TypeKind::Pointer);
        return build_class_field_pointer(st, obj, address_of_what->data.classfield.fieldname, address_of_what->location);
    }
    case AstExpressionKind::Indexing:
    {
        const LocalVariable *ptr = build_expression(st, &address_of_what->data.operands[0]);
        assert(ptr->type->kind == TypeKind::Pointer);

        const LocalVariable *index = build_expression(st, &address_of_what->data.operands[1]);
        assert(is_integer_type(index->type));

        const LocalVariable *result = add_local_var(st, ptr->type);
        add_binary_op(st, address_of_what->location, CF_PTR_ADD_INT, ptr, index, result);
        return result;
    }

    default:
        assert(0);
        break;
    }

    assert(0);
}

static const LocalVariable *build_function_or_method_call(
    struct State *st,
    const Location location,
    const AstCall *call,
    const AstExpression *self,
    bool self_is_a_pointer)
{
    const Signature *sig = NULL;

    if(self) {
        const Type *selfclass = get_expr_types(st, self)->type;
        if (self_is_a_pointer) {
            assert(selfclass->kind == TypeKind::Pointer);
            selfclass = selfclass->data.valuetype;
        }
        assert(selfclass->kind == TypeKind::Class);

        for (const Signature *s = selfclass->data.classdata.methods.ptr; s < End(selfclass->data.classdata.methods); s++) {
            assert(get_self_class(s) == selfclass);
            if (!strcmp(s->name, call->calledname)) {
                sig = s;
                break;
            }
        }
    } else {
        for (const struct SignatureAndUsedPtr *f = st->filetypes->functions.ptr; f < End(st->filetypes->functions); f++) {
            if (!strcmp(f->signature.name, call->calledname)) {
                sig = &f->signature;
                break;
            }
        }
    }
    assert(sig);

    const LocalVariable **args = calloc(call->nargs + 2, sizeof(args[0]));  // NOLINT
    int k = 0;

    if (self) {
        if (is_pointer_type(sig->argtypes[0]) && !self_is_a_pointer) {
            args[k++] = build_address_of_expression(st, self);
        } else if (!is_pointer_type(sig->argtypes[0]) && self_is_a_pointer) {
            const LocalVariable *self_ptr = build_expression(st, self);
            assert(self_ptr->type->kind == TypeKind::Pointer);

            // dereference the pointer
            const LocalVariable *val = add_local_var(st, self_ptr->type->data.valuetype);
            add_unary_op(st, self->location, CF_PTR_LOAD, self_ptr, val);
            args[k++] = val;
        } else {
            args[k++] = build_expression(st, self);
        }
    }

    for (int i = 0; i < call->nargs; i++)
        args[k++] = build_expression(st, &call->args[i]);

    const LocalVariable *return_value;
    if (sig->returntype)
        return_value = add_local_var(st, sig->returntype);
    else
        return_value = NULL;

    union CfInstructionData data = { .signature = copy_signature(sig) };
    add_instruction(st, location, CfInstructionKind::Call, &data, args, return_value);

    if (sig->is_noreturn) {
        // Place the remaining code into an unreachable block, so you will get a warning if there is any
        add_jump(st, NULL, NULL, NULL, NULL);
    }

    free(args);
    return return_value;
}

static const LocalVariable *build_struct_init(struct State *st, const Type *type, const AstCall *call, Location location)
{
    const LocalVariable *instance = add_local_var(st, type);
    const LocalVariable *instanceptr = add_local_var(st, get_pointer_type(type));

    add_unary_op(st, location, CF_ADDRESS_OF_LOCAL_VAR, instance, instanceptr);
    add_unary_op(st, location, CF_PTR_MEMSET_TO_ZERO, instanceptr, NULL);

    for (int i = 0; i < call->nargs; i++) {
        const LocalVariable *fieldptr = build_class_field_pointer(st, instanceptr, call->argnames[i], call->args[i].location);
        const LocalVariable *fieldval = build_expression(st, &call->args[i]);
        add_binary_op(st, location, CF_PTR_STORE, fieldptr, fieldval, NULL);
    }

    return instance;
}

static const LocalVariable *build_array(struct State *st, const Type *type, const AstExpression *items, Location location)
{
    assert(type->kind == TypeKind::Array);

    const LocalVariable *arr = add_local_var(st, type);
    const LocalVariable *arrptr = add_local_var(st, get_pointer_type(type));
    add_unary_op(st, location, CF_ADDRESS_OF_LOCAL_VAR, arr, arrptr);
    const LocalVariable *first_item_ptr = add_local_var(st, get_pointer_type(type->data.array.membertype));
    add_unary_op(st, location, CF_PTR_CAST, arrptr, first_item_ptr);

    for (int i = 0; i < type->data.array.len; i++) {
        const LocalVariable *value = build_expression(st, &items[i]);

        const LocalVariable *ivar = add_local_var(st, intType);
        add_constant(st, location, int_constant(intType, i), ivar);

        const LocalVariable *destptr = add_local_var(st, first_item_ptr->type);
        add_binary_op(st, location, CF_PTR_ADD_INT, first_item_ptr, ivar, destptr);
        add_binary_op(st, location, CF_PTR_STORE, destptr, value, NULL);
    }

    return arr;
}

static int find_enum_member(const Type *enumtype, const char *name)
{
    for (int i = 0; i < enumtype->data.enummembers.count; i++)
        if (!strcmp(enumtype->data.enummembers.names[i], name))
            return i;
    assert(0);
}

static const LocalVariable *build_expression(struct State *st, const AstExpression *expr)
{
    const ExpressionTypes *types = get_expr_types(st, expr);
    if (types && types->implicit_array_to_pointer_cast) {
        const LocalVariable *arrptr = build_address_of_expression(st, expr);
        const LocalVariable *memberptr = add_local_var(st, types->implicit_cast_type);
        add_unary_op(st, expr->location, CF_PTR_CAST, arrptr, memberptr);
        return memberptr;
    }

    if (types && types->implicit_string_to_array_cast) {
        assert(types->implicit_cast_type);
        assert(types->implicit_cast_type->kind == TypeKind::Array);
        assert(expr->kind == AstExpressionKind::Constant);
        assert(expr->data.constant.kind == ConstantKind::String);

        char *padded = calloc(1, types->implicit_cast_type->data.array.len);
        strcpy(padded, expr->data.constant.data.str);

        const LocalVariable *result = add_local_var(st, types->implicit_cast_type);
        union CfInstructionData data = { .strarray = {
            .len = types->implicit_cast_type->data.array.len,
            .str = padded,
        }};
        add_instruction(st, expr->location, CfInstructionKind::StringArray, &data, NULL, result);
        return result;
    }

    const LocalVariable *result, *temp;

    switch(expr->kind) {
    case AstExpressionKind::DerefAndCallMethod:
        result = build_function_or_method_call(st, expr->location, &expr->data.methodcall.call, expr->data.methodcall.obj, true);
        if (!result)
            return NULL;
        break;
    case AstExpressionKind::CallMethod:
        result = build_function_or_method_call(st, expr->location, &expr->data.methodcall.call, expr->data.methodcall.obj, false);
        if (!result)
            return NULL;
        break;
    case AstExpressionKind::FunctionCall:
        result = build_function_or_method_call(st, expr->location, &expr->data.call, NULL, false);
        if (!result)
            return NULL;
        break;
    case AstExpressionKind::BraceInit:
        result = build_struct_init(st, types->type, &expr->data.call, expr->location);
        break;
    case AstExpressionKind::Array:
        assert(types->type->kind == TypeKind::Array);
        assert(types->type->data.array.len == expr->data.array.count);
        result = build_array(st, types->type, expr->data.array.items, expr->location);
        break;
    case AstExpressionKind::GetField:
        temp = build_expression(st, expr->data.classfield.obj);
        result = build_class_field(st, temp, expr->data.classfield.fieldname, expr->location);
        break;
    case AstExpressionKind::GetEnumMember:
        result = add_local_var(st, types->type);
        Constant c = { ConstantKind::EnumMember, {
            .enum_member.enumtype = types->type,
            .enum_member.memberidx = find_enum_member(types->type, expr->data.enummember.membername),
        }};
        add_constant(st, expr->location, c, result);
        break;
    case AstExpressionKind::GetVariable:
        if (get_special_constant(expr->data.varname) != -1) {
            result = add_local_var(st, boolType);
            union CfInstructionData data;
            safe_strcpy(data.scname, expr->data.varname);
            add_instruction(st, expr->location, CF_SPECIAL_CONSTANT, &data, NULL, result);
            break;
        }
        if ((temp = find_local_var(st, expr->data.varname))) {
            if (types->implicit_cast_type == NULL || types->type == types->implicit_cast_type) {
                // Must take a "snapshot" of this variable, as it may change soon.
                result = add_local_var(st, temp->type);
                add_unary_op(st, expr->location, CF_VARCPY, temp, result);
            } else {
                result = temp;
            }
            break;
        }
        // For other than local variables we can evaluate as &*variable.
        // Would also work for locals, but it would confuse simplify_cfg.
        __attribute__((fallthrough));
    case AstExpressionKind::DerefAndGetField:
    case AstExpressionKind::Indexing:
        /*
        To evaluate foo->bar, we first evaluate &foo->bar and then dereference.
        We can similarly evaluate &foo[bar].

        This technique cannot be used with all expressions. For example, &(1+2)
        doesn't work, and &foo.bar doesn't work either whenever &foo doesn't work.
        But &foo->bar and &foo[bar] always work, because foo is already a pointer
        and we only add a memory offset to it.
        */
        temp = build_address_of_expression(st, expr);
        result = add_local_var(st, types->type);
        add_unary_op(st, expr->location, CF_PTR_LOAD, temp, result);
        break;
    case AstExpressionKind::AddressOf:
        result = build_address_of_expression(st, &expr->data.operands[0]);
        break;
    case AstExpressionKind::SizeOf:
        {
            result = add_local_var(st, longType);
            union CfInstructionData data = { .type = get_expr_types(st, &expr->data.operands[0])->type };
            add_instruction(st, expr->location, CF_SIZEOF, &data, NULL, result);
        }
        break;
    case AstExpressionKind::Dereference:
        temp = build_expression(st, &expr->data.operands[0]);
        result = add_local_var(st, types->type);
        add_unary_op(st, expr->location, CF_PTR_LOAD, temp, result);
        break;
    case AstExpressionKind::Constant:
        result = add_local_var(st, types->type);
        add_constant(st, expr->location, expr->data.constant, result);
        break;
    case AstExpressionKind::And:
        result = build_and_or(st, &expr->data.operands[0], &expr->data.operands[1], AND);
        break;
    case AstExpressionKind::Or:
        result = build_and_or(st, &expr->data.operands[0], &expr->data.operands[1], OR);
        break;
    case AstExpressionKind::Not:
        temp = build_expression(st, &expr->data.operands[0]);
        result = add_local_var(st, boolType);
        add_unary_op(st, expr->location, CF_BOOL_NEGATE, temp, result);
        break;
    case AstExpressionKind::Neg:
        temp = build_expression(st, &expr->data.operands[0]);
        const LocalVariable *zero = add_local_var(st, temp->type);
        result = add_local_var(st, temp->type);
        if (temp->type == doubleType)
            add_constant(st, expr->location, ((Constant){ ConstantKind::Double, {.double_or_float_text="0"} }), zero);
        else if (temp->type == floatType)
            add_constant(st, expr->location, ((Constant){ ConstantKind::Float, {.double_or_float_text="0"}}), zero);
        else
            add_constant(st, expr->location, int_constant(temp->type, 0), zero);
        add_binary_op(st, expr->location, CF_NUM_SUB, zero, temp, result);
        break;
    case AstExpressionKind::Add:
    case AstExpressionKind::Sub:
    case AstExpressionKind::Mul:
    case AstExpressionKind::Div:
    case AstExpressionKind::Mod:
    case AstExpressionKind::Eq:
    case AstExpressionKind::Ne:
    case AstExpressionKind::Gt:
    case AstExpressionKind::Ge:
    case AstExpressionKind::Lt:
    case AstExpressionKind::Le:
        {
            // Refactoring note: Make sure to evaluate lhs first. C doesn't guarantee evaluation
            // order of function arguments.
            const LocalVariable *lhs = build_expression(st, &expr->data.operands[0]);
            const LocalVariable *rhs = build_expression(st, &expr->data.operands[1]);
            result = build_binop(st, expr->kind, expr->location, lhs, rhs, types->type);
            break;
        }
    case AstExpressionKind::PreIncrement:
    case AstExpressionKind::PreDecrement:
    case AstExpressionKind::PostIncrement:
    case AstExpressionKind::PostDecrement:
        {
            enum PreOrPost pop;
            int diff;

            switch(expr->kind) {
                case AstExpressionKind::PreIncrement: pop=PRE; diff=1; break;
                case AstExpressionKind::PreDecrement: pop=PRE; diff=-1; break;
                case AstExpressionKind::PostIncrement: pop=POST; diff=1; break;
                case AstExpressionKind::PostDecrement: pop=POST; diff=-1; break;
                default: assert(0);
            }
            result = build_increment_or_decrement(st, expr->location, &expr->data.operands[0], pop, diff);
            break;
        }
    case AstExpressionKind::As:
        temp = build_expression(st, expr->data.as.obj);
        result = build_cast(st, temp, types->type, expr->location);
        break;
    }

    assert(types);
    assert(result->type == types->type);
    if (types->implicit_cast_type)
        return build_cast(st, result, types->implicit_cast_type, expr->location);
    else
        return result;
}

static void build_body(struct State *st, const AstBody *body);

static void build_if_statement(struct State *st, const AstIfStatement *ifstmt)
{
    assert(ifstmt->n_if_and_elifs >= 1);

    CfBlock *done = add_block(st);
    for (int i = 0; i < ifstmt->n_if_and_elifs; i++) {
        const LocalVariable *cond = build_expression(
            st, &ifstmt->if_and_elifs[i].condition);
        CfBlock *then = add_block(st);
        CfBlock *otherwise = add_block(st);

        add_jump(st, cond, then, otherwise, then);
        build_body(st, &ifstmt->if_and_elifs[i].body);
        add_jump(st, NULL, done, done, otherwise);
    }

    build_body(st, &ifstmt->elsebody);
    add_jump(st, NULL, done, done, done);
}

static void build_assert(struct State *st, Location assert_location, const AstAssert *assertion)
{
    const LocalVariable *condvar = build_expression(st, &assertion->condition);

    // If the condition is true, we jump to a block where the rest of the code goes.
    // If the condition is false, we jump to a block that calls _jou_assert_fail().
    CfBlock *trueblock = add_block(st);
    CfBlock *falseblock = add_block(st);
    add_jump(st, condvar, trueblock, falseblock, falseblock);

    char (*argnames)[100] = malloc(3 * sizeof *argnames);
    strcpy(argnames[0], "assertion");
    strcpy(argnames[1], "path");
    strcpy(argnames[2], "lineno");

    const Type **argtypes = malloc(3 * sizeof(argtypes[0]));  // NOLINT
    argtypes[0] = get_pointer_type(byteType);
    argtypes[1] = get_pointer_type(byteType);
    argtypes[2] = intType;

    const LocalVariable *args[4];
    for (int i = 0; i < 3; i++)
        args[i] = add_local_var(st, argtypes[i]);
    args[3] = NULL;

    add_constant(st, assert_location, ((Constant){ConstantKind::String,{.str=assertion->condition_str}}), args[0]);
    char *tmp = strdup(assertion->condition.location.filename);
    add_constant(st, assert_location, ((Constant){ConstantKind::String,{.str=tmp}}), args[1]);
    free(tmp);
    add_constant(st, assert_location, int_constant(intType, assert_location.lineno), args[2]);

    union CfInstructionData data = { .signature = {
        .name = "_jou_assert_fail",
        .nargs = 3,
        .argtypes = argtypes,
        .argnames = argnames,
        .takes_varargs = false,
        .is_noreturn = true,
        .returntype_location = assert_location,
    } };
    add_instruction(st, assert_location, CfInstructionKind::Call, &data, args, NULL);

    st->current_block = trueblock;
}

static void build_statement(struct State *st, const AstStatement *stmt);

// for init; cond; incr:
//     ...body...
//
// While loop is basically a special case of for loop, so it uses this too.
static void build_loop(
    struct State *st,
    const AstStatement *init,
    const AstExpression *cond,
    const AstStatement *incr,
    const AstBody *body)
{
    CfBlock *condblock = add_block(st);  // evaluate condition and go to bodyblock or doneblock
    CfBlock *bodyblock = add_block(st);  // run loop body and go to incrblock
    CfBlock *incrblock = add_block(st);  // run incr and go to condblock
    CfBlock *doneblock = add_block(st);  // rest of the code goes here
    CfBlock *tmp;

    if (init)
        build_statement(st, init);

    // Evaluate condition. Jump to loop body or skip to after loop.
    add_jump(st, NULL, condblock, condblock, condblock);
    const LocalVariable *condvar = build_expression(st, cond);
    add_jump(st, condvar, bodyblock, doneblock, bodyblock);

    // Run loop body: 'break' skips to after loop, 'continue' goes to incr.
    Append(&st->breakstack, doneblock);
    Append(&st->continuestack, incrblock);
    build_body(st, body);
    tmp = Pop(&st->breakstack); assert(tmp == doneblock);
    tmp = Pop(&st->continuestack); assert(tmp == incrblock);

    // Run incr and jump back to condition.
    add_jump(st, NULL, incrblock, incrblock, incrblock);
    if (incr)
        build_statement(st, incr);
    add_jump(st, NULL, condblock, condblock, doneblock);
}

static void build_statement(struct State *st, const AstStatement *stmt)
{
    switch(stmt->kind) {
    case AstStatementKind::If:
        build_if_statement(st, &stmt->data.ifstatement);
        break;

    case AstStatementKind::Assert:
        build_assert(st, stmt->location, &stmt->data.assertion);
        break;

    case AstStatementKind::Pass:
        break;

    case AstStatementKind::While:
        build_loop(
            st, NULL, &stmt->data.whileloop.condition, NULL,
            &stmt->data.whileloop.body);
        break;

    case AstStatementKind::For:
        build_loop(
            st, stmt->data.forloop.init, &stmt->data.forloop.cond, stmt->data.forloop.incr,
            &stmt->data.forloop.body);
        break;

    case AstStatementKind::Break:
        if (!st->breakstack.len)
            fail(stmt->location, "'break' can only be used inside a loop");
        add_jump(st, NULL, End(st->breakstack)[-1], End(st->breakstack)[-1], NULL);
        break;

    case AstStatementKind::Continue:
        if (!st->continuestack.len)
            fail(stmt->location, "'continue' can only be used inside a loop");
        add_jump(st, NULL, End(st->continuestack)[-1], End(st->continuestack)[-1], NULL);
        break;

    case AstStatementKind::Assign:
        {
            const AstExpression *targetexpr = &stmt->data.assignment.target;
            const AstExpression *valueexpr = &stmt->data.assignment.value;
            const LocalVariable *target;

            if (targetexpr->kind == AstExpressionKind::GetVariable
                && (target = find_local_var(st, targetexpr->data.varname)))
            {
                // avoid pointers to help simplify_cfg
                const LocalVariable *value = build_expression(st, valueexpr);
                add_unary_op(st, stmt->location, CF_VARCPY, value, target);
            } else {
                // TODO: is this evaluation order good?
                target = build_address_of_expression(st, targetexpr);
                const LocalVariable *value = build_expression(st, valueexpr);
                assert(target->type->kind == TypeKind::Pointer);
                add_binary_op(st, stmt->location, CF_PTR_STORE, target, value, NULL);
            }
            break;
        }

    case AstStatementKind::InPlaceAdd:
    case AstStatementKind::InPlaceSub:
    case AstStatementKind::InPlaceMul:
    case AstStatementKind::InPlaceDiv:
    case AstStatementKind::InPlaceMod:
    {
        const AstExpression *targetexpr = &stmt->data.assignment.target;
        const AstExpression *rhsexpr = &stmt->data.assignment.value;

        const LocalVariable *targetptr = build_address_of_expression(st, targetexpr);
        const LocalVariable *rhs = build_expression(st, rhsexpr);
        assert(targetptr->type->kind == TypeKind::Pointer);
        const LocalVariable *oldvalue = add_local_var(st, targetptr->type->data.valuetype);
        add_unary_op(st, stmt->location, CF_PTR_LOAD, targetptr, oldvalue);
        enum AstExpressionKind op;
        switch(stmt->kind){
            case AstStatementKind::InPlaceAdd: op=AstExpressionKind::Add; break;
            case AstStatementKind::InPlaceSub: op=AstExpressionKind::Sub; break;
            case AstStatementKind::InPlaceMul: op=AstExpressionKind::Mul; break;
            case AstStatementKind::InPlaceDiv: op=AstExpressionKind::Div; break;
            case AstStatementKind::InPlaceMod: op=AstExpressionKind::Mod; break;
            default: assert(0);
        }
        const LocalVariable *newvalue = build_binop(st, op, stmt->location, oldvalue, rhs, targetptr->type->data.valuetype);
        add_binary_op(st, stmt->location, CF_PTR_STORE, targetptr, newvalue, NULL);
        break;
    }

    case AstStatementKind::Return:
        if (stmt->data.returnvalue) {
            const LocalVariable *retvalue = build_expression(st, stmt->data.returnvalue);
            const LocalVariable *retvariable = find_local_var(st, "return");
            assert(retvariable);
            add_unary_op(st, stmt->location, CF_VARCPY, retvalue, retvariable);
        }
        st->current_block->iftrue = &st->cfg->end_block;
        st->current_block->iffalse = &st->cfg->end_block;
        st->current_block = add_block(st);  // an unreachable block
        break;

    case AstStatementKind::DeclareLocalVar:
        if (stmt->data.vardecl.value) {
            const LocalVariable *v = find_local_var(st, stmt->data.vardecl.name);
            assert(v);
            const LocalVariable *cfvar = build_expression(st, stmt->data.vardecl.value);
            add_unary_op(st, stmt->location, CF_VARCPY, cfvar, v);
        }
        break;

    case AstStatementKind::ExpressionStatement:
        build_expression(st, &stmt->data.expression);
        break;

    case AstStatementKind::Function:
    case AstStatementKind::GlobalVariableDeclaration:
    case AstStatementKind::GlobalVariableDefinition:
    case AstStatementKind::DefineClass:
    case AstStatementKind::DefineEnum:
        assert(0);
    }
}

static void build_body(struct State *st, const AstBody *body)
{
    for (int i = 0; i < body->nstatements; i++)
        build_statement(st, &body->statements[i]);
}

static CfGraph *build_function_or_method(struct State *st, const Type *selfclass, const char *name, const AstBody *body)
{
    assert(!st->fomtypes);
    assert(!st->cfg);

    for (const FunctionOrMethodTypes *f = st->filetypes->fomtypes.ptr; f < End(st->filetypes->fomtypes); f++) {
        if (!strcmp(f->signature.name, name) && get_self_class(&f->signature) == selfclass) {
            st->fomtypes = f;
            break;
        }
    }
    assert(st->fomtypes);

    st->cfg = calloc(1, sizeof *st->cfg);
    st->cfg->signature = copy_signature(&st->fomtypes->signature);
    for (LocalVariable **v = st->fomtypes->locals.ptr; v < End(st->fomtypes->locals); v++)
        Append(&st->cfg->locals, *v);
    Append(&st->cfg->all_blocks, &st->cfg->start_block);
    Append(&st->cfg->all_blocks, &st->cfg->end_block);
    st->current_block = &st->cfg->start_block;

    assert(st->breakstack.len == 0 && st->continuestack.len == 0);
    build_body(st, body);
    assert(st->breakstack.len == 0 && st->continuestack.len == 0);

    // Implicit return at the end of the function
    st->current_block->iftrue = &st->cfg->end_block;
    st->current_block->iffalse = &st->cfg->end_block;

    CfGraph *cfg = st->cfg;
    st->fomtypes = NULL;
    st->cfg = NULL;
    return cfg;
}

// TODO: passing a type context here doesn't really make sense.
// It would be better to pass only the public symbols that have been imported.
CfGraphFile build_control_flow_graphs(const AstFile *ast, FileTypes *filetypes)
{
    CfGraphFile result = { .filename = ast->path };
    struct State st = { .filetypes = filetypes };

    for (int i = 0; i < ast->body.nstatements; i++) {
        const AstStatement *stmt = &ast->body.statements[i];
        if(stmt->kind == AstStatementKind::Function && stmt->data.function.body.nstatements > 0) {
            CfGraph *g = build_function_or_method(&st, NULL, stmt->data.function.signature.name, &stmt->data.function.body);
            Append(&result.graphs, g);
        }

        if (stmt->kind == AstStatementKind::DefineClass) {
            Type *classtype = NULL;
            for (Type **t = filetypes->owned_types.ptr; t < End(filetypes->owned_types); t++) {
                if (!strcmp((*t)->name, stmt->data.classdef.name)) {
                    classtype = *t;
                    break;
                }
            }
            assert(classtype);

            for (AstClassMember *m = stmt->data.classdef.members.ptr; m < End(stmt->data.classdef.members); m++) {
                if (m->kind == AstClassMemberKind::Method) {
                    CfGraph *g = build_function_or_method(&st, classtype, m->data.method.signature.name, &m->data.method.body);
                    Append(&result.graphs, g);
                }
            }
        }
    }

    free(st.breakstack.ptr);
    free(st.continuestack.ptr);
    return result;
}
