# LLVM makes a mess of how to define what kind of computer will run the
# compiled programs. Sometimes it wants a target triple, sometimes a
# data layout. Sometimes it wants a string, sometimes an object
# representing the thing.
#
# This file aims to provide everything you may ever need. Hopefully it
# will make the mess slightly less miserable to you. Just use the global
# "target" variable, it contains everything you will ever need.

import "./llvm.jou"
import "stdlib/str.jou"
import "stdlib/io.jou"
import "stdlib/process.jou"

class Target:
    triple: byte[100]
    data_layout: byte[500]
    target: LLVMTarget*
    target_machine: LLVMTargetMachine*
    target_data: LLVMTargetData*

global target: Target


# This function is a bit of a hack.
#
# Ideally, we would initialize all available targets, or perhaps only the
# native target, but information about supported targets is only in the C
# header files. If we initialize the wrong target, the code will compile, but
# it prints a warning message like this at runtime, every time you invoke the
# Jou compiler:
#
#   'x86-64' is not a recognized processor for this target (ignoring processor)
#
def running_on_arm64_mac() -> bool:
    return MACOS and system("test `uname -m` = arm64") == 0


def init_target() -> None:
    if running_on_arm64_mac():
        LLVMInitializeAArch64TargetInfo()
        LLVMInitializeAArch64Target()
        LLVMInitializeAArch64TargetMC()
        LLVMInitializeAArch64AsmParser()
        LLVMInitializeAArch64AsmPrinter()
    else:
        LLVMInitializeX86TargetInfo()
        LLVMInitializeX86Target()
        LLVMInitializeX86TargetMC()
        LLVMInitializeX86AsmParser()
        LLVMInitializeX86AsmPrinter()

    if WINDOWS:
        # LLVM's default is x86_64-pc-windows-msvc
        target.triple = "x86_64-pc-windows-gnu"
    else:
        system("uname -m")
        fflush(stdout)
        fflush(stderr)
        printf("system(...) returns %d\n", system("test `uname -m` = arm64"))
        fflush(stdout)
        fflush(stderr)
        triple = LLVMGetDefaultTargetTriple()
        fflush(stdout)
        fflush(stderr)
        printf("triple=\"%s\"\n", triple)
        fflush(stdout)
        fflush(stderr)
        assert strlen(triple) < sizeof target.triple
        strcpy(target.triple, triple)
        LLVMDisposeMessage(triple)

    error: byte* = NULL
    if LLVMGetTargetFromTriple(target.triple, &target.target, &error) != 0:
        assert error != NULL
        fprintf(stderr, "LLVMGetTargetFromTriple(\"%s\") failed: %s\n", target.triple, error)
        exit(1)
    assert error == NULL
    assert target.target != NULL

    target.target_machine = LLVMCreateTargetMachine(
        target.target,
        target.triple,
        "x86-64",
        "",
        LLVMCodeGenOptLevel::Default,
        LLVMRelocMode::PIC,
        LLVMCodeModel::Default,
    )
    assert target.target_machine != NULL

    target.target_data = LLVMCreateTargetDataLayout(target.target_machine)
    assert target.target_data != NULL

    tmp = LLVMCopyStringRepOfTargetData(target.target_data)
    assert strlen(tmp) < sizeof target.data_layout
    strcpy(target.data_layout, tmp)
    LLVMDisposeMessage(tmp)

def cleanup_target() -> None:
    LLVMDisposeTargetMachine(target.target_machine)
    LLVMDisposeTargetData(target.target_data)
