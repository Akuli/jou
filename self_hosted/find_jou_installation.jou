from "stdlib/mem.jou" import malloc, realloc, free, memset
from "stdlib/str.jou" import strlen, sprintf, strstr, strcmp, strdup
from "stdlib/io.jou" import fprintf, stderr
from "stdlib/process.jou" import exit, getenv

declare GetModuleFileNameA(hModule: void*, lpFilename: byte*, nSize: int) -> int
declare readlink(linkpath: byte*, result: byte*, result_size: long) -> long

# Return a path to the currently running program. Return value must be free()d.
def find_current_executable() -> byte*:
    buf = NULL
    for size = 2L; True; size *= 2:
        buf = realloc(buf, size)

        if getenv("OS") != NULL and strstr(getenv("OS"), "Windows") != NULL:
            ret: long = GetModuleFileNameA(NULL, buf, size as int)
        else:
            ret = readlink("/proc/self/exe", buf, size)

        if ret <= 0:
            # TODO: include os error message (GetLastError / errno)
            fprintf(stderr, "error: cannot locate currently running executable, needed for finding the Jou standard library\n")
            exit(1)
        if ret < size:
            # buffer is big enough, it fits
            return buf

# TODO: move to stdlib
declare dirname(path: byte*) -> byte*
declare stat(path: byte*, buf: byte[1000]*) -> int  # lol

# Should work on windows and linux
def seems_like_root_of_file_system(path: byte*) -> bool:
    if getenv("OS") != NULL and strstr(getenv("OS"), "Windows") != NULL:
        # windows: C:\ or C:/ or C:
        return strlen(path) <= 3
    else:
        # linux
        return strcmp(path, "/") == 0

def find_stdlib() -> byte*:
    checked: byte*[3]
    memset(&checked, 0, sizeof checked)

    exedir = find_current_executable()
    for i = 0; i < sizeof checked / sizeof checked[0] and not seems_like_root_of_file_system(exedir); i++:
        tmp = strdup(dirname(exedir))
        free(exedir)
        exedir = tmp

        path = malloc(strlen(exedir) + 10)
        sprintf(path, "%s/stdlib", exedir)

        iojou: byte* = malloc(strlen(path) + 10)
        sprintf(iojou, "%s/io.jou", path)
        buf: byte[1000]
        stat_result = stat(iojou, &buf)
        free(iojou)

        if stat_result == 0:
            free(exedir)
            return path

        checked[i] = path

    fprintf(stderr, "error: cannot find the Jou standard library in any of the following locations:\n")
    for i = 0; i < sizeof checked / sizeof checked[0] and checked[i] != NULL; i++:
        fprintf(stderr, "  %s\n", checked[i])
    exit(1)
    return NULL  # TODO: never runs, but compiler shows warning if I delete this
