from "stdlib/mem.jou" import malloc, realloc, free
from "stdlib/str.jou" import strlen, sprintf
from "stdlib/io.jou" import fprintf, stderr
from "stdlib/process.jou" import exit

# TODO: how to compile these only on their respective platforms?
#declare GetModuleFileNameA(hModule: void*, lpFilename: byte*, nSize: int) -> int
declare readlink(linkpath: byte*, result: byte*, result_size: long) -> long

# Return a path to the currently running program. Return value must be free()d.
def find_current_executable() -> byte*:
    buf = NULL
    for size = 2L; True; size *= 2:
        buf = realloc(buf, size)

#        if getenv("OS") != NULL and strstr(getenv("OS"), "Windows") != NULL:
#            ret: long = GetModuleFileNameA(NULL, buf, size as int)
#        else:
#            ret = readlink("/proc/self/exe", buf, size)
        ret = readlink("/proc/self/exe", buf, size)

        if ret <= 0:
            # TODO: include os error message (GetLastError / errno)
            fprintf(stderr, "cannot locate currently running executable, needed for finding the Jou standard library\n")
            exit(1)
        if ret < size:
            # buffer is big enough, it fits
            return buf

# TODO: move to stdlib
declare dirname(path: byte*) -> byte*
declare stat(path: byte*, buf: byte[1000]*) -> int  # lol

def find_stdlib() -> byte*:
    exe = find_current_executable()
    exedir = dirname(exe)
    path = malloc(strlen(exedir) + 10)
    sprintf(path, "%s/stdlib", exedir)
    free(exe)

    iojou: byte* = malloc(strlen(path) + 10)
    sprintf(iojou, "%s/io.jou", path)
    buf: byte[1000]
    if stat(iojou, &buf) != 0:
        fprintf(stderr, "error: cannot find the Jou standard library in %s\n", path)
        exit(1)
    free(iojou)

    return path
