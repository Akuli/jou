# This file turns type-checked AST into LLVM IR. It produces an LLVMModule for each Jou file.
import "./llvm.jou"
import "./typecheck.jou"
import "./types.jou"
import "./ast.jou"
import "./target.jou"
import "stdlib/io.jou"
import "stdlib/mem.jou"
import "stdlib/str.jou"

class LocalVarNameAndPointer:
    name: byte[100]
    pointer: LLVMValue*

class AstToIR:
    module: LLVMModule*
    builder: LLVMBuilder*
    file_types: FileTypes*  # Results of type-checking, so that we know what type each expression is.
    current_function: LLVMValue*
    local_vars: LocalVarNameAndPointer*
    n_local_vars: int

    def get_local_var_pointer(self, name: byte*) -> LLVMValue*:
        for i = 0; i < self->n_local_vars; i++:
            if strcmp(&self->local_vars[i].name[0], name) == 0:
                return self->local_vars[i].pointer
        assert False

    def do_type(self, type: Type*) -> LLVMType*:
        if type->is_integer_type():
            return LLVMIntType(type->size_in_bits)
        if type->kind == TypeKind::Pointer:
            return LLVMPointerType(self->do_type(type->value_type), 0)
        printf("asd-Asd., %s\n", &type->name)
        assert False

    def declare_function(self, sig: Signature*) -> LLVMValue*:
        # Make it so that this can be called many times without issue
        func = LLVMGetNamedFunction(self->module, &sig->name[0])
        if func != NULL:
            return func

        argtypes: LLVMType** = malloc(sig->nargs * sizeof argtypes[0])
        for i = 0; i < sig->nargs; i++:
            argtypes[i] = self->do_type(sig->argtypes[i])

        # TODO: tell llvm if we know a function is noreturn
        if sig->return_type == NULL:  # "-> noreturn" or "-> void"
            return_type = LLVMVoidType()
        else:
            return_type = self->do_type(sig->return_type)

        function_type = LLVMFunctionType(return_type, argtypes, sig->nargs, sig->takes_varargs)
        free(argtypes)

        return LLVMAddFunction(self->module, &sig->name[0], function_type)

    def new_block(self, name_hint: byte*) -> void:
        assert self->current_function != NULL
        block = LLVMAppendBasicBlock(self->current_function, name_hint)
        LLVMPositionBuilderAtEnd(self->builder, block)

    def make_a_string_constant(self, s: byte*) -> LLVMValue*:
        array = LLVMConstString(s, strlen(s) as int, False)
        global_var = LLVMAddGlobal(self->module, LLVMTypeOf(array), "string_literal")
        LLVMSetLinkage(global_var, LLVMLinkage::Private)  # This makes it a static global variable
        LLVMSetInitializer(global_var, array)

        string_type = LLVMPointerType(LLVMInt8Type(), 0)
        return LLVMBuildBitCast(self->builder, global_var, string_type, "string_ptr")

    def build_assert(self, condition: LLVMValue*) -> void:
        true_block = LLVMAppendBasicBlock(self->current_function, "assert_true")
        false_block = LLVMAppendBasicBlock(self->current_function, "assert_false")
        LLVMBuildCondBr(self->builder, condition, true_block, false_block)

        LLVMPositionBuilderAtEnd(self->builder, false_block)

        argtypes = [LLVMPointerType(LLVMInt8Type(), 0), LLVMPointerType(LLVMInt8Type(), 0), LLVMInt32Type()]
        assert_fail_func_type = LLVMFunctionType(LLVMVoidType(), &argtypes[0], 3, False)
        assert_fail_func = LLVMGetNamedFunction(self->module, "_jou_assert_fail")
        if assert_fail_func == NULL:
            assert_fail_func = LLVMAddFunction(self->module, "_jou_assert_fail", assert_fail_func_type)
        assert assert_fail_func != NULL

        args = [
            self->make_a_string_constant("foo"),
            self->make_a_string_constant("bar"),
            LLVMConstInt(LLVMInt32Type(), 123, False),
        ]

        LLVMBuildCall2(self->builder, assert_fail_func_type, assert_fail_func, &args[0], 3, "")
        LLVMPositionBuilderAtEnd(self->builder, true_block)

    def do_address_of_expression(self, ast: AstExpression*) -> LLVMValue*:
        if ast->kind == AstExpressionKind::GetVariable:
            return self->get_local_var_pointer(&ast->varname[0])

        printf("kind: %d\n", ast->kind)
        assert False

    def do_expression(self, ast: AstExpression*) -> LLVMValue*:
        if ast->kind == AstExpressionKind::String:
            return self->make_a_string_constant(ast->string)
        if ast->kind == AstExpressionKind::Byte:
            return LLVMConstInt(LLVMInt8Type(), ast->byte_value, False)
        if ast->kind == AstExpressionKind::Int:
            return LLVMConstInt(LLVMInt32Type(), ast->int_value, False)
        if ast->kind == AstExpressionKind::Long:
            return LLVMConstInt(LLVMInt64Type(), ast->long_value, False)

        if ast->kind == AstExpressionKind::FunctionCall:
            sig = self->file_types->find_function(&ast->call.called_name[0])
            assert sig != NULL
            function = self->declare_function(sig)
            assert LLVMGetTypeKind(LLVMTypeOf(function)) == LLVMTypeKind::Pointer
            function_type = LLVMGetElementType(LLVMTypeOf(function))
            assert LLVMGetTypeKind(function_type) == LLVMTypeKind::Function

            args: LLVMValue** = malloc(sizeof args[0] * ast->call.nargs)
            for i = 0; i < ast->call.nargs; i++:
                args[i] = self->do_expression(&ast->call.args[i])

            name_hint: byte[100]
            if sig->return_type == NULL:
                strcpy(&name_hint[0], "")
            else:
                sprintf(&name_hint[0], "%.20s_return_value", &sig->name[0])

            result = LLVMBuildCall2(self->builder, function_type, function, args, ast->call.nargs, &name_hint[0])
            free(args)
            return result

        if ast->kind == AstExpressionKind::GetVariable:
            pointer = self->do_address_of_expression(ast)
            return LLVMBuildLoad(self->builder, pointer, &ast->varname[0])

        printf("Asd-asd. Unknown expr %d...\n", ast->kind)
        assert False

    def do_statement(self, ast: AstStatement*) -> void:
        if ast->kind == AstStatementKind::ExpressionStatement:
            self->do_expression(&ast->expression)
        elif ast->kind == AstStatementKind::Return:
            if ast->return_value != NULL:
                return_value = self->do_expression(ast->return_value)
                LLVMBuildRet(self->builder, return_value)
            else:
                LLVMBuildRetVoid(self->builder)
            # If more code follows, place it into a new block that never actually runs
            self->new_block("after_return")
        elif ast->kind == AstStatementKind::Assert:
            condition = self->do_expression(&ast->expression)
            self->build_assert(condition)
        elif ast->kind == AstStatementKind::Assign:
            target_pointer = self->do_address_of_expression(&ast->assignment.target)
            value = self->do_expression(&ast->assignment.value)
            LLVMBuildStore(self->builder, value, target_pointer)
        else:
            printf("Asd-asd. Unknown statement...\n")
            assert False

    def do_body(self, body: AstBody*) -> void:
        for i = 0; i < body->nstatements; i++:
            self->do_statement(&body->statements[i])

    # The function must already be declared.
    def define_function(self, funcdef: AstFunction*) -> void:
        func_types = self->file_types->find_defined_function(&funcdef->signature.name[0])
        assert func_types != NULL

        llvm_func = self->declare_function(&func_types->signature)
        assert self->current_function == NULL
        self->current_function = llvm_func
        self->new_block("start")

        # Allocate all local variables at the start of the function.
        assert self->n_local_vars == 0
        assert self->local_vars == NULL
        for v = func_types->local_vars; v != NULL; v = v->next:
            self->n_local_vars++
        self->local_vars = malloc(self->n_local_vars * sizeof self->local_vars[0])
        i = 0
        for v = func_types->local_vars; v != NULL; v = v->next:
            self->local_vars[i++] = LocalVarNameAndPointer{
                name = v->name,
                pointer = LLVMBuildAlloca(self->builder, self->do_type(v->type), &v->name[0]),
            }

        # Place arguments into the first n local variables.
        for i = 0; i < func_types->signature.nargs; i++:
            LLVMBuildStore(self->builder, LLVMGetParam(llvm_func, i), self->local_vars[i].pointer)

        assert funcdef->body.nstatements > 0  # it is a definition
        self->do_body(&funcdef->body)

        if func_types->signature.return_type == NULL:
            LLVMBuildRetVoid(self->builder)
        else:
            LLVMBuildUnreachable(self->builder)

        free(self->local_vars)
        self->local_vars = NULL
        self->n_local_vars = 0
        self->current_function = NULL


def create_llvm_ir(ast: AstFile*, ft: FileTypes*) -> LLVMModule*:
    module = LLVMModuleCreateWithName(ast->path)
    LLVMSetTarget(module, &target.triple[0])
    LLVMSetDataLayout(module, &target.data_layout[0])

    a2i = AstToIR{
        module = module,
        builder = LLVMCreateBuilder(),
        file_types = ft
    }

    for i = 0; i < ast->body_len; i++:
        if ast->body[i].kind == AstToplevelStatementKind::Function and ast->body[i].function.body.nstatements > 0:
            a2i.define_function(&ast->body[i].function)

    LLVMDisposeBuilder(a2i.builder)
    return module
