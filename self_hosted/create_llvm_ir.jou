# This file turns type-checked AST into LLVM IR. It produces an LLVMModule for each Jou file.
import "./llvm.jou"
import "./typecheck.jou"
import "./types.jou"
import "./ast.jou"
import "./target.jou"
import "./evaluate.jou"
import "./errors_and_warnings.jou"
import "stdlib/io.jou"
import "stdlib/mem.jou"
import "stdlib/str.jou"


def build_signed_mod(builder: LLVMBuilder*, lhs: LLVMValue*, rhs: LLVMValue*) -> LLVMValue*:
    # Jou's % operator ensures that a%b has same sign as b:
    # jou_mod(a, b) = llvm_mod(llvm_mod(a, b) + b, b)
    llvm_mod = LLVMBuildSRem(builder, lhs, rhs, "smod_tmp")
    sum = LLVMBuildAdd(builder, llvm_mod, rhs, "smod_tmp")
    return LLVMBuildSRem(builder, sum, rhs, "smod")

def build_signed_div(builder: LLVMBuilder*, lhs: LLVMValue*, rhs: LLVMValue*) -> LLVMValue*:
    # LLVM's provides two divisions. One truncates, the other is an "exact div"
    # that requires there is no remainder. Jou uses floor division which is
    # neither of the two, but is quite easy to implement:
    #
    #    floordiv(a, b) = exact_div(a - jou_mod(a, b), b)
    top = LLVMBuildSub(builder, lhs, build_signed_mod(builder, lhs, rhs), "sdiv_tmp")
    return LLVMBuildExactSDiv(builder, top, rhs, "sdiv")


def lmax(a: long, b: long) -> long:
    if a > b:
        return a
    return b

# LLVM doesn't have a built-in union type, and you're supposed to abuse other types for that:
# https://mapping-high-level-constructs-to-llvm-ir.readthedocs.io/en/latest/basic-constructs/unions.html
#
# My first idea was to use an array of bytes that is big enough to fit anything.
# However, that might not be aligned properly.
#
# Then I tried choosing the member type that has the biggest align, and making a large enough array of it.
# Because the align is always a power of two, the memory will be suitably aligned for all member types.
# But it didn't work for some reason I still don't understand.
#
# Then I figured out how clang does it and did it the same way.
# We make a struct that contains:
#   - the most aligned type as chosen before
#   - array of i8 as padding to make it the right size.
# But for some reason that didn't work either.
#
# As a "last resort" I just use an array of i64 large enough and hope it's aligned as needed.
def create_llvm_union_type(types: LLVMType**, ntypes: int) -> LLVMType*:
    # TODO: in the other compiler I found it compiles faster without this. How about here?
    if ntypes == 1:
        return types[0]

    size_needed: long = 0
    for i = 0; i < ntypes; i++:
        # There are two functions to compute size and I don't know what the difference is.
        size1 = LLVMABISizeOfType(target.target_data, types[i])
        size2 = LLVMStoreSizeOfType(target.target_data, types[i])
        assert size1 == size2
        size_needed = lmax(size_needed, size1)

    return LLVMArrayType(LLVMInt64Type(), ((size_needed + 7) / 8) as int)  # ceil division


# Pointers in classes are stored as i8*, so that a struct can contain a pointer to itself.
def field_uses_i8_ptr_hack(field: ClassField*) -> bool:
    return field->type->kind == TypeKind::Pointer


def class_type_to_llvm(fields: ClassField*, nfields: int) -> LLVMType*:
    elem_types: LLVMType** = malloc(nfields * sizeof elem_types[0])
    for i = 0; i < nfields; i++:
        if field_uses_i8_ptr_hack(&fields[i]):
            elem_types[i] = LLVMPointerType(LLVMInt8Type(), 0)
        else:
            elem_types[i] = type_to_llvm(fields[i].type)

    # Combine together fields of the same union.
    combined_len = 0
    for start = 0; start < nfields; start = end:
        end = start + 1
        while end < nfields and fields[start].union_id == fields[end].union_id:
            end++
        assert fields[start].union_id == combined_len
        elem_types[combined_len++] = create_llvm_union_type(&elem_types[start], end-start)

    result = LLVMStructType(elem_types, combined_len, False as int)
    for i = 0; i < combined_len; i++:
        assert LLVMStructGetTypeAtIndex(result, i) == elem_types[i]
    free(elem_types)
    return result

def type_to_llvm(type: Type*) -> LLVMType*:
    if type == &bool_type:
        return LLVMInt1Type()
    if type == &float_type:
        return LLVMFloatType()
    if type == &double_type:
        return LLVMDoubleType()
    if type->is_integer_type():
        return LLVMIntType(type->size_in_bits)
    if type->kind == TypeKind::Pointer:
        return LLVMPointerType(type_to_llvm(type->value_type), 0)
    if type->kind == TypeKind::VoidPointer:
        return LLVMPointerType(LLVMInt8Type(), 0)
    if type->kind == TypeKind::Enum:
        return LLVMInt32Type()
    if type->kind == TypeKind::Class:
        return class_type_to_llvm(type->class_members.fields, type->class_members.nfields)
    if type->kind == TypeKind::Array:
        return LLVMArrayType(type_to_llvm(type->array.item_type), type->array.length)
    printf("asd-Asd., %s\n", &type->name)
    assert False


class LocalVarNameAndPointer:
    name: byte[100]
    pointer: LLVMValue*

class AstToIR:
    module: LLVMModule*
    builder: LLVMBuilder*
    file_types: FileTypes*  # Results of type-checking

    # Function/method specific fields
    function_or_method_types: FunctionOrMethodTypes*
    llvm_function: LLVMValue*
    local_vars: LocalVarNameAndPointer*
    n_local_vars: int

    break_stack: LLVMBasicBlock**
    continue_stack: LLVMBasicBlock**
    nested_loop_count: int  # number of items in break/continue stacks

    def get_local_var_pointer(self, name: byte*) -> LLVMValue*:
        for i = 0; i < self->n_local_vars; i++:
            if strcmp(self->local_vars[i].name, name) == 0:
                return self->local_vars[i].pointer
        return NULL

    def declare_function(self, sig: Signature*) -> LLVMValue*:
        full_name: byte[200]
        if sig->is_method():
            class_type = sig->get_containing_class()
            assert sizeof class_type->name + sizeof sig->name == sizeof full_name
            sprintf(full_name, "%s.%s", class_type->name, sig->name)
        else:
            strcpy(full_name, sig->name)

        # Make it so that this can be called many times without issue
        func = LLVMGetNamedFunction(self->module, full_name)
        if func != NULL:
            return func

        argtypes: LLVMType** = malloc(sig->nargs * sizeof argtypes[0])
        for i = 0; i < sig->nargs; i++:
            argtypes[i] = type_to_llvm(sig->argtypes[i])

        # TODO: tell llvm if we know a function is noreturn
        if sig->return_type == NULL:  # "-> noreturn" or "-> None"
            return_type = LLVMVoidType()
        else:
            return_type = type_to_llvm(sig->return_type)

        function_type = LLVMFunctionType(return_type, argtypes, sig->nargs, sig->takes_varargs as int)
        free(argtypes)

        return LLVMAddFunction(self->module, full_name, function_type)

    def new_block(self, name_hint: byte*) -> None:
        assert self->llvm_function != NULL
        block = LLVMAppendBasicBlock(self->llvm_function, name_hint)
        LLVMPositionBuilderAtEnd(self->builder, block)

    # If array_len is -1, returns a pointer to the start of a static global string.
    # Otherwise returns an array value.
    def make_a_string_constant(self, s: byte*, array_len: int) -> LLVMValue*:
        if array_len == -1:
            array = LLVMConstString(s, strlen(s) as int, False as int)
            global_var = LLVMAddGlobal(self->module, LLVMTypeOf(array), "string_literal")
            LLVMSetLinkage(global_var, LLVMLinkage::Private)  # This makes it a static global variable
            LLVMSetInitializer(global_var, array)
            string_type = LLVMPointerType(LLVMInt8Type(), 0)
            return LLVMBuildBitCast(self->builder, global_var, string_type, "string_ptr")
        else:
            assert strlen(s) < array_len
            padded = calloc(1, array_len)
            strcpy(padded, s)
            array = LLVMConstString(padded, array_len, True as int)
            free(padded)
            return array

    def do_cast(self, obj: LLVMValue*, from: Type*, to: Type*) -> LLVMValue*:
        # Treat enums as just integers
        if from->kind == TypeKind::Enum:
            from = int_type
        if to->kind == TypeKind::Enum:
            to = int_type

        if from == to:
            return obj

        if from->is_pointer_type() and to->is_pointer_type():
            return LLVMBuildBitCast(self->builder, obj, type_to_llvm(to), "cast_ptr")

        if from->is_integer_type() and to->is_integer_type():
            # Examples:
            #   signed 8-bit 0xFF (-1) --> 16-bit 0xFFFF (-1 or max value)
            #   unsigned 8-bit 0xFF (255) --> 16-bit 0x00FF (255)
            return LLVMBuildIntCast2(self->builder, obj, type_to_llvm(to), (from->kind == TypeKind::SignedInteger) as int, "cast_int")

        if from->kind == TypeKind::SignedInteger and to->kind == TypeKind::FloatingPoint:
            return LLVMBuildSIToFP(self->builder, obj, type_to_llvm(to), "cast_signed_to_float")
        if from->kind == TypeKind::UnsignedInteger and to->kind == TypeKind::FloatingPoint:
            return LLVMBuildUIToFP(self->builder, obj, type_to_llvm(to), "cast_unsigned_to_float")
        if from->kind == TypeKind::FloatingPoint and to->kind == TypeKind::SignedInteger:
            return LLVMBuildFPToSI(self->builder, obj, type_to_llvm(to), "cast_float_to_signed")
        if from->kind == TypeKind::FloatingPoint and to->kind == TypeKind::UnsignedInteger:
            return LLVMBuildFPToUI(self->builder, obj, type_to_llvm(to), "cast_float_to_unsigned")

        if from == &bool_type and to->is_integer_type():
            # True --> 1, False --> 0
            return LLVMBuildZExt(self->builder, obj, type_to_llvm(to), "cast_bool_to_int")

        if from->kind == TypeKind::FloatingPoint and to->kind == TypeKind::FloatingPoint:
            return LLVMBuildFPCast(self->builder, obj, type_to_llvm(to), "cast_float_double")

        printf("unimplemented cast: %s --> %s\n", from->name, to->name)
        assert False

    # Makes a temporary pointer, places the value there, then casts and reads the pointer.
    def do_cast_through_pointers(self, value: LLVMValue*, to: LLVMType*) -> LLVMValue*:
        printf("Cast through pointers!!!!!\n")
        fflush(stdout)

        p1 = LLVMBuildAlloca(self->builder, LLVMTypeOf(value), "cast_through_ptr_temp")
        LLVMBuildStore(self->builder, value, p1)
        p2 = LLVMBuildBitCast(self->builder, p1, LLVMPointerType(to, 0), "cast_through_ptr_temp")
        return LLVMBuildLoad2(self->builder, to, p2, "cast_through_ptr_result")

    def do_binop(
        self,
        op: AstExpressionKind,
        lhs: LLVMValue*,
        lhs_type: Type*,
        rhs: LLVMValue*,
        rhs_type: Type*,
    ) -> LLVMValue*:
        if lhs_type->kind == TypeKind::Enum:
            lhs_type = int_type
        if rhs_type->kind == TypeKind::Enum:
            rhs_type = int_type

        got_numbers = lhs_type->is_number_type() and rhs_type->is_number_type()
        got_pointers = lhs_type->is_pointer_type() and rhs_type->is_pointer_type()
        assert got_numbers or got_pointers

        if lhs_type->kind == TypeKind::FloatingPoint and rhs_type->kind == TypeKind::FloatingPoint:
            if op == AstExpressionKind::Add:
                return LLVMBuildFAdd(self->builder, lhs, rhs, "add")
            if op == AstExpressionKind::Subtract:
                return LLVMBuildFSub(self->builder, lhs, rhs, "sub")
            if op == AstExpressionKind::Multiply:
                return LLVMBuildFMul(self->builder, lhs, rhs, "mul")
            if op == AstExpressionKind::Divide:
                return LLVMBuildFDiv(self->builder, lhs, rhs, "div")
            if op == AstExpressionKind::Modulo:
                return LLVMBuildFRem(self->builder, lhs, rhs, "mod")
            if op == AstExpressionKind::Eq:
                return LLVMBuildFCmp(self->builder, LLVMRealPredicate::OEQ, lhs, rhs, "eq")
            if op == AstExpressionKind::Ne:
                return LLVMBuildFCmp(self->builder, LLVMRealPredicate::ONE, lhs, rhs, "ne")
            if op == AstExpressionKind::Gt:
                return LLVMBuildFCmp(self->builder, LLVMRealPredicate::OGT, lhs, rhs, "gt")
            if op == AstExpressionKind::Ge:
                return LLVMBuildFCmp(self->builder, LLVMRealPredicate::OGE, lhs, rhs, "ge")
            if op == AstExpressionKind::Lt:
                return LLVMBuildFCmp(self->builder, LLVMRealPredicate::OLT, lhs, rhs, "lt")
            if op == AstExpressionKind::Le:
                return LLVMBuildFCmp(self->builder, LLVMRealPredicate::OLE, lhs, rhs, "le")
            assert False

        if lhs_type->is_integer_type() and rhs_type->is_integer_type():
            is_signed = lhs_type->kind == TypeKind::SignedInteger and rhs_type->kind == TypeKind::SignedInteger
            if op == AstExpressionKind::Add:
                return LLVMBuildAdd(self->builder, lhs, rhs, "add")
            if op == AstExpressionKind::Subtract:
                return LLVMBuildSub(self->builder, lhs, rhs, "sub")
            if op == AstExpressionKind::Multiply:
                return LLVMBuildMul(self->builder, lhs, rhs, "mul")
            if op == AstExpressionKind::Divide:
                if is_signed:
                    return build_signed_div(self->builder, lhs, rhs)
                else:
                    return LLVMBuildUDiv(self->builder, lhs, rhs, "div")
            if op == AstExpressionKind::Modulo:
                if is_signed:
                    return build_signed_mod(self->builder, lhs, rhs)
                else:
                    return LLVMBuildURem(self->builder, lhs, rhs, "mod")
            if op == AstExpressionKind::Eq:
                return LLVMBuildICmp(self->builder, LLVMIntPredicate::EQ, lhs, rhs, "eq")
            if op == AstExpressionKind::Ne:
                return LLVMBuildICmp(self->builder, LLVMIntPredicate::NE, lhs, rhs, "ne")
            if op == AstExpressionKind::Gt:
                if is_signed:
                    return LLVMBuildICmp(self->builder, LLVMIntPredicate::SGT, lhs, rhs, "gt")
                else:
                    return LLVMBuildICmp(self->builder, LLVMIntPredicate::UGT, lhs, rhs, "gt")
            if op == AstExpressionKind::Ge:
                if is_signed:
                    return LLVMBuildICmp(self->builder, LLVMIntPredicate::SGE, lhs, rhs, "ge")
                else:
                    return LLVMBuildICmp(self->builder, LLVMIntPredicate::UGE, lhs, rhs, "ge")
            if op == AstExpressionKind::Lt:
                if is_signed:
                    return LLVMBuildICmp(self->builder, LLVMIntPredicate::SLT, lhs, rhs, "lt")
                else:
                    return LLVMBuildICmp(self->builder, LLVMIntPredicate::ULT, lhs, rhs, "lt")
            if op == AstExpressionKind::Le:
                if is_signed:
                    return LLVMBuildICmp(self->builder, LLVMIntPredicate::SLE, lhs, rhs, "le")
                else:
                    return LLVMBuildICmp(self->builder, LLVMIntPredicate::ULE, lhs, rhs, "le")
            assert False

        if lhs_type->is_pointer_type() and rhs_type->is_pointer_type():
            lhs_int = LLVMBuildPtrToInt(self->builder, lhs, LLVMInt64Type(), "ptreq_lhs")
            rhs_int = LLVMBuildPtrToInt(self->builder, rhs, LLVMInt64Type(), "ptreq_rhs")
            if op == AstExpressionKind::Eq:
                return LLVMBuildICmp(self->builder, LLVMIntPredicate::EQ, lhs_int, rhs_int, "ptreq")
            if op == AstExpressionKind::Ne:
                return LLVMBuildICmp(self->builder, LLVMIntPredicate::NE, lhs_int, rhs_int, "ptreq")
            assert False

        printf("%s %d %s\n", lhs_type->name, op, rhs_type->name)
        assert False

    def do_assert(self, location: Location, condition: LLVMValue*, condition_str: byte*) -> None:
        true_block = LLVMAppendBasicBlock(self->llvm_function, "assert_true")
        false_block = LLVMAppendBasicBlock(self->llvm_function, "assert_false")
        LLVMBuildCondBr(self->builder, condition, true_block, false_block)

        LLVMPositionBuilderAtEnd(self->builder, false_block)

        argtypes = [LLVMPointerType(LLVMInt8Type(), 0), LLVMPointerType(LLVMInt8Type(), 0), LLVMInt32Type()]
        assert_fail_func_type = LLVMFunctionType(LLVMVoidType(), argtypes, 3, False as int)
        assert_fail_func = LLVMGetNamedFunction(self->module, "_jou_assert_fail")
        if assert_fail_func == NULL:
            assert_fail_func = LLVMAddFunction(self->module, "_jou_assert_fail", assert_fail_func_type)
        assert assert_fail_func != NULL

        args = [
            self->make_a_string_constant(condition_str, -1),
            self->make_a_string_constant(location.path, -1),
            LLVMConstInt(LLVMInt32Type(), location.lineno, False as int),
        ]

        LLVMBuildCall2(self->builder, assert_fail_func_type, assert_fail_func, args, 3, "")
        LLVMBuildUnreachable(self->builder)
        LLVMPositionBuilderAtEnd(self->builder, true_block)

    def do_incr_decr(self, value_expression: AstExpression*, diff: int) -> LLVMValue*[2]:
        assert diff == 1 or diff == -1
        value_type = self->function_or_method_types->get_expression_types(value_expression)->original_type
        pointer = self->do_address_of_expression(value_expression)

        old_value = LLVMBuildLoad(self->builder, pointer, "old_value")
        if value_type->is_integer_type():
            diff_object = LLVMConstInt(type_to_llvm(value_type), diff, True as int)
            new_value = LLVMBuildAdd(self->builder, old_value, diff_object, "new_value")
        else:
            assert value_type->is_pointer_type()
            diff_object = LLVMConstInt(LLVMInt64Type(), diff, True as int)
            new_value = LLVMBuildGEP(self->builder, old_value, &diff_object, 1, "new_value")

        LLVMBuildStore(self->builder, new_value, pointer)
        return [old_value, new_value]

    def do_address_of_expression(self, ast: AstExpression*) -> LLVMValue*:
        if ast->kind == AstExpressionKind::GetVariable:
            local_var = self->get_local_var_pointer(ast->varname)
            if local_var != NULL:
                return local_var

            global_var = LLVMGetNamedGlobal(self->module, ast->varname)
            assert global_var != NULL
            return global_var

        if ast->kind == AstExpressionKind::GetClassField:
            lhs_type = self->function_or_method_types->get_expression_types(ast->class_field.instance)->original_type

            if ast->class_field.uses_arrow_operator:
                # &foo->bar = foo + some offset
                instance_pointer = self->do_expression(ast->class_field.instance)
                assert lhs_type->kind == TypeKind::Pointer
                class_type = lhs_type->value_type
            else:
                # &foo.bar = &foo + some offset
                instance_pointer = self->do_address_of_expression(ast->class_field.instance)
                class_type = lhs_type

            field = class_type->class_members.find_field(ast->class_field.field_name)
            assert field != NULL
            field_pointer = LLVMBuildStructGEP2(
                self->builder,
                type_to_llvm(class_type),
                instance_pointer,
                field->union_id,
                field->name,
            )

            if field_uses_i8_ptr_hack(field) or field->belongs_to_union:
                field_pointer = LLVMBuildBitCast(
                    self->builder,
                    field_pointer,
                    LLVMPointerType(type_to_llvm(field->type), 0),
                    "class_field_ptr_cast",
                )

            return field_pointer

        if ast->kind == AstExpressionKind::Indexing:
            # &pointer[index] = pointer + some offset
            pointer = self->do_expression(&ast->operands[0])
            index = self->do_expression(&ast->operands[1])
            return LLVMBuildGEP(self->builder, pointer, &index, 1, "indexing_ptr")

        if ast->kind == AstExpressionKind::Dereference:
            return self->do_expression(&ast->operands[0])

        ast->print()
        printf("expression kind (taking address): %d\n", ast->kind)
        assert False

    def do_and_or(self, lhs: AstExpression*, rhs: AstExpression*, is_and: bool) -> LLVMValue*:
        # Must be careful with side effects. For example, "lhs and rhs" doesn't evaluate rhs if the lhs is False.
        # TODO: do we need lhs_start_block?
        lhs_start_block = LLVMAppendBasicBlock(self->llvm_function, "andor_lhs")
        rhs_start_block = LLVMAppendBasicBlock(self->llvm_function, "andor_rhs")
        done_block = LLVMAppendBasicBlock(self->llvm_function, "andor_done")
        LLVMBuildBr(self->builder, lhs_start_block)

        LLVMPositionBuilderAtEnd(self->builder, lhs_start_block)
        lhs_value = self->do_expression(lhs)
        lhs_end_block = LLVMGetInsertBlock(self->builder)
        if is_and:
            LLVMBuildCondBr(self->builder, lhs_value, rhs_start_block, done_block)
        else:
            LLVMBuildCondBr(self->builder, lhs_value, done_block, rhs_start_block)

        LLVMPositionBuilderAtEnd(self->builder, rhs_start_block)
        rhs_value = self->do_expression(rhs)
        rhs_end_block = LLVMGetInsertBlock(self->builder)
        LLVMBuildBr(self->builder, done_block)

        LLVMPositionBuilderAtEnd(self->builder, done_block)
        phi = LLVMBuildPhi(self->builder, LLVMInt1Type(), "and")
        LLVMAddIncoming(phi, &lhs_value, &lhs_end_block, 1)
        LLVMAddIncoming(phi, &rhs_value, &rhs_end_block, 1)
        return phi

    def do_call(self, call: AstCall*) -> LLVMValue*:
        if call->method_call_self != NULL:
            self_type = (
                self
                ->function_or_method_types
                ->get_expression_types(call->method_call_self)
                ->get_type_after_implicit_cast()
            )
            if call->uses_arrow_operator:
                assert self_type->kind == TypeKind::Pointer
                self_type = self_type->value_type
            assert self_type->kind == TypeKind::Class
            signature = self_type->class_members.find_method(call->name)

            if call->uses_arrow_operator:
                self_pointer = self->do_expression(call->method_call_self)
            else:
                self_pointer = self->do_address_of_expression(call->method_call_self)
        else:
            signature = self->file_types->find_function(call->name)
            self_pointer = NULL

        assert signature != NULL

        function = self->declare_function(signature)
        assert LLVMGetTypeKind(LLVMTypeOf(function)) == LLVMTypeKind::Pointer
        function_type = LLVMGetElementType(LLVMTypeOf(function))
        assert LLVMGetTypeKind(function_type) == LLVMTypeKind::Function

        args: LLVMValue** = malloc(sizeof args[0] * (call->nargs + 1))
        k = 0
        if self_pointer != NULL:
            args[k++] = self_pointer
        for i = 0; i < call->nargs; i++:
            args[k++] = self->do_expression(&call->args[i])

        name_hint: byte[100] = ""
        if signature->return_type != NULL:
            sprintf(name_hint, "%.20s_return_value", signature->name)

        result = LLVMBuildCall2(self->builder, function_type, function, args, k, name_hint)
        free(args)
        if signature->return_type == NULL:
            return NULL
        return result

    def do_expression(self, ast: AstExpression*) -> LLVMValue*:
        types = self->function_or_method_types->get_expression_types(ast)
        if types != NULL and types->implicit_array_to_pointer_cast:
            pointer_to_array = self->do_address_of_expression(ast)
            return LLVMBuildBitCast(
                self->builder,
                pointer_to_array,
                type_to_llvm(types->implicit_cast_type),
                "array_to_ptr_cast",
            )

        if ast->kind == AstExpressionKind::String:
            if types->implicit_string_to_array_cast:
                array_len = types->implicit_cast_type->array.length
            else:
                array_len = -1
            result = self->make_a_string_constant(ast->string, array_len)
        elif ast->kind == AstExpressionKind::Bool:
            result = LLVMConstInt(LLVMInt1Type(), ast->bool_value as long, False as int)
        elif ast->kind == AstExpressionKind::Byte:
            result = LLVMConstInt(LLVMInt8Type(), ast->byte_value, False as int)
        elif ast->kind == AstExpressionKind::Short:
            result = LLVMConstInt(LLVMInt16Type(), ast->short_value, False as int)
        elif ast->kind == AstExpressionKind::Int:
            result = LLVMConstInt(LLVMInt32Type(), ast->int_value, False as int)
        elif ast->kind == AstExpressionKind::Long:
            result = LLVMConstInt(LLVMInt64Type(), ast->long_value, False as int)
        elif ast->kind == AstExpressionKind::Null:
            result = LLVMConstNull(type_to_llvm(types->original_type))

        elif ast->kind == AstExpressionKind::Call:
            result = self->do_call(&ast->call)
            if result == NULL:
                return NULL

        elif ast->kind == AstExpressionKind::GetEnumMember:
            enum_type = self->file_types->find_type(ast->enum_member.enum_name)
            assert enum_type != NULL
            i = enum_type->enum_members.find_index(ast->enum_member.member_name)
            assert i != -1
            result = LLVMConstInt(LLVMInt32Type(), i, False as int)

        elif ast->kind == AstExpressionKind::As:
            value = self->do_expression(&ast->as_expression->value)
            type_before_cast = self->function_or_method_types->get_expression_types(&ast->as_expression->value)->get_type_after_implicit_cast()
            type_after_cast = self->function_or_method_types->get_expression_types(ast)->original_type
            result = self->do_cast(value, type_before_cast, type_after_cast)

        elif ast->kind == AstExpressionKind::Negate:
            value = self->do_expression(&ast->operands[0])
            if self->function_or_method_types->get_expression_types(&ast->operands[0])->original_type->kind == TypeKind::FloatingPoint:
                result = LLVMBuildFNeg(self->builder, value, "negate")
            else:
                result = LLVMBuildNeg(self->builder, value, "negate")

        elif ast->kind == AstExpressionKind::PreIncr:
            old_and_new = self->do_incr_decr(&ast->operands[0], 1)
            result = old_and_new[1]
        elif ast->kind == AstExpressionKind::PostIncr:
            old_and_new = self->do_incr_decr(&ast->operands[0], 1)
            result = old_and_new[0]
        elif ast->kind == AstExpressionKind::PreDecr:
            old_and_new = self->do_incr_decr(&ast->operands[0], -1)
            result = old_and_new[1]
        elif ast->kind == AstExpressionKind::PostDecr:
            old_and_new = self->do_incr_decr(&ast->operands[0], -1)
            result = old_and_new[0]

        elif ast->kind == AstExpressionKind::Instantiate:
            instance_type = self->function_or_method_types->get_expression_types(ast)->original_type
            assert instance_type->kind == TypeKind::Class

            result = LLVMConstNull(type_to_llvm(instance_type))

            for i = 0; i < ast->instantiation.nfields; i++:
                field = instance_type->class_members.find_field(ast->instantiation.field_names[i])
                assert field != NULL
                value = self->do_expression(&ast->instantiation.field_values[i])
                printf("create_llvm_ir: (type=%s) get belongs_to_union = ", instance_type->name)
                if field->belongs_to_union:
                    printf("True")
                else:
                    printf("False")
                printf(" for field '%s'\n", field->name)
                fflush(stdout)
                if field_uses_i8_ptr_hack(field) or field->belongs_to_union:
                    printf("IF STATEMENT\n")
                    fflush(stdout)
                    value = self->do_cast_through_pointers(value, LLVMStructGetTypeAtIndex(type_to_llvm(instance_type), field->union_id))
                    assert LLVMTypeOf(value) == LLVMStructGetTypeAtIndex(type_to_llvm(instance_type), field->union_id)
                else:
                    printf("ELSE STATEMENT\n")
                    fflush(stdout)
                result = LLVMBuildInsertValue(self->builder, result, value, field->union_id, "instance")

        elif ast->kind == AstExpressionKind::GetClassField:
            instance = self->do_expression(ast->class_field.instance)
            instance_type = self->function_or_method_types->get_expression_types(ast->class_field.instance)->original_type

            if ast->class_field.uses_arrow_operator:
                instance = LLVMBuildLoad(self->builder, instance, "instance")
                assert instance_type->kind == TypeKind::Pointer
                instance_type = instance_type->value_type

            assert instance_type->kind == TypeKind::Class
            field = instance_type->class_members.find_field(ast->class_field.field_name)
            assert field != NULL
            result = LLVMBuildExtractValue(self->builder, instance, field->union_id, field->name)

            if field_uses_i8_ptr_hack(field) or field->belongs_to_union:
                result = self->do_cast_through_pointers(result, type_to_llvm(field->type))

        elif ast->kind == AstExpressionKind::GetVariable:
            v = get_special_constant(ast->varname)
            if v == -1:
                # normal variable
                pointer = self->do_address_of_expression(ast)
                result = LLVMBuildLoad(self->builder, pointer, ast->varname)
            else:
                result = LLVMConstInt(LLVMInt1Type(), v, False as int)

        elif ast->kind == AstExpressionKind::Indexing:
            pointer = self->do_address_of_expression(ast)
            result = LLVMBuildLoad(self->builder, pointer, ast->varname)

        elif ast->kind == AstExpressionKind::AddressOf:
            result = self->do_address_of_expression(&ast->operands[0])

        elif (
            ast->kind == AstExpressionKind::Add
            or ast->kind == AstExpressionKind::Subtract
            or ast->kind == AstExpressionKind::Multiply
            or ast->kind == AstExpressionKind::Divide
            or ast->kind == AstExpressionKind::Modulo
            or ast->kind == AstExpressionKind::Eq
            or ast->kind == AstExpressionKind::Ne
            or ast->kind == AstExpressionKind::Gt
            or ast->kind == AstExpressionKind::Ge
            or ast->kind == AstExpressionKind::Lt
            or ast->kind == AstExpressionKind::Le
        ):
            lhs = self->do_expression(&ast->operands[0])
            rhs = self->do_expression(&ast->operands[1])
            lhs_type = self->function_or_method_types->get_expression_types(&ast->operands[0])->get_type_after_implicit_cast()
            rhs_type = self->function_or_method_types->get_expression_types(&ast->operands[1])->get_type_after_implicit_cast()
            result = self->do_binop(ast->kind, lhs, lhs_type, rhs, rhs_type)

        elif ast->kind == AstExpressionKind::Array:
            assert types->original_type->kind == TypeKind::Array
            result = LLVMConstNull(type_to_llvm(types->original_type))
            for i = 0; i < types->original_type->array.length; i++:
                item = self->do_expression(&ast->array.items[i])
                result = LLVMBuildInsertValue(self->builder, result, item, i, "array")

        elif ast->kind == AstExpressionKind::Float or ast->kind == AstExpressionKind::Double:
            result = LLVMConstRealOfString(type_to_llvm(types->original_type), ast->float_or_double_text)

        elif ast->kind == AstExpressionKind::Self:
            self_ptr = self->get_local_var_pointer("self")
            assert self_ptr != NULL
            result = LLVMBuildLoad(self->builder, self_ptr, "self")

        elif ast->kind == AstExpressionKind::And:
            result = self->do_and_or(&ast->operands[0], &ast->operands[1], True)
        elif ast->kind == AstExpressionKind::Or:
            result = self->do_and_or(&ast->operands[0], &ast->operands[1], False)
        elif ast->kind == AstExpressionKind::Not:
            # compile "not x" as "x == False"
            value = self->do_expression(&ast->operands[0])
            false = LLVMConstInt(LLVMInt1Type(), 0, False as int)
            result = LLVMBuildICmp(self->builder, LLVMIntPredicate::EQ, value, false, "not")

        elif ast->kind == AstExpressionKind::Dereference:
            result = LLVMBuildLoad(self->builder, self->do_expression(&ast->operands[0]), "ptr_deref")

        elif ast->kind == AstExpressionKind::SizeOf:
            types = self->function_or_method_types->get_expression_types(&ast->operands[0])
            assert types != NULL
            result = LLVMSizeOf(type_to_llvm(types->get_type_after_implicit_cast()))

        else:
            ast->print()
            printf("create_llvm_ir: unknown expression kind %d...\n", ast->kind)
            assert False

        types = self->function_or_method_types->get_expression_types(ast)
        if types->implicit_cast_type == NULL or types->implicit_string_to_array_cast:
            return result
        return self->do_cast(result, types->original_type, types->implicit_cast_type)

    def do_if_statement(self, ast: AstIfStatement*) -> None:
        assert ast->n_if_and_elifs >= 1
        done = LLVMAppendBasicBlock(self->llvm_function, "if_done")

        for i = 0; i < ast->n_if_and_elifs; i++:
            condition = self->do_expression(&ast->if_and_elifs[i].condition)
            then = LLVMAppendBasicBlock(self->llvm_function, "then")
            otherwise = LLVMAppendBasicBlock(self->llvm_function, "otherwise")
            LLVMBuildCondBr(self->builder, condition, then, otherwise)

            LLVMPositionBuilderAtEnd(self->builder, then)
            self->do_body(&ast->if_and_elifs[i].body)
            LLVMBuildBr(self->builder, done)
            LLVMPositionBuilderAtEnd(self->builder, otherwise)

        self->do_body(&ast->else_body)
        LLVMBuildBr(self->builder, done)
        LLVMPositionBuilderAtEnd(self->builder, done)

    # for init; cond; incr:
    #     ...body...
    #
    # While loop is basically a special case of for loop, so it uses this too.
    def do_loop(self, init: AstStatement*, cond: AstExpression*, incr: AstStatement*, body: AstBody*) -> None:
        cond_block = LLVMAppendBasicBlock(self->llvm_function, "loop_cond")
        body_block = LLVMAppendBasicBlock(self->llvm_function, "loop_body")
        incr_block = LLVMAppendBasicBlock(self->llvm_function, "loop_incr")
        done_block = LLVMAppendBasicBlock(self->llvm_function, "loop_done")

        if init != NULL:
            self->do_statement(init)
        LLVMBuildBr(self->builder, cond_block)

        # cond_block: evaluate condition, jump to body or skip to done
        LLVMPositionBuilderAtEnd(self->builder, cond_block)
        condition = self->do_expression(cond)
        LLVMBuildCondBr(self->builder, condition, body_block, done_block)

        # body_block: 'break' skips to after loop, 'continue' goes to incr (also goes to incr at end)
        LLVMPositionBuilderAtEnd(self->builder, body_block)
        self->break_stack = realloc(self->break_stack, (self->nested_loop_count + 1) * sizeof self->break_stack[0])
        self->break_stack[self->nested_loop_count] = done_block
        self->continue_stack = realloc(self->continue_stack, (self->nested_loop_count + 1) * sizeof self->continue_stack[0])
        self->continue_stack[self->nested_loop_count] = incr_block

        self->nested_loop_count++
        self->do_body(body)
        self->nested_loop_count--
        LLVMBuildBr(self->builder, incr_block)

        # incr_block: run incr and go back to start
        LLVMPositionBuilderAtEnd(self->builder, incr_block)
        if incr != NULL:
            self->do_statement(incr)
        LLVMBuildBr(self->builder, cond_block)

        # rest of the function/method goes to done block
        LLVMPositionBuilderAtEnd(self->builder, done_block)

    def do_in_place_operation(self, op: AstExpressionKind, assignment: AstAssignment*) -> None:
        target_pointer = self->do_address_of_expression(&assignment->target)
        target_type = self->function_or_method_types->get_expression_types(&assignment->target)->original_type
        rhs = self->do_expression(&assignment->value)
        rhs_type = self->function_or_method_types->get_expression_types(&assignment->value)->get_type_after_implicit_cast()

        old_value = LLVMBuildLoad(self->builder, target_pointer, "old_value")
        new_value = self->do_binop(op, old_value, target_type, rhs, rhs_type)
        LLVMBuildStore(self->builder, new_value, target_pointer)

    def do_statement(self, ast: AstStatement*) -> None:
        if ast->kind == AstStatementKind::ExpressionStatement:
            self->do_expression(&ast->expression)
        elif ast->kind == AstStatementKind::Return:
            if ast->return_value != NULL:
                return_value = self->do_expression(ast->return_value)
                LLVMBuildRet(self->builder, return_value)
            else:
                LLVMBuildRetVoid(self->builder)
            # If more code follows, place it into a new block that never actually runs
            self->new_block("after_return")
        elif ast->kind == AstStatementKind::Assert:
            self->do_assert(ast->location, self->do_expression(&ast->assertion.condition), ast->assertion.condition_str)
        elif ast->kind == AstStatementKind::Pass:
            pass
        elif ast->kind == AstStatementKind::Assign:
            target_pointer = self->do_address_of_expression(&ast->assignment.target)
            value = self->do_expression(&ast->assignment.value)
            LLVMBuildStore(self->builder, value, target_pointer)
        elif ast->kind == AstStatementKind::DeclareLocalVar:
            if ast->var_declaration.value != NULL:
                target_pointer = self->get_local_var_pointer(ast->var_declaration.name)
                assert target_pointer != NULL
                value = self->do_expression(ast->var_declaration.value)
                LLVMBuildStore(self->builder, value, target_pointer)
        elif ast->kind == AstStatementKind::If:
            self->do_if_statement(&ast->if_statement)
        elif ast->kind == AstStatementKind::WhileLoop:
            self->do_loop(NULL, &ast->while_loop.condition, NULL, &ast->while_loop.body)
        elif ast->kind == AstStatementKind::ForLoop:
            self->do_loop(ast->for_loop.init, &ast->for_loop.cond, ast->for_loop.incr, &ast->for_loop.body)
        elif ast->kind == AstStatementKind::Break:
            LLVMBuildBr(self->builder, self->break_stack[self->nested_loop_count-1])
            self->new_block("after_break")  # don't fail to compile, if there is code after break/continue
        elif ast->kind == AstStatementKind::Continue:
            LLVMBuildBr(self->builder, self->continue_stack[self->nested_loop_count-1])
            self->new_block("after_continue")
        elif ast->kind == AstStatementKind::InPlaceAdd:
            self->do_in_place_operation(AstExpressionKind::Add, &ast->assignment)
        elif ast->kind == AstStatementKind::InPlaceSubtract:
            self->do_in_place_operation(AstExpressionKind::Subtract, &ast->assignment)
        elif ast->kind == AstStatementKind::InPlaceMultiply:
            self->do_in_place_operation(AstExpressionKind::Multiply, &ast->assignment)
        elif ast->kind == AstStatementKind::InPlaceDivide:
            self->do_in_place_operation(AstExpressionKind::Divide, &ast->assignment)
        elif ast->kind == AstStatementKind::InPlaceModulo:
            self->do_in_place_operation(AstExpressionKind::Modulo, &ast->assignment)
        else:
            printf("create_llvm_ir: unknown statement kind %d...\n", ast->kind)
            assert False

    def do_body(self, body: AstBody*) -> None:
        for i = 0; i < body->nstatements; i++:
            self->do_statement(&body->statements[i])

    def call_the_special_startup_function(self) -> None:
        if WINDOWS:
            name = "_jou_windows_startup"
        elif MACOS:
            name = "_jou_macos_startup"
        else:
            return

        functype = LLVMFunctionType(LLVMVoidType(), NULL, 0, False as int)
        func = LLVMAddFunction(self->module, name, functype)
        LLVMBuildCall2(self->builder, functype, func, NULL, 0, "")

    def define_function_or_method(self, funcdef: AstFunctionOrMethod*, self_type: Type*) -> None:
        assert self->function_or_method_types == NULL
        self->function_or_method_types = self->file_types->find_defined_function_or_method(funcdef->signature.name, self_type)
        assert self->function_or_method_types != NULL

        assert self->llvm_function == NULL
        sig = &self->function_or_method_types->signature
        self->llvm_function = self->declare_function(sig)
        self->new_block("start")

        if (WINDOWS or MACOS) and strcmp(sig->name, "main") == 0 and not sig->is_method():
            self->call_the_special_startup_function()

        # Allocate all local variables at the start of the function.
        assert self->n_local_vars == 0
        assert self->local_vars == NULL
        for v = self->function_or_method_types->local_vars; v != NULL; v = v->next:
            self->n_local_vars++
        self->local_vars = malloc(self->n_local_vars * sizeof self->local_vars[0])
        i = 0
        for v = self->function_or_method_types->local_vars; v != NULL; v = v->next:
            self->local_vars[i++] = LocalVarNameAndPointer{
                name = v->name,
                pointer = LLVMBuildAlloca(self->builder, type_to_llvm(v->type), v->name),
            }

        # Place arguments into the first n local variables.
        for i = 0; i < sig->nargs; i++:
            LLVMBuildStore(self->builder, LLVMGetParam(self->llvm_function, i), self->local_vars[i].pointer)

        assert funcdef->body.nstatements > 0  # it is a definition
        self->do_body(&funcdef->body)

        if sig->return_type == NULL:
            LLVMBuildRetVoid(self->builder)
        else:
            LLVMBuildUnreachable(self->builder)

        free(self->local_vars)
        self->local_vars = NULL
        self->n_local_vars = 0
        self->llvm_function = NULL
        self->function_or_method_types = NULL


# This distinguishes defined global variables from:
#   - imported global variables
#   - declared global variables
def file_defines_global_var(ast: AstFile*, name: byte*) -> bool:
    for s = ast->body.statements; s < &ast->body.statements[ast->body.nstatements]; s++:
        if s->kind == AstStatementKind::GlobalVariableDefinition and strcmp(s->var_declaration.name, name) == 0:
            return True
    return False


def create_llvm_ir(ast: AstFile*, ft: FileTypes*) -> LLVMModule*:
    module = LLVMModuleCreateWithName(ast->path)
    LLVMSetTarget(module, target.triple)
    LLVMSetDataLayout(module, target.data_layout)

    for v = ft->globals; v < &ft->globals[ft->nglobals]; v++:
        t = type_to_llvm(v->type)
        globalptr = LLVMAddGlobal(module, t, v->name)
        if file_defines_global_var(ast, v->name):
            LLVMSetInitializer(globalptr, LLVMConstNull(t))

    a2i = AstToIR{
        module = module,
        builder = LLVMCreateBuilder(),
        file_types = ft
    }

    for s = ast->body.statements; s < &ast->body.statements[ast->body.nstatements]; s++:
        if s->kind == AstStatementKind::Function and s->function.body.nstatements > 0:
            a2i.define_function_or_method(&s->function, NULL)
        elif s->kind == AstStatementKind::Class:
            classdef = &s->classdef
            class_type = ft->find_type(classdef->name)
            assert class_type != NULL
            for k = 0; k < classdef->nmembers; k++:
                if classdef->members[k].kind == AstClassMemberKind::Method:
                    a2i.define_function_or_method(&classdef->members[k].method, class_type)
        else:
            # TODO: need to handle some others?
            pass

    LLVMDisposeBuilder(a2i.builder)
    return module
