import "stdlib/io.jou"
import "stdlib/mem.jou"

import "./llvm.jou"
import "./structs.jou"
import "./types.jou"


def print_string(s: byte*, len: int) -> None:
    putchar('"')
    for i = 0; i < len or (len == -1 and s[i] != '\0'); i++:
        if 32 <= s[i] and s[i] <= 126:
            # printable ascii character
            putchar(s[i])
        elif s[i] == '\n':
            printf("\\n")
        else:
            printf("\\x%02x", s[i])     # TODO: \x is not yet recognized by the tokenizer
    putchar('"')


def print_constant(c: Constant*) -> None:
    if c->kind == ConstantKind::EnumMember:
        printf("enum member %d of %s", c->enum_member.memberidx, c->enum_member.enumtype->name)
    elif c->kind == ConstantKind::Bool:
        if c->boolean:
            printf("True")
        else:
            printf("False")
    elif c->kind == ConstantKind::Float:
        printf("float %s", c->double_or_float_text)
    elif c->kind == ConstantKind::Double:
        printf("double %s", c->double_or_float_text)
    elif c->kind == ConstantKind::Integer:
        if c->integer.is_signed:
            signed_or_unsigned = "signed"
        else:
            signed_or_unsigned = "unsigned"
        printf(
            "%lld (%d-bit %s)",
            c->integer.value,
            c->integer.size_in_bits,
            signed_or_unsigned,
        )
    elif c->kind == ConstantKind::Null:
        printf("NULL")
    elif c->kind == ConstantKind::String:
        print_string(c->str, -1)
    else:
        assert False


def varname_for_printing(var: LocalVariable*) -> byte*:
    if var->name[0] != '\0':
        # it is named, not a dummy
        return var->name

    # TODO: port this properly if needed
#    // Cycle through enough space for a few variables, so that you
#    // can call this several times inside the same printf()
#    static char names[50 + sizeof var->name][5];
#    static unsigned i = 0;
#    char *s = names[i++];
#    i %= sizeof(names) / sizeof(names[0]);
#
#    sprintf(s, "$%d", var->id);
#    return s;
    return "<temporary var>"


def very_short_number_type_description(t: Type*) -> byte*:
    if t->kind == TypeKind::FloatingPoint:
        return "floating"
    if t->kind == TypeKind::SignedInteger:
        return "signed"
    if t->kind == TypeKind::UnsignedInteger:
        return "unsigned"
    assert False


def print_cf_instruction(ins: CfInstruction*) -> None:
    printf("    line %-4d  ", ins->location.lineno)

    if ins->destvar != NULL:
        printf("%s = ", varname_for_printing(ins->destvar))

    if ins->kind == CfInstructionKind::AddressOfLocalVar:
        printf("address of %s (local variable)", varname_for_printing(ins->operands[0]))
    elif ins->kind == CfInstructionKind::AddressOfGlobalVar:
        printf("address of %s (global variable)", ins->globalname)
    elif ins->kind == CfInstructionKind::SizeOf:
        printf("sizeof %s", ins->type->name)
    elif ins->kind == CfInstructionKind::BoolNegate:
        printf("boolean negation of %s", varname_for_printing(ins->operands[0]))
    elif ins->kind == CfInstructionKind::Call:
        if get_self_class(&ins->signature) != NULL:
            printf("call method %s.", get_self_class(&ins->signature)->name)
        else:
            printf("call function ")
        printf("%s(", ins->signature.name)
        for i = 0; i < ins->noperands; i++:
            if i != 0:
                printf(", ")
            printf("%s", varname_for_printing(ins->operands[i]))
        printf(")")
    elif ins->kind == CfInstructionKind::NumCast:
        printf(
            "number cast %s (%d-bit %s --> %d-bit %s)",
            varname_for_printing(ins->operands[0]),
            ins->operands[0]->type->size_in_bits,
            very_short_number_type_description(ins->operands[0]->type),
            ins->destvar->type->size_in_bits,
            very_short_number_type_description(ins->destvar->type))
    elif ins->kind == CfInstructionKind::EnumToInt32:
        printf("cast %s from enum to 32-bit signed int", varname_for_printing(ins->operands[0]))
    elif ins->kind == CfInstructionKind::Int32ToEnum:
        printf("cast %s from 32-bit signed int to enum", varname_for_printing(ins->operands[0]))
    elif ins->kind == CfInstructionKind::PtrToInt64:
        printf("cast %s to 64-bit integer", varname_for_printing(ins->operands[0]))
    elif ins->kind == CfInstructionKind::Int64ToPtr:
        printf("cast %s from 64-bit integer to pointer", varname_for_printing(ins->operands[0]))
    elif ins->kind == CfInstructionKind::Constant:
        print_constant(&ins->constant)
    elif ins->kind == CfInstructionKind::SpecialConstant:
        printf("special constant \"%s\"", ins->scname)
    elif ins->kind == CfInstructionKind::StringArray:
        printf("string array ")
        print_string(ins->strarray.str, ins->strarray.len)
    elif (
        ins->kind == CfInstructionKind::NumAdd
        or ins->kind == CfInstructionKind::NumSub
        or ins->kind == CfInstructionKind::NumMul
        or ins->kind == CfInstructionKind::NumDiv
        or ins->kind == CfInstructionKind::NumMod
        or ins->kind == CfInstructionKind::NumEq
        or ins->kind == CfInstructionKind::NumLt
    ):
        if ins->kind == CfInstructionKind::NumAdd:
            printf("num add ")
        elif ins->kind == CfInstructionKind::NumSub:
            printf("num sub ")
        elif ins->kind == CfInstructionKind::NumMul:
            printf("num mul ")
        elif ins->kind == CfInstructionKind::NumDiv:
            printf("num div ")
        elif ins->kind == CfInstructionKind::NumMod:
            printf("num mod ")
        elif ins->kind == CfInstructionKind::NumEq:
            printf("num eq ")
        elif ins->kind == CfInstructionKind::NumLt:
            printf("num lt ")
        else:
            assert False
        printf("%s, %s", varname_for_printing(ins->operands[0]), varname_for_printing(ins->operands[1]))
    elif ins->kind == CfInstructionKind::PtrLoad:
        # Extra parentheses to make these stand out a bit.
        printf("*(%s)", varname_for_printing(ins->operands[0]))
    elif ins->kind == CfInstructionKind::PtrStore:
        printf("*(%s) = %s", varname_for_printing(ins->operands[0]), varname_for_printing(ins->operands[1]))
    elif ins->kind == CfInstructionKind::PtrAddInt:
        printf("ptr %s + integer %s", varname_for_printing(ins->operands[0]), varname_for_printing(ins->operands[1]))
    elif ins->kind == CfInstructionKind::PtrClassField:
        printf("%s + offset of field \"%s\"", varname_for_printing(ins->operands[0]), ins->fieldname)
    elif ins->kind == CfInstructionKind::PtrCast:
        printf("pointer cast %s", varname_for_printing(ins->operands[0]))
    elif ins->kind == CfInstructionKind::PtrMemsetToZero:
        printf("set value of pointer %s to zero bytes", varname_for_printing(ins->operands[0]))
    elif ins->kind == CfInstructionKind::VarCpy:
        printf("%s", varname_for_printing(ins->operands[0]))
    else:
        assert False
    printf("\n")


def print_control_flow_graph(cfg: CfGraph*) -> None:
    sigstr: byte* = signature_to_string(&cfg->signature, True, True)
    printf("Function %s\n", sigstr)
    free(sigstr)

    printf("  Variables:\n")
    for var = cfg->locals; var < &cfg->locals[cfg->nlocals]; var++:
        printf("    %-20s  %s\n", varname_for_printing(*var), (*var)->type->name)

    for blockidx = 0; blockidx < cfg->n_all_blocks; blockidx++:
        b = cfg->all_blocks[blockidx]

        printf("  Block %d", blockidx)
        #printf(" at %p", b)

        if b == &cfg->start_block:
            printf(" (start block)")
        if b == &cfg->end_block:
            assert b->ninstructions == 0
            printf(" is the end block.\n")
            continue

        printf(":\n")

        for ins = b->instructions; ins < &b->instructions[b->ninstructions]; ins++:
            print_cf_instruction(ins)

        if b == &cfg->end_block:
            assert b->iftrue == NULL
            assert b->iffalse == NULL
        elif b->iftrue == NULL and b->iffalse == NULL:
            printf("    Execution stops here. We have called a noreturn function.\n")
        else:
            trueidx = -1
            falseidx = -1
            for i = 0; i < cfg->n_all_blocks; i++:
                if cfg->all_blocks[i] == b->iftrue:
                    trueidx = i
                if cfg->all_blocks[i]==b->iffalse:
                    falseidx = i
            assert trueidx != -1
            assert falseidx != -1
            if trueidx == falseidx:
                printf("    Jump to block %d.\n", trueidx)
            else:
                assert b->branchvar != NULL
                printf("    If %s is True jump to block %d, otherwise block %d.\n",
                    varname_for_printing(b->branchvar), trueidx, falseidx)

    printf("\n")


def print_control_flow_graphs(cfgfile: CfGraphFile*) -> None:
    printf("===== Control Flow Graphs for file \"%s\" =====\n", cfgfile->filename)
    for cfg = cfgfile->graphs; cfg < &cfgfile->graphs[cfgfile->ngraphs]; cfg++:
        print_control_flow_graph(*cfg)

def print_llvm_ir(module: LLVMModule*, is_optimized: bool) -> None:
    if is_optimized:
        opt_or_unopt = "Optimized"
    else:
        opt_or_unopt = "Unoptimized"

    len = 0L
    filename = LLVMGetSourceFileName(module, &len)
    printf("===== %s LLVM IR for file \"%.*s\" =====\n", opt_or_unopt, len as int, filename)

    s = LLVMPrintModuleToString(module)
    puts(s)
    LLVMDisposeMessage(s)
