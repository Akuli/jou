from "./errors_and_warnings.jou" import assert
from "./ast.jou" import AstFile, AstImport
from "./tokenizer.jou" import tokenize, print_tokens
from "./parser.jou" import parse
from "./types.jou" import init_types
from "./typecheck.jou" import (
    TypeContext, ExportSymbol,
    typecheck_stage2_signatures_globals_structbodies,
    typecheck_stage3_function_and_method_bodies,
)
from "./find_jou_installation.jou" import find_stdlib, is_windows
from "./target.jou" import init_target, target
from "./create_llvm_ir.jou" import create_llvm_ir
from "./llvm.jou" import (
    LLVMPrintModuleToString, LLVMDisposeMessage,
    LLVMCodeGenFileType,
    LLVMTargetMachineEmitToFile,
    LLVMVerifyModule, LLVMVerifierFailureAction,
)
from "stdlib/mem.jou" import malloc, realloc, free
from "stdlib/process.jou" import exit, system
from "stdlib/str.jou" import strcmp, strlen, sprintf, starts_with, strspn
from "stdlib/io.jou" import fprintf, stderr, printf, puts

enum CompilerMode:
    TokenizeOnly    # Tokenize one file, don't recurse to imports
    ParseOnly       # Tokenize and parse one file, don't recurse to imports
    Compile         # Compile and link
    CompileAndRun   # Compile, link and run a program (default)

class CommandLineArgs:
    mode: CompilerMode
    output_file: byte*  # The argument after -o, possibly with .exe appended to it
    verbosity: int      # Number of -v/--verbose flags given
    main_path: byte*    # Jou file path passed on command line


# An error message should have already been printed to stderr, without a trailing \n
def fail_parsing_args(argv0: byte*, message: byte*) -> void:
    fprintf(stderr, "%s: %s (try \"%s --help\")\n", argv0, message, argv0)
    exit(2)

def print_help(argv0: byte*) -> void:
    printf("Usage:\n")
    printf("  %s [options] FILENAME.jou\n", argv0)
    printf("  %s --help         # This message\n", argv0)
    printf("\n")
    printf("Options:\n")
    printf("  -o OUTFILE                 output an executable file, don't run the code\n")
    printf("  -v/--verbose               print what compilation steps are done\n")
    printf("  -vv / --verbose --verbose  show what each compilation step produces\n")
    printf("  --tokenize-only            tokenize one file and display the resulting tokens\n")
    printf("  --parse-only               tokenize and parse one file and display the AST\n")

def parse_args(argc: int, argv: byte**) -> CommandLineArgs:
    result = CommandLineArgs{mode = CompilerMode::CompileAndRun}

    i = 1
    while i < argc:
        arg = argv[i++]

        if strcmp(arg, "--help") == 0:
            print_help(argv[0])
            exit(0)

        if result.mode != CompilerMode::CompileAndRun and (
            strcmp(arg, "--tokenize-only") == 0
            or strcmp(arg, "--parse-only") == 0
            or strcmp(arg, "-o") == 0
        ):
            fail_parsing_args(argv[0], "only one of --tokenize-only, --parse-only or -o can be given")

        if strcmp(arg, "--tokenize-only") == 0:
            result.mode = CompilerMode::TokenizeOnly
        elif strcmp(arg, "--parse-only") == 0:
            result.mode = CompilerMode::ParseOnly
        elif strcmp(arg, "-o") == 0:
            result.mode = CompilerMode::Compile
            result.output_file = argv[i++]
            if result.output_file == NULL:
                fail_parsing_args(argv[0], "-o must be followed by the name of an output file")
        elif starts_with(arg, "-v") and strspn(&arg[1], "v") == strlen(arg) - 1:
            result.verbosity += (strlen(arg) as int) - 1
        elif arg[0] == '-':
            message = malloc(strlen(arg) + 100)
            sprintf(message, "unknown option '%s'", arg)
            fail_parsing_args(argv[0], message)
        elif result.main_path == NULL:
            result.main_path = arg
        else:
            fail_parsing_args(argv[0], "you can pass only one Jou file")

    if result.main_path == NULL:
        fail_parsing_args(argv[0], "missing Jou file name")

    return result


class FileState:
    ast: AstFile
    typectx: TypeContext
    pending_exports: ExportSymbol*

class Compiler:
    verbosity: int
    stdlib_path: byte*
    files: FileState*
    nfiles: int

    def parse_all_files(self, main_path: byte*) -> void:
        queue: byte** = malloc(sizeof main_path)
        queue[0] = main_path
        queue_len = 1

        while queue_len > 0:
            path = queue[--queue_len]

            found = False
            for i = 0; i < self->nfiles; i++:
                if strcmp(self->files[i].ast.path, path) == 0:
                    found = True
                    break
            if found:
                continue

            if self->verbosity >= 1:
                printf("Parsing %s\n", path)

            tokens = tokenize(path)
            if self->verbosity >= 2:
                print_tokens(tokens)
            ast = parse(tokens, self->stdlib_path)
            if self->verbosity >= 2:
                ast.print()
            free(tokens)  # TODO: do this properly

            self->files = realloc(self->files, sizeof self->files[0] * (self->nfiles + 1))
            self->files[self->nfiles++] = FileState{ast = ast}

            imp: AstImport* = NULL
            while ast.next_import(&imp):
                queue = realloc(queue, sizeof queue[0] * (queue_len + 1))
                queue[queue_len++] = imp->path

        free(queue)

    def process_imports_and_exports(self) -> void:
        if self->verbosity >= 1:
            printf("Processing imports/exports\n")

        for isrc = 0; isrc < self->nfiles; isrc++:
            for idest = 0; idest < self->nfiles; idest++:
                src = &self->files[isrc]
                dest = &self->files[idest]

                imp: AstImport* = NULL
                while dest->ast.next_import(&imp):
                    for exp = src->pending_exports; exp->name[0] != '\0'; exp++:
                        if strcmp(&imp->symbol[0], &exp->name[0]) == 0:
                            if self->verbosity >= 1:
                                printf(
                                    "  %s: imported in %s, exported in %s\n",
                                    &exp->name[0], src->ast.path, dest->ast.path,
                                )
                            dest->typectx.add_imported_symbol(exp)

        for i = 0; i < self->nfiles; i++:
            free(self->files[i].pending_exports)
            self->files[i].pending_exports = NULL

    def typecheck_stage2_all_files(self) -> void:
        for i = 0; i < self->nfiles; i++:
            if self->verbosity >= 1:
                printf("Type-check stage 2: %s\n", self->files[i].ast.path)

            assert(self->files[i].pending_exports == NULL)
            self->files[i].pending_exports = typecheck_stage2_signatures_globals_structbodies(
                &self->files[i].typectx,
                &self->files[i].ast,
            )

    def typecheck_stage3_all_files(self) -> void:
        for i = 0; i < self->nfiles; i++:
            if self->verbosity >= 1:
                printf("Type-check stage 3: %s\n", self->files[i].ast.path)

            typecheck_stage3_function_and_method_bodies(
                &self->files[i].typectx,
                &self->files[i].ast,
            )

    def create_object_files(self) -> void:
        # TODO: do this in a way that doesn't suck
        if not is_windows():
            system("rm -rf tmp/self_hosted_obj && mkdir -p tmp/self_hosted_obj")

        for i = 0; i < self->nfiles; i++:
            if self->verbosity >= 1:
                printf("Build LLVM IR: %s\n", self->files[i].ast.path)

            module = create_llvm_ir(&self->files[i].ast, &self->files[i].typectx)
            if self->verbosity >= 2:
                # Don't want to use LLVMDumpModule() because it dumps to stdout.
                # When redirected, stdout and stderr tend to get mixed up into a weird order.
                s = LLVMPrintModuleToString(module)
                puts(s)
                LLVMDisposeMessage(s)

            if self->verbosity >= 1:
                printf("Verify LLVM IR: %s\n", self->files[i].ast.path)
            LLVMVerifyModule(module, LLVMVerifierFailureAction::AbortProcess)

            path: byte[100]
            sprintf(&path[0], "tmp/self_hosted_obj/object%d.o", i)

            if self->verbosity >= 1:
                printf("Emit LLVM IR: %s --> %s\n", self->files[i].ast.path, &path[0])

            error: byte* = NULL
            if LLVMTargetMachineEmitToFile(target.target_machine, module, &path[0], LLVMCodeGenFileType::ObjectFile, &error):
                assert(error != NULL)
                fprintf(stderr, "error in LLVMTargetMachineEmitToFile(): %s\n", error)
                exit(1)
            assert(error == NULL)


def main(argc: int, argv: byte**) -> int:
    init_target()
    init_types()

    args = parse_args(argc, argv)

    if args.mode == CompilerMode::TokenizeOnly:
        tokens = tokenize(args.main_path)
        print_tokens(tokens)
        free(tokens)
    elif args.mode == CompilerMode::ParseOnly:
        tokens = tokenize(args.main_path)
        stdlib_path = find_stdlib()
        ast = parse(tokens, stdlib_path)
        ast.print()
        ast.free()
        free(tokens)
        free(stdlib_path)
    else:
        compiler = Compiler{verbosity = args.verbosity, stdlib_path = find_stdlib()}
        compiler.parse_all_files(args.main_path)
        compiler.typecheck_stage2_all_files()
        compiler.process_imports_and_exports()
        compiler.typecheck_stage3_all_files()
        compiler.create_object_files()

    return 0
