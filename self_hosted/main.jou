import "stdlib/io.jou"
import "stdlib/process.jou"
import "stdlib/mem.jou"
import "stdlib/errno.jou"
import "stdlib/str.jou"

import "./build_cfg.jou"
import "./codegen.jou"
import "./print.jou"
import "./llvm.jou"
import "./output.jou"
import "./typecheck.jou"
import "./target.jou"
import "./types.jou"
import "./free.jou"
import "./parser.jou"
import "./paths.jou"
import "./errors_and_warnings.jou"
import "./structs.jou"
import "./update.jou"
import "./tokenizer.jou"
import "./ast.jou"


def optimize(module: LLVMModule*, level: int) -> None:
    assert 1 <= level and level <= 3

    pm = LLVMCreatePassManager()

    # The default settings should be fine for Jou because they work well for
    # C and C++, and Jou is quite similar to C.
    pmbuilder = LLVMPassManagerBuilderCreate()
    LLVMPassManagerBuilderSetOptLevel(pmbuilder, level)
    LLVMPassManagerBuilderPopulateModulePassManager(pmbuilder, pm)
    LLVMPassManagerBuilderDispose(pmbuilder)

    LLVMRunPassManager(pm, module)
    LLVMDisposePassManager(pm)


def print_help(argv0: byte*) -> None:
    printf("Usage:\n")
    printf("  %s [-o OUTFILE] [-O0|-O1|-O2|-O3] [--verbose] [--linker-flags \"...\"] FILENAME\n", argv0)
    printf("  %s --help       # This message\n", argv0)
    printf("  %s --update     # Download and install the latest Jou\n", argv0)
    printf("\n")
    printf("Options:\n")
    printf("  -o OUTFILE       output an executable file, don't run the code\n")
    printf("  -O0/-O1/-O2/-O3  set optimization level (0 = no optimization, 1 = default, 3 = runs fastest)\n")
    printf("  -v / --verbose   display some progress information\n")
    printf("  -vv              display a lot of information about all compilation steps\n")
    printf("  --valgrind       use valgrind when running the code\n")
    printf("  --tokenize-only  display only the output of the tokenizer, don't do anything else\n")
    printf("  --parse-only     display only the AST (parse tree), don't do anything else\n")
    printf("  --linker-flags   appended to the linker command, so you can use external libraries\n")

def parse_arguments(argc: int, argv: byte**) -> None:
    memset(&command_line_args, 0, sizeof command_line_args)
    command_line_args.argv0 = argv[0]
    # Set default optimize to O1, user sets optimize will overwrite the default flag
    command_line_args.optlevel = 1

    if argc == 2 and strcmp(argv[1], "--help") == 0:
        print_help(argv[0])
        exit(0)

    if argc == 2 and strcmp(argv[1], "--update") == 0:
        update_jou_compiler()
        exit(0)

    i = 1
    while i < argc:
        if strcmp(argv[i], "--help") == 0 or strcmp(argv[i], "--update") == 0:
            fprintf(stderr, "%s: \"%s\" cannot be used with other arguments", argv[0], argv[i])
            fprintf(stderr, " (try \"%s --help\")\n", argv[0])
            exit(2)
        elif strcmp(argv[i], "--verbose") == 0:
            command_line_args.verbosity++
            i++
        elif starts_with(argv[i], "-v") and strspn(&argv[i][1], "v") == strlen(argv[i])-1:
            command_line_args.verbosity += (strlen(argv[i]) as int) - 1
            i++
        elif strcmp(argv[i], "--valgrind") == 0:
            command_line_args.valgrind = True
            i++
        elif strcmp(argv[i], "--tokenize-only") == 0:
            if argc > 3:
                fprintf(stderr, "%s: --tokenize-only cannot be used together with other flags (try \"%s --help\")\n", argv[0], argv[0])
                exit(2)
            command_line_args.tokenize_only = True
            i++
        elif strcmp(argv[i], "--parse-only") == 0:
            if argc > 3:
                fprintf(stderr, "%s: --parse-only cannot be used together with other flags (try \"%s --help\")", argv[0], argv[0])
                exit(2)
            command_line_args.parse_only = True
            i++
        elif strcmp(argv[i], "--linker-flags") == 0:
            if command_line_args.linker_flags != NULL:
                fprintf(stderr, "%s: --linker-flags cannot be given multiple times (try \"%s --help\")\n", argv[0], argv[0])
                exit(2)

            if argc-i < 2:
                fprintf(stderr, "%s: there must be a string of flags after --linker-flags (try \"%s --help\")\n", argv[0], argv[0])
                exit(2)

            command_line_args.linker_flags = argv[i+1]
            i += 2
        elif (
            strlen(argv[i]) == 3
            and starts_with(argv[i], "-O")
            and argv[i][2] >= '0'
            and argv[i][2] <= '3'
        ):
            command_line_args.optlevel = argv[i][2] - '0'
            i++
        elif strcmp(argv[i], "-o") == 0:
            if argc-i < 2:
                fprintf(stderr, "%s: there must be a file name after -o", argv[0])
                fprintf(stderr, " (try \"%s --help\")\n", argv[0])
                exit(2)

            command_line_args.outfile = argv[i+1]
            if strlen(command_line_args.outfile) > 4 and ends_with(command_line_args.outfile, ".jou"):
                fprintf(stderr, "%s: the filename after -o should be an executable, not a Jou file (try \"%s --help\")\n", argv[0], argv[0])
                exit(2)
            i += 2
        elif argv[i][0] == '-':
            fprintf(stderr, "%s: unknown argument \"%s\"", argv[0], argv[i])
            fprintf(stderr, " (try \"%s --help\")\n", argv[0])
            exit(2)
        elif command_line_args.infile != NULL:
            fprintf(stderr, "%s: you can only pass one Jou file (try \"%s --help\")\n", argv[0], argv[0])
            exit(2)
        else:
            command_line_args.infile = argv[i++]

    if command_line_args.infile == NULL:
        fprintf(stderr, "%s: missing Jou file name (try \"%s --help\")\n", argv[0], argv[0])
        exit(2)


class FileState:
    path: byte*
    ast: AstFile
    types: FileTypes
    module: LLVMModule*
    pending_exports: ExportSymbol*

class ParseQueueItem:
    filename: byte*
    import_location: Location

class CompileState:
    stdlib_path: byte*
    files: FileState*
    nfiles: int
    parse_queue: ParseQueueItem*
    parse_queue_len: int

def find_file(compst: CompileState*, path: byte*) -> FileState*:
    for fs = compst->files; fs < &compst->files[compst->nfiles]; fs++:
        if strcmp(fs->path, path) == 0:
            return fs
    return NULL

def open_the_file(path: byte*, import_location: Location*) -> FILE*:
    f = fopen(path, "rb")
    if f == NULL:
        msg: byte[500]
        if import_location != NULL:
            snprintf(msg, sizeof(msg), "cannot import from \"%s\": %s", path, strerror(get_errno()))
            fail(*import_location, msg)
        else:
            snprintf(msg, sizeof(msg), "cannot open file: %s", strerror(get_errno()))
            fail(Location{path=path}, msg)
    return f

def defines_main(ast: AstFile*) -> bool:
    for i = 0; i < ast->body.nstatements; i++:
        s = &ast->body.statements[i]
        if s->kind == AstStatementKind::Function and strcmp(s->function.signature.name, "main") == 0:
            return True
    return False

def parse_file(compst: CompileState*, filename: byte*, import_location: Location*) -> None:
    if find_file(compst, filename) != NULL:
        return

    fs = FileState{path = strdup(filename)}

    if command_line_args.verbosity >= 1:
        printf("Tokenizing %s\n", filename)
    tokens = tokenize(fs.path, import_location)

    if command_line_args.verbosity >= 2:
        print_tokens(tokens)

    if command_line_args.verbosity >= 1:
        printf("Parsing %s\n", filename)
    fs.ast = parse(tokens, compst->stdlib_path)
    free_tokens(tokens)

    # TODO: enable this
#    if command_line_args.verbosity >= 1:
#        printf("Evaluating compile-time if statements in %s\n", filename)
#    evaluate_compile_time_if_statements(&fs.ast.body)

    if command_line_args.verbosity >= 2:
        fs.ast.print()

    # If it's not the file passed on command line, it shouldn't define main()
    if strcmp(filename, command_line_args.infile) != 0 and defines_main(&fs.ast):
        # Set error location to import, so user immediately knows which file
        # imports something that defines main().
        assert import_location != NULL
        fail(*import_location, "imported file should not have `main` function")

    for imp = fs.ast.imports; imp < &fs.ast.imports[fs.ast.nimports]; imp++:
        compst->parse_queue = realloc(compst->parse_queue, sizeof(compst->parse_queue[0]) * (compst->parse_queue_len + 1))
        assert compst->parse_queue != NULL
        compst->parse_queue[compst->parse_queue_len++] = ParseQueueItem{
            filename = imp->resolved_path,
            import_location = imp->location,
        }

    compst->files = realloc(compst->files, sizeof(compst->files[0]) * (compst->nfiles + 1))
    assert compst->files != NULL
    compst->files[compst->nfiles++] = fs

def parse_all_pending_files(compst: CompileState*) -> None:
    while compst->parse_queue_len > 0:
        it = compst->parse_queue[--compst->parse_queue_len]
        parse_file(compst, it.filename, &it.import_location)
    free(compst->parse_queue)

def compile_ast_to_object_file(fs: FileState*) -> byte*:
    if command_line_args.verbosity >= 1:
        printf("Building Control Flow Graphs: %s\n", fs->path)

    cfgfile = build_control_flow_graphs(&fs->ast, &fs->types)
    for imp = fs->ast.imports; imp < &fs->ast.imports[fs->ast.nimports]; imp++:
        if not imp->used:
            msg: byte[500]
            snprintf(msg, sizeof msg, "\"%s\" imported but not used", imp->specified_path)
            show_warning(imp->location, msg)

    if command_line_args.verbosity >= 2:
        print_control_flow_graphs(&cfgfile)

    # TODO: implement this
#    if command_line_args.verbosity >= 1:
#        printf("Analyzing CFGs: %s\n", fs->path)
#    simplify_control_flow_graphs(&cfgfile)
#    if command_line_args.verbosity >= 2:
#        print_control_flow_graphs(&cfgfile)

    if command_line_args.verbosity >= 1:
        printf("Building LLVM IR: %s\n", fs->path)

    mod = codegen(&cfgfile, &fs->types)
    # TODO: free the control flow graphs, this crashes for some reason
    #free_control_flow_graphs(&cfgfile)

    if command_line_args.verbosity >= 2:
        print_llvm_ir(mod, False)

    # If this fails, it is not just users writing dumb code, it is a bug in this compiler.
    # This compiler should always fail with an error elsewhere, or generate valid LLVM IR.
    LLVMVerifyModule(mod, LLVMVerifierFailureAction::AbortProcess, NULL)

    if command_line_args.optlevel != 0:
        if command_line_args.verbosity >= 1:
            printf("Optimizing %s (level %d)\n", fs->path, command_line_args.optlevel)
        optimize(mod, command_line_args.optlevel)
        if command_line_args.verbosity >= 2:
            print_llvm_ir(mod, True)

    objpath = compile_to_object_file(mod)
    LLVMDisposeModule(mod)
    return objpath


def statement_conflicts_with_an_import(stmt: AstStatement*, importsym: ExportSymbol*) -> bool:
    if stmt->kind == AstStatementKind::Function:
        return (
            importsym->kind == ExportSymbolKind::Function
            and strcmp(importsym->name, stmt->function.signature.name) == 0
        )

    if (
        stmt->kind == AstStatementKind::GlobalVariableDeclaration
        or stmt->kind == AstStatementKind::GlobalVariableDefinition
    ):
        return (
            importsym->kind == ExportSymbolKind::GlobalVar
            and strcmp(importsym->name, stmt->var_declaration.name) == 0
        )

    if stmt->kind == AstStatementKind::Class:
        return (
            importsym->kind == ExportSymbolKind::Type
            and strcmp(importsym->name, stmt->classdef.name) == 0
        )

    if stmt->kind == AstStatementKind::Enum:
        return (
            importsym->kind == ExportSymbolKind::Type
            and strcmp(importsym->name, stmt->enumdef.name) == 0
        )

    assert False  # TODO

def add_imported_symbol(fs: FileState*, es: ExportSymbol*, imp: AstImport*) -> None:
    for i = 0; i < fs->ast.body.nstatements; i++:
        if statement_conflicts_with_an_import(&fs->ast.body.statements[i], es):
            if es->kind == ExportSymbolKind::Function:
                wat = "function"
            elif es->kind == ExportSymbolKind::GlobalVar:
                wat = "global variable"
            elif es->kind == ExportSymbolKind::Type:
                wat = "type"
            else:
                assert False

            msg: byte[500]
            snprintf(msg, sizeof msg, "a %s named '%s' already exists", wat, es->name)
            fail(fs->ast.body.statements[i].location, msg)

    if es->kind == ExportSymbolKind::Function:
        fs->types.functions = realloc(fs->types.functions, sizeof(fs->types.functions[0]) * (fs->types.nfunctions + 1))
        assert fs->types.functions != NULL
        fs->types.functions[fs->types.nfunctions++] = SignatureAndUsedPtr{
            signature = copy_signature(&es->funcsignature),
            usedptr = &imp->used,
        }
    elif es->kind == ExportSymbolKind::Type:
        fs->types.types = realloc(fs->types.types, sizeof(fs->types.types[0]) * (fs->types.ntypes + 1))
        assert fs->types.types != NULL
        fs->types.types[fs->types.ntypes++] = TypeAndUsedPtr{
            type = es->type,
            usedptr = &imp->used,
        }
    elif es->kind == ExportSymbolKind::GlobalVar:
        g = GlobalVariable{
            type = es->type,
            usedptr = &imp->used,
        }

        assert strlen(es->name) < sizeof g.name
        strcpy(g.name, es->name)

        fs->types.globals = realloc(fs->types.globals, sizeof(fs->types.globals[0]) * (fs->types.nglobals + 1))
        assert fs->types.globals != NULL
        fs->types.globals[fs->types.nglobals++] = g
    else:
        assert False

def add_imported_symbols(compst: CompileState*) -> None:
    for to = compst->files; to < &compst->files[compst->nfiles]; to++:
        seen_before: FileState** = NULL
        seen_before_len = 0

        for imp = to->ast.imports; imp < &to->ast.imports[to->ast.nimports]; imp++:
            from = find_file(compst, imp->resolved_path)
            assert from != NULL

            if from == to:
                fail(imp->location, "the file itself cannot be imported")

            for i = 0; i < seen_before_len; i++:
                if seen_before[i] == from:
                    msg: byte[500]
                    snprintf(msg, sizeof msg, "file \"%s\" is imported twice", imp->specified_path)
                    fail(imp->location, msg)

            seen_before = realloc(seen_before, sizeof(seen_before[0]) * (seen_before_len + 1))
            seen_before[seen_before_len++] = from

            for es = from->pending_exports; es->name[0] != '\0'; es++:
                if command_line_args.verbosity >= 2:
                    if es->kind == ExportSymbolKind::Function:
                        kindstr = "function"
                    elif es->kind == ExportSymbolKind::GlobalVar:
                        kindstr = "global var"
                    elif es->kind == ExportSymbolKind::Type:
                        kindstr = "type"
                    else:
                        assert False

                    printf("Adding imported %s %s: %s --> %s\n",
                        kindstr, es->name, from->path, to->path)

                add_imported_symbol(to, es, imp)

        free(seen_before)

    # Mark all exports as no longer pending.
    for fs = compst->files; fs < &compst->files[compst->nfiles]; fs++:
        for es = fs->pending_exports; es->name[0] != '\0'; es++:
            free_export_symbol(es)
        free(fs->pending_exports)
        fs->pending_exports = NULL

def include_special_stdlib_file(compst: CompileState*, filename: byte*) -> None:
    path = malloc(strlen(compst->stdlib_path) + strlen(filename) + 123)
    sprintf(path, "%s/%s", compst->stdlib_path, filename)
    parse_file(compst, path, NULL)
    free(path)

def main(argc: int, argv: byte**) -> int:
    init_target()
    init_types()
    stdlib = find_stdlib()
    parse_arguments(argc, argv)

    compst = CompileState{ stdlib_path = stdlib }
    if command_line_args.verbosity >= 2:
        printf("Target triple: %s\n", target.triple)
        printf("Data layout: %s\n", target.data_layout)

    if command_line_args.tokenize_only or command_line_args.parse_only:
        tokens = tokenize(command_line_args.infile, NULL)
        if command_line_args.tokenize_only:
            print_tokens(tokens)
        else:
            ast = parse(tokens, compst.stdlib_path)
            ast.print()
            ast.free()
        free_tokens(tokens)
        return 0

    include_special_stdlib_file(&compst, "_assert_fail.jou")

    if WINDOWS or MACOS or NETBSD:
        include_special_stdlib_file(&compst, "_jou_startup.jou")

    parse_file(&compst, command_line_args.infile, NULL)
    parse_all_pending_files(&compst)

    if command_line_args.verbosity >= 1:
        printf("Type-checking...\n")

    for fs = compst.files; fs < &compst.files[compst.nfiles]; fs++:
        if command_line_args.verbosity >= 1:
            printf("  stage 1: %s\n", fs->path)
        fs->pending_exports = typecheck_stage1_create_types(&fs->types, &fs->ast)

    add_imported_symbols(&compst)
    for fs = compst.files; fs < &compst.files[compst.nfiles]; fs++:
        if command_line_args.verbosity >= 1:
            printf("  stage 2: %s\n", fs->path)
        fs->pending_exports = typecheck_stage2_populate_types(&fs->types, &fs->ast)

    add_imported_symbols(&compst)
    for fs = compst.files; fs < &compst.files[compst.nfiles]; fs++:
        if command_line_args.verbosity >= 1:
            printf("  stage 3: %s\n", fs->path)
        typecheck_stage3_function_and_method_bodies(&fs->types, &fs->ast)

    objpaths: byte** = calloc(sizeof objpaths[0], compst.nfiles + 1)
    for i = 0; i < compst.nfiles; i++:
        objpaths[i] = compile_ast_to_object_file(&compst.files[i])

    # Check for missing main() as late as possible, so that other errors come first.
    # This way Jou users can work on other functions before main() function is written.
    mainfile = find_file(&compst, command_line_args.infile)
    assert mainfile != NULL
    if not defines_main(&mainfile->ast):
        fail(Location{path=mainfile->path, lineno=0}, "missing `main` function to execute the program")

    for fs = compst.files; fs < &compst.files[compst.nfiles]; fs++:
        fs->ast.free()
        free(fs->path)
        free_file_types(&fs->types)
    free(compst.files)
    free(stdlib)

    if command_line_args.outfile != NULL:
        exepath = strdup(command_line_args.outfile)
    else:
        assert False  # TODO: do this
        #exepath = get_default_exe_path()

    run_linker(objpaths, exepath)
    for i = 0; objpaths[i] != NULL; i++:
        free(objpaths[i])
    free(objpaths)

    ret = 0
    if command_line_args.outfile != NULL:
        if command_line_args.verbosity >= 1:
            printf("Run: %s\n", exepath)
        assert False  # TODO: do this
        #ret = run_exe(exepath, command_line_args.valgrind)

    free(exepath)

    # not really necessary, but makes valgrind much happier
    free_global_type_state()
    cleanup_target()

    return ret
