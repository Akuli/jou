import "stdlib/math.jou"
import "stdlib/mem.jou"
import "stdlib/str.jou"

import "./typecheck.jou"
import "./evaluate.jou"
import "./llvm.jou"
import "./target.jou"
import "./types.jou"
import "./structs.jou"

# LLVM doesn't have a built-in union type, and you're supposed to abuse other types for that:
# https://mapping-high-level-constructs-to-llvm-ir.readthedocs.io/en/latest/basic-constructs/unions.html
#
# My first idea was to use an array of bytes that is big enough to fit anything.
# However, that might not be aligned properly.
#
# Then I tried choosing the member type that has the biggest align, and making a large enough array of it.
# Because the align is always a power of two, the memory will be suitably aligned for all member types.
# But it didn't work for some reason I still don't understand.
#
# Then I figured out how clang does it and did it the same way.
# We make a struct that contains:
# - the most aligned type as chosen before
# - array of i8 as padding to make it the right size.
# But for some reason that didn't work either.
#
# As a "last resort" I just use an array of i64 large enough and hope it's aligned as needed.
def codegen_union_type(types: LLVMType**, ntypes: int) -> LLVMType*:
    # For some reason uncommenting this makes stuff compile almost 2x slower...
    #if ntypes == 1:
    #    return types[0]

    sizeneeded = 0L
    for i = 0; i < ntypes; i++:
        size1 = LLVMABISizeOfType(target.target_data, types[i])
        size2 = LLVMStoreSizeOfType(target.target_data, types[i])

        # If this assert fails, you need to figure out which of the size functions should be used.
        # I don't know what their difference is.
        # And if you need the alignment, there's 3 different functions for that...
        assert size1 == size2
        sizeneeded = llmax(sizeneeded, size1)

    return LLVMArrayType(LLVMInt64Type(), ((sizeneeded+7)/8) as int)


def codegen_class_type(type: Type*) -> LLVMType*:
    assert type->kind == TypeKind::Class

    n = type->classdata.nfields

    flat_elems: LLVMType** = malloc(sizeof(flat_elems[0]) * n)
    for i = 0; i < n; i++:
        # Treat all pointers inside structs as if they were void*.
        # This allows structs to contain pointers to themselves.
        if type->classdata.fields[i].type->kind == TypeKind::Pointer:
            flat_elems[i] = codegen_type(voidPtrType)
        else:
            flat_elems[i] = codegen_type(type->classdata.fields[i].type)

    # Combine together fields of the same union.
    combined: LLVMType** = malloc(sizeof(combined[0]) * n)
    combinedlen = 0
    for start = 0; start < n; start = end:
        end = start + 1
        while end < n and type->classdata.fields[start].union_id == type->classdata.fields[end].union_id:
            end++
        combined[combinedlen++] = codegen_union_type(&flat_elems[start], end-start)

    result = LLVMStructType(combined, combinedlen, False as int)
    free(flat_elems)
    free(combined)
    return result


def codegen_type(type: Type*) -> LLVMType*:
    if type->kind == TypeKind::Array:
        return LLVMArrayType(codegen_type(type->array.item_type), type->array.len)
    if type->kind == TypeKind::Pointer:
        return LLVMPointerType(codegen_type(type->value_type), 0)
    if type->kind == TypeKind::FloatingPoint:
        if type->size_in_bits == 32:
            return LLVMFloatType()
        if type->size_in_bits == 64:
            return LLVMDoubleType()
        assert False
    if type->kind == TypeKind::VoidPointer:
        # just use i8* as here https://stackoverflow.com/q/36724399
        return LLVMPointerType(LLVMInt8Type(), 0)
    if (
        type->kind == TypeKind::SignedInteger
        or type->kind == TypeKind::UnsignedInteger
    ):
        return LLVMIntType(type->size_in_bits)
    if type->kind == TypeKind::Bool:
        return LLVMInt1Type()
    if type->kind == TypeKind::OpaqueClass:
        # this is compiler internal/temporary thing and should never end up here
        assert False
    if type->kind == TypeKind::Class:
        return codegen_class_type(type)
    if type->kind == TypeKind::Enum:
        return LLVMInt32Type()
    assert False


class State:
    module: LLVMModule*
    builder: LLVMBuilder*
    cfvars: LocalVariable**
    cfvars_end: LocalVariable**
    # All local variables are represented as pointers to stack space, even
    # if they are never reassigned. LLVM will optimize the mess.
    llvm_locals: LLVMValue**


def get_pointer_to_local_var(st: State*, cfvar: LocalVariable*) -> LLVMValue*:
    assert cfvar != NULL

    # The loop below looks stupid, but I don't see a better alternative.
    #
    # I want CFG variables to be used as pointers, so that it's easy to refer to a
    # variable's name and type, check if you have the same variable, etc. But I
    # can't make a List of variables when building CFG, because existing variable
    # pointers would become invalid as the list grows. The solution is to allocate
    # each variable separately when building the CFG.
    #
    # Another idea I had was to count the number of variables needed beforehand,
    # so I wouldn't need to ever resize the list of variables, but the CFG building
    # is already complicated enough as is.
    for i = 0; &st->cfvars[i] < st->cfvars_end; i++:
        if st->cfvars[i] == cfvar:
            return st->llvm_locals[i]
    assert False


def get_local_var(st: State*, cfvar: LocalVariable*) -> LLVMValue*:
    varptr = get_pointer_to_local_var(st, cfvar)
    return LLVMBuildLoad(st->builder, varptr, cfvar->name)


def set_local_var(st: State*, cfvar: LocalVariable*, value: LLVMValue*) -> None:
    assert cfvar != NULL
    for i = 0; &st->cfvars[i] < st->cfvars_end; i++:
        if st->cfvars[i] == cfvar:
            LLVMBuildStore(st->builder, value, st->llvm_locals[i])
            return
    assert False


def codegen_function_or_method_decl(st: State*, sig: Signature*) -> LLVMValue*:
    fullname: byte[200]
    if get_self_class(sig) != NULL:
        snprintf(fullname, sizeof fullname, "%s.%s", get_self_class(sig)->name, sig->name)
    else:
        assert sizeof(fullname) >= sizeof(sig->name)
        assert sizeof(sig->name) > 50  # this is an array, not a pointer to dynamic length string
        strcpy(fullname, sig->name)

    # Make it so that this can be called many times without issue
    func = LLVMGetNamedFunction(st->module, fullname)
    if func != NULL:
        return func

    argtypes: LLVMType** = malloc(sig->nargs * sizeof(argtypes[0]))
    for i = 0; i < sig->nargs; i++:
        argtypes[i] = codegen_type(sig->argtypes[i])

    returntype: LLVMType*
    # TODO: tell llvm, if we know a function is noreturn ?
    if sig->returntype == NULL:  # "-> noreturn" or "-> None"
        returntype = LLVMVoidType()
    else:
        returntype = codegen_type(sig->returntype)

    functype = LLVMFunctionType(returntype, argtypes, sig->nargs, sig->takes_varargs as int)
    free(argtypes)

    return LLVMAddFunction(st->module, fullname, functype)


def codegen_call(st: State*, sig: Signature*, args: LLVMValue**, nargs: int) -> LLVMValue*:
    function: LLVMValue* = codegen_function_or_method_decl(st, sig)
    assert function != NULL
    assert LLVMGetTypeKind(LLVMTypeOf(function)) == LLVMTypeKind::Pointer
    function_type = LLVMGetElementType(LLVMTypeOf(function))
    assert LLVMGetTypeKind(function_type) == LLVMTypeKind::Function

    debug_name: byte[100] = ""
    if LLVMGetTypeKind(LLVMGetReturnType(function_type)) != LLVMTypeKind::Void:
        snprintf(debug_name, sizeof debug_name, "%s_return_value", sig->name)

    return LLVMBuildCall2(st->builder, function_type, function, args, nargs, debug_name)


def make_a_string_constant(st: State*, s: byte*) -> LLVMValue*:
    array = LLVMConstString(s, strlen(s) as int, False as int)
    global_var = LLVMAddGlobal(st->module, LLVMTypeOf(array), "string_literal")
    LLVMSetLinkage(global_var, LLVMLinkage::Private)  # This makes it a static global variable
    LLVMSetInitializer(global_var, array)

    string_type = LLVMPointerType(LLVMInt8Type(), 0)
    return LLVMBuildBitCast(st->builder, global_var, string_type, "string_ptr")


def codegen_constant(st: State*, c: Constant*) -> LLVMValue*:
    if c->kind == ConstantKind::Bool:
        return LLVMConstInt(LLVMInt1Type(), c->boolean as long, False as int)
    if c->kind == ConstantKind::Integer:
        return LLVMConstInt(codegen_type(type_of_constant(c)), c->integer.value, c->integer.is_signed as int)
    if c->kind == ConstantKind::Float or c->kind == ConstantKind::Double:
        return LLVMConstRealOfString(codegen_type(type_of_constant(c)), c->double_or_float_text)
    if c->kind == ConstantKind::Null:
        return LLVMConstNull(codegen_type(voidPtrType))
    if c->kind == ConstantKind::String:
        return make_a_string_constant(st, c->str)
    if c->kind == ConstantKind::EnumMember:
        return LLVMConstInt(LLVMInt32Type(), c->enum_member.memberidx, False as int)
    assert False


def codegen_special_constant(name: byte*) -> LLVMValue*:
    v = get_special_constant(name)
    assert v != -1
    return LLVMConstInt(LLVMInt1Type(), v, False as int)


def build_signed_mod(builder: LLVMBuilder*, lhs: LLVMValue*, rhs: LLVMValue*) -> LLVMValue*:
    # Jou's % operator ensures that a%b has same sign as b:
    # jou_mod(a, b) = llvm_mod(llvm_mod(a, b) + b, b)
    llmod = LLVMBuildSRem(builder, lhs, rhs, "smod_tmp")
    sum = LLVMBuildAdd(builder, llmod, rhs, "smod_tmp")
    return LLVMBuildSRem(builder, sum, rhs, "smod")


def build_signed_div(builder: LLVMBuilder*, lhs: LLVMValue*, rhs: LLVMValue*) -> LLVMValue*:
    # LLVM's provides two divisions. One truncates, the other is an "exact div"
    # that requires there is no remainder. Jou uses floor division which is
    # neither of the two, but is quite easy to implement:
    #
    #    floordiv(a, b) = exact_div(a - jou_mod(a, b), b)
    #
    top = LLVMBuildSub(builder, lhs, build_signed_mod(builder, lhs, rhs), "sdiv_tmp")
    return LLVMBuildExactSDiv(builder, top, rhs, "sdiv")


def codegen_arithmetic_instruction(st: State*, ins: CfInstruction*) -> None:
    lhs = get_local_var(st, ins->operands[0])
    rhs = get_local_var(st, ins->operands[1])

    assert ins->operands[0]->type == ins->operands[1]->type
    type = ins->operands[0]->type

    if type->kind == TypeKind::FloatingPoint:
        if ins->kind == CfInstructionKind::NumAdd:
            set_local_var(st, ins->destvar, LLVMBuildFAdd(st->builder, lhs, rhs, "float_sum"))
        elif ins->kind == CfInstructionKind::NumSub:
            set_local_var(st, ins->destvar, LLVMBuildFSub(st->builder, lhs, rhs, "float_diff"))
        elif ins->kind == CfInstructionKind::NumMul:
            set_local_var(st, ins->destvar, LLVMBuildFMul(st->builder, lhs, rhs, "float_prod"))
        elif ins->kind == CfInstructionKind::NumDiv:
            set_local_var(st, ins->destvar, LLVMBuildFDiv(st->builder, lhs, rhs, "float_quot"))
        elif ins->kind == CfInstructionKind::NumMod:
            set_local_var(st, ins->destvar, LLVMBuildFRem(st->builder, lhs, rhs, "float_mod"))
        else:
            assert False

    elif type->kind == TypeKind::SignedInteger:
        if ins->kind == CfInstructionKind::NumAdd:
            set_local_var(st, ins->destvar, LLVMBuildAdd(st->builder, lhs, rhs, "int_sum"))
        elif ins->kind == CfInstructionKind::NumSub:
            set_local_var(st, ins->destvar, LLVMBuildSub(st->builder, lhs, rhs, "int_diff"))
        elif ins->kind == CfInstructionKind::NumMul:
            set_local_var(st, ins->destvar, LLVMBuildMul(st->builder, lhs, rhs, "int_prod"))
        elif ins->kind == CfInstructionKind::NumDiv:
            set_local_var(st, ins->destvar, build_signed_div(st->builder, lhs, rhs))
        elif ins->kind == CfInstructionKind::NumMod:
            set_local_var(st, ins->destvar, build_signed_mod(st->builder, lhs, rhs))
        else:
            assert False

    elif type->kind == TypeKind::UnsignedInteger:
        if ins->kind == CfInstructionKind::NumAdd:
            set_local_var(st, ins->destvar, LLVMBuildAdd(st->builder, lhs, rhs, "uint_sum"))
        elif ins->kind == CfInstructionKind::NumSub:
            set_local_var(st, ins->destvar, LLVMBuildSub(st->builder, lhs, rhs, "uint_diff"))
        elif ins->kind == CfInstructionKind::NumMul:
            set_local_var(st, ins->destvar, LLVMBuildMul(st->builder, lhs, rhs, "uint_prod"))
        elif ins->kind == CfInstructionKind::NumDiv:
            set_local_var(st, ins->destvar, LLVMBuildUDiv(st->builder, lhs, rhs, "uint_quot"))
        elif ins->kind == CfInstructionKind::NumMod:
            set_local_var(st, ins->destvar, LLVMBuildURem(st->builder, lhs, rhs, "uint_mod"))
        else:
            assert False

    else:
        assert False


def codegen_instruction(st: State*, ins: CfInstruction*) -> None:
    if ins->kind == CfInstructionKind::Call:
        args: LLVMValue** = malloc(ins->noperands * sizeof(args[0]))
        for i = 0; i < ins->noperands; i++:
            args[i] = get_local_var(st, ins->operands[i])
        return_value = codegen_call(st, &ins->signature, args, ins->noperands)
        if ins->destvar != NULL:
            set_local_var(st, ins->destvar, return_value)
        free(args)
    elif ins->kind == CfInstructionKind::Constant:
        set_local_var(st, ins->destvar, codegen_constant(st, &ins->constant))
    elif ins->kind == CfInstructionKind::SpecialConstant:
        set_local_var(st, ins->destvar, codegen_special_constant(ins->scname))
    elif ins->kind == CfInstructionKind::StringArray:
        set_local_var(st, ins->destvar, LLVMConstString(ins->strarray.str, ins->strarray.len, True as int))
    elif ins->kind == CfInstructionKind::SizeOf:
        set_local_var(st, ins->destvar, LLVMSizeOf(codegen_type(ins->type)))
    elif ins->kind == CfInstructionKind::AddressOfLocalVar:
        set_local_var(st, ins->destvar, get_pointer_to_local_var(st, ins->operands[0]))
    elif ins->kind == CfInstructionKind::AddressOfGlobalVar:
        set_local_var(st, ins->destvar, LLVMGetNamedGlobal(st->module, ins->globalname))
    elif ins->kind == CfInstructionKind::PtrLoad:
        set_local_var(st, ins->destvar, LLVMBuildLoad(st->builder, get_local_var(st, ins->operands[0]), "ptr_load"))
    elif ins->kind == CfInstructionKind::PtrStore:
        LLVMBuildStore(st->builder, get_local_var(st, ins->operands[1]), get_local_var(st, ins->operands[0]))
    elif ins->kind == CfInstructionKind::PtrToInt64:
        set_local_var(st, ins->destvar, LLVMBuildPtrToInt(st->builder, get_local_var(st, ins->operands[0]), LLVMInt64Type(), "ptr_as_long"))
    elif ins->kind == CfInstructionKind::Int64ToPtr:
        set_local_var(st, ins->destvar, LLVMBuildIntToPtr(st->builder, get_local_var(st, ins->operands[0]), codegen_type(ins->destvar->type), "long_as_ptr"))
    elif ins->kind == CfInstructionKind::PtrClassField:
        classtype = ins->operands[0]->type->value_type
        assert classtype->kind == TypeKind::Class
        f = classtype->classdata.fields
        while strcmp(f->name, ins->fieldname) != 0:
            f++
            assert f < &classtype->classdata.fields[classtype->classdata.nfields]

        val = LLVMBuildStructGEP2(st->builder, codegen_type(classtype), get_local_var(st, ins->operands[0]), f->union_id, ins->fieldname)
        # This cast is needed in two cases:
        #  * All pointers are i8* in structs so we can do self-referencing classes.
        #  * This is how unions work.
        val = LLVMBuildBitCast(st->builder, val, LLVMPointerType(codegen_type(f->type), 0), "struct_member_cast")
        set_local_var(st, ins->destvar, val)
    elif ins->kind == CfInstructionKind::PtrMemsetToZero:
        size = LLVMSizeOf(codegen_type(ins->operands[0]->type->value_type))
        LLVMBuildMemSet(st->builder, get_local_var(st, ins->operands[0]), LLVMConstInt(LLVMInt8Type(), 0, False as int), size, 0)
    elif ins->kind == CfInstructionKind::PtrAddInt:
        ptr_var = get_local_var(st, ins->operands[0])
        int_var = get_local_var(st, ins->operands[1])
        set_local_var(st, ins->destvar, LLVMBuildGEP(st->builder, ptr_var, &int_var, 1, "ptr_add_int"))
    elif ins->kind == CfInstructionKind::NumCast:
        from = ins->operands[0]->type
        to = ins->destvar->type
        assert is_number_type(from) and is_number_type(to)

        if is_integer_type(from) and is_integer_type(to):
            # Examples:
            #  signed 8-bit 0xFF (-1) --> 16-bit 0xFFFF (-1 or max value)
            #  unsigned 8-bit 0xFF (255) --> 16-bit 0x00FF (255)
            set_local_var(st, ins->destvar, LLVMBuildIntCast2(st->builder, get_local_var(st, ins->operands[0]), codegen_type(to), (from->kind == TypeKind::SignedInteger) as int, "int_cast"))
        elif is_integer_type(from) and to->kind == TypeKind::FloatingPoint:
            # integer --> double / float
            if from->kind == TypeKind::SignedInteger:
                set_local_var(st, ins->destvar, LLVMBuildSIToFP(st->builder, get_local_var(st, ins->operands[0]), codegen_type(to), "cast"))
            else:
                set_local_var(st, ins->destvar, LLVMBuildUIToFP(st->builder, get_local_var(st, ins->operands[0]), codegen_type(to), "cast"))
        elif from->kind == TypeKind::FloatingPoint and is_integer_type(to):
            if to->kind == TypeKind::SignedInteger:
                set_local_var(st, ins->destvar, LLVMBuildFPToSI(st->builder, get_local_var(st, ins->operands[0]), codegen_type(to), "cast"))
            else:
                set_local_var(st, ins->destvar, LLVMBuildFPToUI(st->builder, get_local_var(st, ins->operands[0]), codegen_type(to), "cast"))
        elif from->kind == TypeKind::FloatingPoint and to->kind == TypeKind::FloatingPoint:
            set_local_var(st, ins->destvar, LLVMBuildFPCast(st->builder, get_local_var(st, ins->operands[0]), codegen_type(to), "cast"))
        else:
            assert False
    elif ins->kind == CfInstructionKind::BoolNegate:
        set_local_var(st, ins->destvar, LLVMBuildXor(st->builder, get_local_var(st, ins->operands[0]), LLVMConstInt(LLVMInt1Type(), 1, False as int), "bool_negate"))
    elif ins->kind == CfInstructionKind::PtrCast:
        set_local_var(st, ins->destvar, LLVMBuildBitCast(st->builder, get_local_var(st, ins->operands[0]), codegen_type(ins->destvar->type), "ptr_cast"))
    elif ins->kind == CfInstructionKind::VarCpy or ins->kind == CfInstructionKind::Int32ToEnum or ins->kind == CfInstructionKind::EnumToInt32:
        set_local_var(st, ins->destvar, get_local_var(st, ins->operands[0]))
    elif ins->kind == CfInstructionKind::NumAdd or ins->kind == CfInstructionKind::NumSub or ins->kind == CfInstructionKind::NumMul or ins->kind == CfInstructionKind::NumDiv or ins->kind == CfInstructionKind::NumMod:
        codegen_arithmetic_instruction(st, ins)
    elif ins->kind == CfInstructionKind::NumEq:
        if is_integer_type(ins->operands[0]->type):
            set_local_var(st, ins->destvar, LLVMBuildICmp(st->builder, LLVMIntPredicate::EQ, get_local_var(st, ins->operands[0]), get_local_var(st, ins->operands[1]), "num_eq"))
        else:
            set_local_var(st, ins->destvar, LLVMBuildFCmp(st->builder, LLVMRealPredicate::OEQ, get_local_var(st, ins->operands[0]), get_local_var(st, ins->operands[1]), "num_eq"))
    elif ins->kind == CfInstructionKind::NumLt:
        if ins->operands[0]->type->kind == TypeKind::UnsignedInteger and ins->operands[1]->type->kind == TypeKind::UnsignedInteger:
            set_local_var(st, ins->destvar, LLVMBuildICmp(st->builder, LLVMIntPredicate::ULT, get_local_var(st, ins->operands[0]), get_local_var(st, ins->operands[1]), "num_lt"))
        elif is_integer_type(ins->operands[0]->type) and is_integer_type(ins->operands[1]->type):
            set_local_var(st, ins->destvar, LLVMBuildICmp(st->builder, LLVMIntPredicate::SLT, get_local_var(st, ins->operands[0]), get_local_var(st, ins->operands[1]), "num_lt"))
        else:
            set_local_var(st, ins->destvar, LLVMBuildFCmp(st->builder, LLVMRealPredicate::OLT, get_local_var(st, ins->operands[0]), get_local_var(st, ins->operands[1]), "num_lt"))
    else:
        assert False


def find_block(cfg: CfGraph*, b: CfBlock*) -> int:
    for i = 0; i < cfg->n_all_blocks; i++:
        if cfg->all_blocks[i] == b:
            return i
    assert False


def codegen_call_to_the_special_startup_function(st: State*) -> None:
    if WINDOWS or MACOS or NETBSD:
        functype = LLVMFunctionType(LLVMVoidType(), NULL, 0, False as int)
        func = LLVMAddFunction(st->module, "_jou_startup", functype)
        LLVMBuildCall2(st->builder, functype, func, NULL, 0, "")


def codegen_function_or_method_def(st: State*, cfg: CfGraph*) -> None:
    st->cfvars = cfg->locals
    st->cfvars_end = &cfg->locals[cfg->nlocals]
    st->llvm_locals = malloc(sizeof(st->llvm_locals[0]) * cfg->nlocals)

    llvm_func = codegen_function_or_method_decl(st, &cfg->signature)

    blocks: LLVMBasicBlock** = malloc(sizeof(blocks[0]) * cfg->n_all_blocks)
    for i = 0; i < cfg->n_all_blocks; i++:
        name: byte[50]
        sprintf(name, "block%d", i)
        blocks[i] = LLVMAppendBasicBlock(llvm_func, name)

    assert cfg->all_blocks[0] == &cfg->start_block
    LLVMPositionBuilderAtEnd(st->builder, blocks[0])

    if get_self_class(&cfg->signature) == NULL and strcmp(cfg->signature.name, "main") == 0:
        # Insert special code at start of main()
        codegen_call_to_the_special_startup_function(st)

    # Allocate stack space for local variables at start of function.
    return_value: LLVMValue* = NULL
    for i = 0; i < cfg->nlocals; i++:
        v = cfg->locals[i]
        st->llvm_locals[i] = LLVMBuildAlloca(st->builder, codegen_type(v->type), v->name)
        if strcmp(v->name, "return") == 0:
            return_value = st->llvm_locals[i]

    # Place arguments into the first n local variables.
    for i = 0; i < cfg->signature.nargs; i++:
        set_local_var(st, cfg->locals[i], LLVMGetParam(llvm_func, i))

    for i = 0; i < cfg->n_all_blocks; i++:
        b = &cfg->all_blocks[i]
        LLVMPositionBuilderAtEnd(st->builder, blocks[i])

        for ins = (*b)->instructions; ins < &(*b)->instructions[(*b)->ninstructions]; ins++:
            codegen_instruction(st, ins)

        if *b == &cfg->end_block:
            assert (*b)->ninstructions == 0
            # The "return" variable may have been deleted as unused.
            # In that case return_value is NULL but signature.returntype isn't.
            if return_value != NULL:
                LLVMBuildRet(st->builder, LLVMBuildLoad(st->builder, return_value, "return_value"))
            elif cfg->signature.returntype != NULL or cfg->signature.is_noreturn:
                LLVMBuildUnreachable(st->builder)
            else:
                LLVMBuildRetVoid(st->builder)
        elif (*b)->iftrue != NULL and (*b)->iffalse != NULL:
            if (*b)->iftrue == (*b)->iffalse:
                LLVMBuildBr(st->builder, blocks[find_block(cfg, (*b)->iftrue)])
            else:
                assert (*b)->branchvar != NULL
                LLVMBuildCondBr(
                    st->builder,
                    get_local_var(st, (*b)->branchvar),
                    blocks[find_block(cfg, (*b)->iftrue)],
                    blocks[find_block(cfg, (*b)->iffalse)])
        elif (*b)->iftrue == NULL and (*b)->iffalse == NULL:
            LLVMBuildUnreachable(st->builder)
        else:
            assert False

    free(blocks)
    free(st->llvm_locals)


def codegen(cfgfile: CfGraphFile*, ft: FileTypes*) -> LLVMModule*:
    st = State{
        module = LLVMModuleCreateWithName(cfgfile->filename),
        builder = LLVMCreateBuilder(),
    }

    LLVMSetTarget(st.module, target.triple)
    LLVMSetDataLayout(st.module, target.data_layout)

    for v = ft->globals; v < &ft->globals[ft->nglobals]; v++:
        t = codegen_type(v->type)
        globalptr = LLVMAddGlobal(st.module, t, v->name)
        if v->defined_in_current_file:
            LLVMSetInitializer(globalptr, LLVMConstNull(t))

    for g = cfgfile->graphs; g < &cfgfile->graphs[cfgfile->ngraphs]; g++:
        codegen_function_or_method_def(&st, *g)

    LLVMDisposeBuilder(st.builder)
    return st.module
