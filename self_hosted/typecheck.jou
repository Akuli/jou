# Type checking is split into several stages:
#    1. Create types. After this, classes defined in Jou exist, but
#       they are opaque and contain no members. Enums exist and contain
#       their members (although it doesn't really matter whether enum
#       members are handled in stage 1 or 2).
#    2. Check signatures, global variables and class bodies, without
#       checking bodies of methods. This stage assumes that all types
#       exist, but doesn't need to know what fields each class has.
#    3. Check function and method bodies.
#
# The goal of this design is to make cyclic imports possible. At each
# stage, we don't need the results from the same stage, only from
# previous stages. This means that cyclic imports "just work" if we do
# each stage on all files before moving on to the next stage.

from "stdlib/io.jou" import printf
from "stdlib/str.jou" import strcmp, strlen, sprintf
from "stdlib/mem.jou" import malloc, realloc
from "./ast.jou" import (
    AstExpression, AstType, AstTypeKind, AstFile, AstSignature, AstToplevelStatementKind,
)
from "./types.jou" import Type, Signature, int_type, bool_type, long_type, byte_type
from "./errors_and_warnings.jou" import assert, fail

# Suppose file A imports file B.
#   - Type checking file B produces an ExportSymbol that matches the import in file A.
#   - Before the next type checking stage, the ExportSymbol is added to file A's type context.
#   - During the next stage, file A can use the imported symbol.

enum ExportSymbolKind:
    Function
    # TODO: exporting types, exporting global variables

class ExportSymbol:
    kind: ExportSymbolKind
    name: byte[100]

    # TODO: union
    signature: Signature    # ExportSymbolKind::Function

class ExpressionTypes:
    expr: AstExpression*
    type: Type*
    next: ExpressionTypes*  # TODO: switch to more efficient structure than linked list

# There's supposed to be one of these for each Jou file.
class TypeChecker:
    # Types of all expressions in the file except calls to "-> void" functions.
    # Filled during stage 3.
    expr_types: ExpressionTypes*

    # Includes imported and defined functions.
    functions: Signature*
    nfunctions: int

    # TODO: implement
    #def typecheck_stage1_create_types(ctx: TypeContext*, file: AstFile*) -> ExportSymbol*:
    #    assert(False)

    def type_from_ast(self, ast_type: AstType*) -> Type*:
        result = self->type_or_void_from_ast(ast_type)
        if result == NULL:
            fail(ast_type->location, "'void' cannot be used here because it is not a type")
        return result

    def type_or_void_from_ast(self, ast_type: AstType*) -> Type*:
        if ast_type->kind == AstTypeKind::Named:
            if strcmp(&ast_type->name[0], "int") == 0:
                return int_type
            if strcmp(&ast_type->name[0], "long") == 0:
                return long_type
            if strcmp(&ast_type->name[0], "byte") == 0:
                return byte_type
            if strcmp(&ast_type->name[0], "bool") == 0:
                return &bool_type
            # TODO: float, double
            if strcmp(&ast_type->name[0], "void") == 0:
                return NULL

            message: byte* = malloc(strlen(&ast_type->name[0]) + 100)
            sprintf(message, "there is no type named '%s'", &ast_type->name[0])
            fail(ast_type->location, message)

        if ast_type->kind == AstTypeKind::Pointer:
            return self->type_from_ast(ast_type->value_type)->get_pointer_type()

        ast_type->print(True)
        printf("\n")
        assert(False)  # TODO
        return NULL  # never runs, but silences compiler warning

    def handle_signature(self, astsig: AstSignature*) -> Signature:
        printf("Handle sig:\n")
        astsig->print()
        sig = Signature{
            function_or_method_name = astsig->funcname,
            nargs = astsig->nargs,
            takes_varargs = astsig->takes_varargs,
            return_type = self->type_or_void_from_ast(&astsig->return_type),
        }

        sig.argnames = malloc(sizeof sig.argnames[0] * sig.nargs)
        for i = 0; i < sig.nargs; i++:
            sig.argnames[i] = astsig->args[i].name

        sig.argtypes = malloc(sizeof sig.argtypes[0] * sig.nargs)
        for i = 0; i < sig.nargs; i++:
            sig.argtypes[i] = self->type_from_ast(&astsig->args[i].type)

        return sig

    # Returned array is terminated by ExportSymbol with empty name.
    def typecheck_stage2_signatures_globals_structbodies(self, ast_file: AstFile*) -> ExportSymbol*:
        exports: ExportSymbol* = NULL
        nexports = 0

        for i = 0; i < ast_file->body_len; i++:
            ts = &ast_file->body[i]
            # TODO: get rid of declare/define copy pasta
            if ts->kind == AstToplevelStatementKind::FunctionDeclaration:
                # TODO: terrible hack: skip functions that use FILE, such as fopen()
                # Will be no longer needed once struct FILE works.
                if ts->decl_signature.funcname[0] == 'f' or strcmp(&ts->decl_signature.funcname[0], "rewind") == 0:
                    continue
                exports = realloc(exports, sizeof exports[0] * (nexports + 1))
                exports[nexports++] = ExportSymbol{
                    kind = ExportSymbolKind::Function,
                    name = ts->decl_signature.funcname,
                    signature = self->handle_signature(&ts->decl_signature),
                }
            if ts->kind == AstToplevelStatementKind::FunctionDefinition:
                exports = realloc(exports, sizeof exports[0] * (nexports + 1))
                exports[nexports++] = ExportSymbol{
                    kind = ExportSymbolKind::Function,
                    name = ts->funcdef.signature.funcname,
                    signature = self->handle_signature(&ts->funcdef.signature),
                }

        exports = realloc(exports, sizeof exports[0] * (nexports + 1))
        exports[nexports] = ExportSymbol{}
        return exports

#
#def main() -> int:
#    init_types()
#    printf("Hi\n")
#    return 0
