# Type checking is split into several stages:
#    1. Create types. After this, classes defined in Jou exist, but
#       they are opaque and contain no members. Enums exist and contain
#       their members (although it doesn't really matter whether enum
#       members are handled in stage 1 or 2).
#    2. Check signatures, global variables and class bodies, without
#       checking bodies of methods. This stage assumes that all types
#       exist, but doesn't need to know what fields each class has.
#    3. Check function and method bodies.
#
# The goal of this design is to make cyclic imports possible. At each
# stage, we don't need the results from the same stage, only from
# previous stages. This means that cyclic imports "just work" if we do
# each stage on all files before moving on to the next stage.

import "stdlib/io.jou"
import "stdlib/str.jou"
import "stdlib/mem.jou"
import "./ast.jou"
import "./types.jou"
import "./errors_and_warnings.jou"


def can_cast_implicitly(from: Type*, to: Type*) -> bool:
    return from == to or (
        # Cast to bigger integer types implicitly, unless it is signed-->unsigned.
        from->is_integer_type()
        and to->is_integer_type()
        and from->size_in_bits < to->size_in_bits
        and not (from->kind == TypeKind::SignedInteger and to->kind == TypeKind::SignedInteger)
#    ) or (
#        # Cast to bigger floating-point type.
#        from == floatType and to == doubleType
#    ) or (
#        # Cast from any integer type to float/double.
#        is_integer_type(from) and to->kind == TYPE_FLOATING_POINT
#    ) or (
#        # Cast implicitly between void pointer and any other pointer.
#        (from->kind == TYPE_POINTER and to->kind == TYPE_VOID_POINTER)
#        or (from->kind == TYPE_VOID_POINTER and to->kind == TYPE_POINTER)
    )

# Implicit casts are used in many places, e.g. function arguments.
#
# When you pass an argument of the wrong type, it's best to give an error message
# that says so, instead of some generic "expected type foo, got object of type bar"
# kind of message.
#
# The template can contain "<from>" and "<to>". They will be substituted with names
# of types. We cannot use printf() style functions because the arguments can be in
# any order.
def fail_with_implicit_cast_error(location: Location, template: byte*, from: Type*, to: Type*) -> void:
    n = 0
    for i = 0; template[i] != '\0'; i++:
        if template[i] == '<':
            n++

    message: byte* = malloc(sizeof(from->name)*n + strlen(template) + 1)
    message[0] = '\0'
    while *template != '\0':
        if starts_with(template, "<from>"):
            template = &template[6]
            strcat(message, &from->name[0])
        elif starts_with(template, "<to>"):
            template = &template[4]
            strcat(message, &to->name[0])
        else:
            s = [*template++, '\0']
            strcat(message, &s[0])

    fail(location, message)


# To understand the purpose of ExportSymbol, suppose file A imports file B.
#   - Type checking file B produces an ExportSymbol that matches the import in file A.
#   - Before the next type checking stage, the ExportSymbol is added to file A's types.
#   - During the next stage, file A can use the imported symbol.

enum ExportSymbolKind:
    Function
    # TODO: exporting types, exporting global variables

class ExportSymbol:
    kind: ExportSymbolKind
    name: byte[100]

    # TODO: union
    signature: Signature    # ExportSymbolKind::Function

class ExpressionTypes:
    expression: AstExpression*
    original_type: Type*
    implicit_cast_type: Type*  # NULL if no implicit casting is needed
    next: ExpressionTypes*  # TODO: switch to more efficient structure than linked list?

    def do_implicit_cast(self, to: Type*, error_location: Location, error_template: byte*) -> void:
        assert self->implicit_cast_type == NULL  # This cannot be called multiple times

        from = self->original_type
        if from == to:
            return

        # Passing in NULL for error_template can be used to force a cast to happen.
        if error_template != NULL and not can_cast_implicitly(from, to):
            fail_with_implicit_cast_error(error_location, error_template, from, to)

        self->implicit_cast_type = to

class LocalVariable:
    name: byte[100]
    type: Type*
    next: LocalVariable*  # TODO: switch to more efficient structure than linked list?

class FunctionOrMethodTypes:
    signature: Signature
    expression_types: ExpressionTypes*
    local_vars: LocalVariable*

    def get_expression_types(self, expr: AstExpression*) -> ExpressionTypes*:
        for et = self->expression_types; et != NULL; et = et->next:
            if et->expression == expr:
                return et
        return NULL

    def find_local_var(self, name: byte*) -> LocalVariable*:
        for v = self->local_vars; v != NULL; v = v->next:
            if strcmp(&v->name[0], name) == 0:
                return v
        return NULL

# All type information for a Jou file. This is initially empty, and is filled during each stage of type checking.
class FileTypes:
    # Includes imported and defined functions.
    all_functions: Signature*
    n_all_functions: int

    defined_functions: FunctionOrMethodTypes*
    n_defined_functions: int

    def add_imported_symbol(self, symbol: ExportSymbol*) -> void:
        assert symbol->kind == ExportSymbolKind::Function
        self->all_functions = realloc(self->all_functions, sizeof self->all_functions[0] * (self->n_all_functions + 1))
        self->all_functions[self->n_all_functions++] = symbol->signature.copy()

    def find_function(self, name: byte*) -> Signature*:
        for i = 0; i < self->n_all_functions; i++:
            if strcmp(&self->all_functions[i].name[0], name) == 0:
                return &self->all_functions[i]
        return NULL

    def find_defined_function(self, name: byte*) -> FunctionOrMethodTypes*:
        for i = 0; i < self->n_defined_functions; i++:
            if strcmp(&self->defined_functions[i].signature.name[0], name) == 0:
                return &self->defined_functions[i]
        return NULL

# TODO: implement
#def typecheck_stage1_create_types(ft: FileTypes*, file: AstFile*) -> ExportSymbol*:
#    assert False

def type_from_ast(ft: FileTypes*, ast_type: AstType*) -> Type*:
    if ast_type->is_void():
        fail(ast_type->location, "'void' cannot be used here because it is not a type")
    if ast_type->is_noreturn():
        fail(ast_type->location, "'noreturn' cannot be used here because it is not a type")

    if ast_type->kind == AstTypeKind::Named:
        if strcmp(&ast_type->name[0], "int") == 0:
            return int_type
        if strcmp(&ast_type->name[0], "long") == 0:
            return long_type
        if strcmp(&ast_type->name[0], "byte") == 0:
            return byte_type
        if strcmp(&ast_type->name[0], "bool") == 0:
            return &bool_type
        # TODO: float, double

        message: byte* = malloc(strlen(&ast_type->name[0]) + 100)
        sprintf(message, "there is no type named '%s'", &ast_type->name[0])
        fail(ast_type->location, message)

    if ast_type->kind == AstTypeKind::Pointer:
        if ast_type->value_type->is_void():
            return &void_ptr_type
        return type_from_ast(ft, ast_type->value_type)->get_pointer_type()

    ast_type->print(True)
    printf("\n")
    assert False  # TODO

def handle_signature(ft: FileTypes*, astsig: AstSignature*) -> Signature:
    sig = Signature{
        name = astsig->name,
        nargs = astsig->nargs,
        takes_varargs = astsig->takes_varargs,
    }

    if astsig->return_type.is_void() or astsig->return_type.is_noreturn():
        sig.return_type = NULL
    else:
        sig.return_type = type_from_ast(ft, &astsig->return_type)

    sig.argnames = malloc(sizeof sig.argnames[0] * sig.nargs)
    for i = 0; i < sig.nargs; i++:
        sig.argnames[i] = astsig->args[i].name

    sig.argtypes = malloc(sizeof sig.argtypes[0] * sig.nargs)
    for i = 0; i < sig.nargs; i++:
        sig.argtypes[i] = type_from_ast(ft, &astsig->args[i].type)

    return sig

# Returned array is terminated by ExportSymbol with empty name.
def typecheck_stage2_signatures_globals_structbodies(ft: FileTypes*, ast_file: AstFile*) -> ExportSymbol*:
    exports: ExportSymbol* = NULL
    nexports = 0

    for i = 0; i < ast_file->body_len; i++:
        ts = &ast_file->body[i]
        if ts->kind == AstToplevelStatementKind::Function:
            # TODO: terrible hack: skip functions that use FILE, such as fopen()
            # Will be no longer needed once struct FILE works.
            if ts->function.body.nstatements == 0 and (
                ts->function.signature.name[0] == 'f'
                or strcmp(&ts->function.signature.name[0], "rewind") == 0
            ):
                continue

            sig = handle_signature(ft, &ts->function.signature)
            ft->all_functions = realloc(ft->all_functions, sizeof ft->all_functions[0] * (ft->n_all_functions + 1))
            ft->all_functions[ft->n_all_functions++] = sig.copy()
            exports = realloc(exports, sizeof exports[0] * (nexports + 1))
            exports[nexports++] = ExportSymbol{
                kind = ExportSymbolKind::Function,
                name = sig.name,
                signature = sig,
            }

    exports = realloc(exports, sizeof exports[0] * (nexports + 1))
    exports[nexports] = ExportSymbol{}
    return exports


def plural_s(n: int) -> byte*:
    if n == 1:
        return ""
    return "s"

def nth(n: int) -> byte*:
    first_few = [NULL as byte*, "first", "second", "third", "fourth", "fifth", "sixth"]
    if n < sizeof first_few / sizeof first_few[0]:
        return strdup(first_few[n])

    result = malloc(100)
    sprintf(result, "%dth", n)
    return result


class Stage3TypeChecker:
    file_types: FileTypes*
    current_function_or_method: FunctionOrMethodTypes*

    def add_local_var(self, name: byte*, type: Type*) -> LocalVariable*:
        v: LocalVariable* = calloc(1, sizeof *v)
        assert strlen(name) < sizeof v->name
        strcpy(&v->name[0], name)
        v->type = type

        dest_pointer = &self->current_function_or_method->local_vars
        while *dest_pointer != NULL:
            dest_pointer = &(*dest_pointer)->next

        *dest_pointer = v
        return v

    def find_var(self, name: byte*) -> Type*:
        local_var = self->current_function_or_method->find_local_var(name)
        if local_var != NULL:
            return local_var->type
        # TODO: check global vars (they don't exist yet)
        return NULL

    def do_function_call(self, call: AstCall*) -> Type*:
        message: byte[500]

        signature = self->file_types->find_function(&call->called_name[0])
        if signature == NULL:
            snprintf(&message[0], sizeof message, "function '%s' not found", &call->called_name[0])
            fail(call->location, &message[0])

        signature_string = signature->to_string(False)

        if (
            call->nargs < signature->nargs
            or (call->nargs > signature->nargs and not signature->takes_varargs)
        ):
            snprintf(
                &message[0], sizeof message,
                "function %s takes %d argument%s, but it was called with %d argument%s",
                signature_string,
                signature->nargs,
                plural_s(signature->nargs),
                call->nargs,
                plural_s(call->nargs),
            )
            fail(call->location, &message[0])

        for i = 0; i < signature->nargs; i++:
            # This is a common error, so worth spending some effort to get a good error message.
            tmp = nth(i+1)
            snprintf(
                &message[0], sizeof message,
                "%s argument of function %s should have type <to>, not <from>",
                tmp, signature_string)
            free(tmp)
            self->do_expression_and_implicit_cast(&call->args[i], signature->argtypes[i], &message[0])

        for i = signature->nargs; i < call->nargs; i++:
            # This code runs for varargs, e.g. the things to format in printf().
            types = self->do_expression(&call->args[i])

            # TODO: do something to arrays

            if (
                (types->original_type->is_integer_type() and types->original_type->size_in_bits < 32)
                or types->original_type == &bool_type
            ):
                # Add implicit cast to signed int, just like in C.
                types->do_implicit_cast(int_type, Location{}, NULL)

            # TODO: cast float to double implicitly

        free(signature_string)
        return signature->return_type

    def do_expression_maybe_void(self, expression: AstExpression*) -> ExpressionTypes*:
        result: Type*

        if expression->kind == AstExpressionKind::String:
            result = byte_type->get_pointer_type()
        elif expression->kind == AstExpressionKind::Byte:
            result = byte_type
        elif expression->kind == AstExpressionKind::Int:
            result = int_type
        elif expression->kind == AstExpressionKind::Long:
            result = long_type
        elif expression->kind == AstExpressionKind::FunctionCall:
            result = self->do_function_call(&expression->call)
            if result == NULL:
                return NULL
        elif expression->kind == AstExpressionKind::GetVariable:
            result = self->find_var(&expression->varname[0])
            if result == NULL:
                message: byte[200]
                snprintf(&message[0], sizeof message, "no variable named '%s'", &expression->varname[0])
                fail(expression->location, &message[0])
        else:
            printf("*** %d\n", expression->kind as int)
            assert False

        p: ExpressionTypes* = malloc(sizeof *p)
        *p = ExpressionTypes{
            expression = expression,
            original_type = result,
            next = self->current_function_or_method->expression_types,
        }
        self->current_function_or_method->expression_types = p
        return p

    def do_expression(self, expression: AstExpression*) -> ExpressionTypes*:
        types = self->do_expression_maybe_void(expression)
        if types == NULL:
            assert expression->kind == AstExpressionKind::FunctionCall
            name = &expression->call.called_name[0]
            message = malloc(strlen(name) + 100)
            sprintf(message, "function '%s' does not return a value", name)
            fail(expression->location, message)
        return types

    def do_expression_and_implicit_cast(
        self,
        expression: AstExpression*,
        cast_type: Type*,
        error_message_template: byte*,
    ) -> ExpressionTypes*:
        types = self->do_expression(expression)
        types->do_implicit_cast(cast_type, expression->location, error_message_template)
        return types

    def do_statement(self, statement: AstStatement*) -> void:
        if statement->kind == AstStatementKind::ExpressionStatement:
            self->do_expression_maybe_void(&statement->expression)

        elif statement->kind == AstStatementKind::Return:
            sig = &self->current_function_or_method->signature

            # TODO: check for noreturn functions

            msg: byte[500]

            if statement->return_value != NULL and sig->return_type == NULL:
                snprintf(
                    &msg[0], sizeof msg,
                    "%s '%s' cannot return a value because it was defined with '-> void'",
                    sig->function_or_method(), &sig->name[0],
                )
                fail(statement->location, &msg[0])
            if statement->return_value == NULL and sig->return_type != NULL:
                snprintf(
                    &msg[0], sizeof msg,
                    "%s '%s' must return a value because it was defined with '-> %s'",
                    sig->function_or_method(), &sig->name[0], &sig->return_type->name[0],
                )
                fail(statement->location, &msg[0])

            if statement->return_value != NULL:
                cast_error_msg: byte[500]
                snprintf(
                    &cast_error_msg[0], sizeof cast_error_msg,
                    "attempting to return a value of type <from> from %s '%s' defined with '-> <to>'",
                    sig->function_or_method(), &sig->name[0],
                )
                self->do_expression_and_implicit_cast(
                    statement->return_value, sig->return_type, &cast_error_msg[0]
                )

        elif statement->kind == AstStatementKind::Assign:
            target_expr = &statement->assignment.target
            value_expr = &statement->assignment.value

            if (
                target_expr->kind == AstExpressionKind::GetVariable
                and self->find_var(&target_expr->varname[0]) == NULL
            ):
                # Making a new variable. Use the type of the value being assigned.
                types = self->do_expression(value_expr)
                self->add_local_var(&target_expr->varname[0], types->original_type)
            else:
                # Convert value to the type of an existing variable or other assignment target.
                #ensure_can_take_address(targetexpr, "cannot assign to %s")

                # This is a common error, so try to produce a helpful error message.
                if target_expr->kind == AstExpressionKind::Dereference:
                    error_template = "cannot place a value of type <from> into a pointer of type <to>*"
                else:
                    # TODO: improve this error message.
                    # See short_expression_description() in the other compiler.
                    error_template = "cannot assign a value of type FROM to target of type TO"

                target_types = self->do_expression(target_expr)
                self->do_expression_and_implicit_cast(value_expr, target_types->original_type, error_template)

        else:
            assert False

    def typecheck_body(self, body: AstBody*) -> void:
        for i = 0; i < body->nstatements; i++:
            self->do_statement(&body->statements[i])


def typecheck_stage3_function_and_method_bodies(file_types: FileTypes*, ast_file: AstFile*) -> void:
    checker = Stage3TypeChecker{file_types = file_types}
    for i = 0; i < ast_file->body_len; i++:
        ts = &ast_file->body[i]
        if ts->kind != AstToplevelStatementKind::Function or ts->function.body.nstatements == 0:
            continue

        sig = file_types->find_function(&ts->function.signature.name[0])
        assert sig != NULL

        assert checker.current_function_or_method == NULL
        file_types->defined_functions = realloc(file_types->defined_functions, (file_types->n_defined_functions + 1) * sizeof file_types->defined_functions[0])
        checker.current_function_or_method = &file_types->defined_functions[file_types->n_defined_functions++]
        *checker.current_function_or_method = FunctionOrMethodTypes{signature = sig->copy()}

        for k = 0; k < sig->nargs; k++:
            checker.add_local_var(&sig->argnames[k][0], sig->argtypes[k])

        checker.typecheck_body(&ts->function.body)
        checker.current_function_or_method = NULL
