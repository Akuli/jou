#include "jou_compiler.h"
#include <stdnoreturn.h>

static const Type *find_type(const FileTypes *ft, const char *name)
{
    for (struct TypeAndUsedPtr *t = ft->types.ptr; t < End(ft->types); t++) {
        if (!strcmp(t->type->name, name)) {
            if (t->usedptr)
                *t->usedptr = true;
            return t->type;
        }
    }
    return NULL;
}

static const Signature *find_function(const FileTypes *ft, const char *name)
{
    for (struct SignatureAndUsedPtr *f = ft->functions.ptr; f < End(ft->functions); f++) {
        if (!strcmp(f->signature.name, name)) {
            if (f->usedptr)
                *f->usedptr = true;
            return &f->signature;
        }
    }
    return NULL;
}

static const Signature *find_method(const Type *selfclass, const char *name)
{
    if (selfclass->kind != TypeKind::Class)
        return NULL;
    for (const Signature *m = selfclass->data.classdata.methods.ptr; m < End(selfclass->data.classdata.methods); m++)
        if (!strcmp(m->name, name))
            return m;
    return NULL;
}

static const Signature *find_function_or_method(const FileTypes *ft, const Type *selfclass, const char *name)
{
    if (selfclass)
        return find_method(selfclass, name);
    else
        return find_function(ft, name);
}

static const LocalVariable *find_local_var(const FileTypes *ft, const char *name)
{
    if (ft->current_fom_types)
        for (LocalVariable **var = ft->current_fom_types->locals.ptr; var < End(ft->current_fom_types->locals); var++)
            if (!strcmp((*var)->name, name))
                return *var;
    return NULL;
}

static const Type *find_any_var(const FileTypes *ft, const char *name)
{
    if (get_special_constant(name) != -1)
        return boolType;
    if (ft->current_fom_types)
        for (LocalVariable **var = ft->current_fom_types->locals.ptr; var < End(ft->current_fom_types->locals); var++)
            if (!strcmp((*var)->name, name))
                return (*var)->type;
    for (GlobalVariable *var = ft->globals.ptr; var < End(ft->globals); var++)
        if (!strcmp(var->name, name)) {
            if (var->usedptr)
                *var->usedptr = true;
            return var->type;
        }
    return NULL;
}

static const char *short_type_description(const Type *t)
{
    switch(t->kind) {
        case TypeKind::OpaqueClass:
        case TypeKind::Class:
            return "a class";
        case TypeKind::Enum:
            return "an enum";
        case TypeKind::VoidPointer:
        case TypeKind::Pointer:
            return "a pointer type";
        case TypeKind::SignedInteger:
        case TypeKind::UnsignedInteger:
        case TypeKind::FloatingPoint:
            return "a number type";
        case TypeKind::Array:
            return "an array type";
        case TypeKind::Bool:
            return "the built-in bool type";
    }
}

ExportSymbol *typecheck_stage1_create_types(FileTypes *ft, const AstFile *ast)
{
    List(ExportSymbol) exports = {0};

    for (int i = 0; i < ast->body.nstatements; i++) {
        const AstStatement *stmt = &ast->body.statements[i];
        Type *t;
        char name[100];

        switch(stmt->kind) {
        case AstStatementKind::DefineClass:
            safe_strcpy(name, stmt->data.classdef.name);
            t = create_opaque_class(name);
            break;
        case AstStatementKind::DefineEnum:
            safe_strcpy(name, stmt->data.enumdef.name);
            t = create_enum(name, stmt->data.enumdef.nmembers, stmt->data.enumdef.membernames);
            break;
        default:
            continue;
        }

        const Type *existing = find_type(ft, name);
        if (existing)
            fail(stmt->location, "%s named '%s' already exists", short_type_description(existing), name);

        Append(&ft->types, (struct TypeAndUsedPtr){ .type=t, .usedptr=NULL });
        Append(&ft->owned_types, t);

        struct ExportSymbol es = { .kind = ExportSymbolKind::Type, .data.type = t };
        safe_strcpy(es.name, name);
        Append(&exports, es);
    }

    Append(&exports, (ExportSymbol){0});
    return exports.ptr;
}

int evaluate_array_length(const AstExpression *expr)
{
    if (expr->kind == AstExpressionKind::Constant
        && expr->data.constant.kind == ConstantKind::Integer
        && expr->data.constant.data.integer.is_signed
        && expr->data.constant.data.integer.width_in_bits == 32)
    {
        return (int)expr->data.constant.data.integer.value;
    }

    fail(expr->location, "cannot evaluate array length at compile time");
}

static bool is_void(const AstType *t)
{
    return t->kind == AstTypeKind::Named && !strcmp(t->data.name, "void");
}

static bool is_none(const AstType *t)
{
    return t->kind == AstTypeKind::Named && !strcmp(t->data.name, "None");
}

static bool is_noreturn(const AstType *t)
{
    return t->kind == AstTypeKind::Named && !strcmp(t->data.name, "noreturn");
}

static const Type *type_from_ast(const FileTypes *ft, const AstType *asttype)
{
    if (is_void(asttype) || is_none(asttype) || is_noreturn(asttype))
        fail(asttype->location, "'%s' cannot be used here because it is not a type", asttype->data.name);

    const Type *tmp;

    switch(asttype->kind) {
    case AstTypeKind::Named:
        if (!strcmp(asttype->data.name, "short"))
            return shortType;
        if (!strcmp(asttype->data.name, "int"))
            return intType;
        if (!strcmp(asttype->data.name, "long"))
            return longType;
        if (!strcmp(asttype->data.name, "byte"))
            return byteType;
        if (!strcmp(asttype->data.name, "bool"))
            return boolType;
        if (!strcmp(asttype->data.name, "float"))
            return floatType;
        if (!strcmp(asttype->data.name, "double"))
            return doubleType;
        if ((tmp = find_type(ft, asttype->data.name)))
            return tmp;
        fail(asttype->location, "there is no type named '%s'", asttype->data.name);

    case AstTypeKind::Pointer:
        if (is_void(asttype->data.valuetype))
            return voidPtrType;
        return get_pointer_type(type_from_ast(ft, asttype->data.valuetype));

    case AstTypeKind::Array:
        tmp = type_from_ast(ft, asttype->data.valuetype);
        int len = evaluate_array_length(asttype->data.array.len);
        if (len <= 0)
            fail(asttype->data.array.len->location, "array length must be positive");
        return get_array_type(tmp, len);
    }
}

static ExportSymbol handle_global_var(FileTypes *ft, const AstNameTypeValue *vardecl, bool defined_here)
{
    assert(ft->current_fom_types == NULL);  // find_any_var() only finds global vars
    if (find_any_var(ft, vardecl->name))
        fail(vardecl->name_location, "a global variable named '%s' already exists", vardecl->name);

    assert(!vardecl->value);
    GlobalVariable g = {
        .type = type_from_ast(ft, &vardecl->type),
        .defined_in_current_file = defined_here,
    };
    safe_strcpy(g.name, vardecl->name);
    Append(&ft->globals, g);

    ExportSymbol es = { .kind = ExportSymbolKind::GlobalVar, .data.type = g.type };
    safe_strcpy(es.name, g.name);
    return es;
}

static Signature handle_signature(FileTypes *ft, const AstSignature *astsig, const Type *self_class)
{
    if (find_function_or_method(ft, self_class, astsig->name))
        fail(astsig->name_location, "a %s named '%s' already exists", self_class ? "method" : "function", astsig->name);

    Signature sig = { .nargs = astsig->args.len, .takes_varargs = astsig->takes_varargs };
    safe_strcpy(sig.name, astsig->name);

    size_t size = sizeof(sig.argnames[0]) * sig.nargs;
    sig.argnames = malloc(size);
    for (int i = 0; i < sig.nargs; i++)
        safe_strcpy(sig.argnames[i], astsig->args.ptr[i].name);

    sig.argtypes = malloc(sizeof(sig.argtypes[0]) * sig.nargs);  // NOLINT
    for (int i = 0; i < sig.nargs; i++) {
        const Type *argtype;
        if (
            !strcmp(sig.argnames[i], "self")
            && astsig->args.ptr[i].type.kind == AstTypeKind::Named
            && astsig->args.ptr[i].type.data.name[0] == '\0'
        ) {
            // just "self" without a type after it --> default to "self: Foo*" in class Foo
            argtype = get_pointer_type(self_class);
        } else {
            argtype = type_from_ast(ft, &astsig->args.ptr[i].type);
        }

        if (!strcmp(sig.argnames[i], "self") && argtype != self_class && argtype != get_pointer_type(self_class))
        {
            fail(astsig->args.ptr[i].type.location, "type of self must be %s* (default) or %s", self_class->name, self_class->name);
        }

        sig.argtypes[i] = argtype;
    }

    sig.is_noreturn = is_noreturn(&astsig->returntype);
    if (is_none(&astsig->returntype) || is_noreturn(&astsig->returntype))
        sig.returntype = NULL;
    else if (is_void(&astsig->returntype))
        fail(astsig->returntype.location, "void is not a valid return type, use '-> None' if the function does not return a value");
    else
        sig.returntype = type_from_ast(ft, &astsig->returntype);

    if (!self_class && !strcmp(sig.name, "main")) {
        // special main() function checks
        if (sig.returntype != intType)
            fail(astsig->returntype.location, "the main() function must return int");
        if (sig.nargs != 0 && !(
                sig.nargs == 2
                && sig.argtypes[0] == intType
                && sig.argtypes[1] == get_pointer_type(get_pointer_type(byteType))))
        {
            fail(
                astsig->args.ptr[0].type.location,
                "if the main() function takes parameters, it should be defined like this: def main(argc: int, argv: byte**) -> int"
            );
        }
    }

    sig.returntype_location = astsig->returntype.location;

    if (!self_class)
        Append(&ft->functions, (struct SignatureAndUsedPtr){ .signature=copy_signature(&sig), .usedptr=NULL });

    return sig;
}

static void handle_class_members_stage2(FileTypes *ft, const AstClassDef *classdef)
{
    // Previous type-checking stage created an opaque struct.
    Type *type = NULL;
    for (Type **s = ft->owned_types.ptr; s < End(ft->owned_types); s++) {
        if (!strcmp((*s)->name, classdef->name)) {
            type = *s;
            break;
        }
    }
    assert(type);
    assert(type->kind == TypeKind::OpaqueClass);
    type->kind = TypeKind::Class;

    memset(&type->data.classdata, 0, sizeof type->data.classdata);

    int union_id = 0;
    for (const AstClassMember *m = classdef->members.ptr; m < End(classdef->members); m++) {
        switch(m->kind) {
            case AstClassMemberKind::Field:
            {
                struct ClassField f = {
                    .type = type_from_ast(ft, &m->data.field.type),
                    .union_id = union_id++,
                };
                safe_strcpy(f.name, m->data.field.name);
                Append(&type->data.classdata.fields, f);
                break;
            }
            case AstClassMemberKind::Union:
            {
                int uid = union_id++;
                for (struct AstNameTypeValue *ntv = m->data.unionfields.ptr; ntv < End(m->data.unionfields); ntv++) {
                    struct ClassField f = {
                        .type = type_from_ast(ft, &ntv->type),
                        .union_id = uid,
                    };
                    safe_strcpy(f.name, ntv->name);
                    Append(&type->data.classdata.fields, f);
                }
                break;
            }
            case AstClassMemberKind::Method:
            {
                // Don't handle the method body yet: that is a part of stage 3, not stage 2
                Signature sig = handle_signature(ft, &m->data.method.signature, type);
                Append(&type->data.classdata.methods, sig);
                break;
            }
        }
    }
}

ExportSymbol *typecheck_stage2_populate_types(FileTypes *ft, const AstFile *ast)
{
    List(ExportSymbol) exports = {0};

    for (int i = 0; i < ast->body.nstatements; i++) {
        const AstStatement *stmt = &ast->body.statements[i];
        switch(stmt->kind) {
        case AstStatementKind::GlobalVariableDeclaration:
            Append(&exports, handle_global_var(ft, &stmt->data.vardecl, false));
            break;
        case AstStatementKind::GlobalVariableDefinition:
            Append(&exports, handle_global_var(ft, &stmt->data.vardecl, true));
            break;
        case AstStatementKind::Function:
            {
                Signature sig = handle_signature(ft, &stmt->data.function.signature, NULL);
                ExportSymbol es = { .kind = ExportSymbolKind::Function, .data.funcsignature = sig };
                safe_strcpy(es.name, sig.name);
                Append(&exports, es);
            }
            break;
        case AstStatementKind::DefineClass:
            handle_class_members_stage2(ft, &stmt->data.classdef);
            break;
        case AstStatementKind::DefineEnum:
            // Everything done in previous type-checking steps.
            break;
        default:
            assert(0);
        }
    }

    Append(&exports, (ExportSymbol){0});
    return exports.ptr;
}

static LocalVariable *add_variable(FileTypes *ft, const Type *t, const char *name)
{
    LocalVariable *var = calloc(1, sizeof *var);
    var->id = ft->current_fom_types->locals.len;
    var->type = t;

    assert(name);
    assert(!find_local_var(ft, name));
    assert(strlen(name) < sizeof var->name);
    strcpy(var->name, name);

    Append(&ft->current_fom_types->locals, var);
    return var;
}

// Intended for errors. Returned string can be overwritten in next call.
static const char *short_expression_description(const AstExpression *expr)
{
    static char result[200];

    switch(expr->kind) {
    // Imagine "cannot assign to" in front of these, e.g. "cannot assign to a constant"
    case AstExpressionKind::Constant: return "a constant";
    case AstExpressionKind::GetEnumMember: return "an enum member";
    case AstExpressionKind::SizeOf: return "a sizeof expression";
    case AstExpressionKind::FunctionCall: return "a function call";
    case AstExpressionKind::CallMethod: return "a method call";
    case AstExpressionKind::DerefAndCallMethod: return "a method call";
    case AstExpressionKind::BraceInit: return "a newly created instance";
    case AstExpressionKind::Array: return "an array literal";
    case AstExpressionKind::Indexing: return "an indexed value";
    case AstExpressionKind::As: return "the result of a cast";
    case AstExpressionKind::Dereference: return "the value of a pointer";
    case AstExpressionKind::And: return "the result of 'and'";
    case AstExpressionKind::Or: return "the result of 'or'";
    case AstExpressionKind::Not: return "the result of 'not'";

    case AstExpressionKind::GetVariable:
        if (!strcmp(expr->data.varname,"self"))
            return "self";
        if (get_special_constant(expr->data.varname) != -1)
            return "a special constant";
        return "a variable";

    case AstExpressionKind::Add:
    case AstExpressionKind::Sub:
    case AstExpressionKind::Mul:
    case AstExpressionKind::Div:
    case AstExpressionKind::Mod:
    case AstExpressionKind::Neg:
        return "the result of a calculation";

    case AstExpressionKind::Eq:
    case AstExpressionKind::Ne:
    case AstExpressionKind::Gt:
    case AstExpressionKind::Ge:
    case AstExpressionKind::Lt:
    case AstExpressionKind::Le:
        return "the result of a comparison";

    case AstExpressionKind::PreIncrement:
    case AstExpressionKind::PostIncrement:
        return "the result of incrementing a value";

    case AstExpressionKind::PreDecrement:
    case AstExpressionKind::PostDecrement:
        return "the result of decrementing a value";

    case AstExpressionKind::AddressOf:
        snprintf(result, sizeof result, "address of %s", short_expression_description(&expr->data.operands[0]));
        break;

    case AstExpressionKind::GetField:
    case AstExpressionKind::DerefAndGetField:
        snprintf(result, sizeof result, "field '%s'", expr->data.classfield.fieldname);
        break;
    }

    return result;
}

/*
The & operator can't go in front of most expressions.
You can't do &(1 + 2), for example.

The same rules apply to assignments: "foo = bar" is treated as setting the
value of the pointer &foo to bar.

errmsg_template can be e.g. "cannot take address of %s" or "cannot assign to %s"
*/
static void ensure_can_take_address(const FunctionOrMethodTypes *fom, const AstExpression *expr, const char *errmsg_template)
{
    assert(fom != NULL);

    switch(expr->kind) {
    case AstExpressionKind::Dereference:
    case AstExpressionKind::Indexing:  // &foo[bar]
    case AstExpressionKind::DerefAndGetField:  // &foo->bar = foo + offset (it doesn't use &foo)
        return;

    case AstExpressionKind::GetField:
        // &foo.bar = &foo + offset
        {
            // Turn "cannot assign to %s" into "cannot assign to a field of %s".
            // This assumes that errmsg_template is relatively simple, i.e. it only contains one %s somewhere.
            char *newtemplate = malloc(strlen(errmsg_template) + 100);
            sprintf(newtemplate, errmsg_template, "a field of %s");
            ensure_can_take_address(fom, &expr->data.operands[0], newtemplate);
            free(newtemplate);
        }
        return;

    case AstExpressionKind::GetVariable:
        if (get_special_constant(expr->data.varname) != -1)
            goto error;

        // In methods that take self as a pointer, you cannot take address of self
        if (!strcmp(expr->data.varname, "self")) {
            if (fom->signature.argtypes[0]->kind == TypeKind::Pointer)
                goto error;
        }

        return;

    default:
        goto error;
    }

error:
    fail(expr->location, errmsg_template, short_expression_description(expr));
}

/*
Implicit casts are used in many places, e.g. function arguments.

When you pass an argument of the wrong type, it's best to give an error message
that says so, instead of some generic "expected type foo, got object of type bar"
kind of message.

The template can contain "FROM" and "TO". They will be substituted with names
of types. We cannot use printf() style functions because the arguments can be in
any order.
*/
static noreturn void fail_with_implicit_cast_error(
    Location location, const char *template, const Type *from, const Type *to)
{
    assert(template);

    List(char) msg = {0};
    while(*template){
        if (!strncmp(template, "FROM", 4)) {
            AppendStr(&msg, from->name);
            template += 4;
        } else if (!strncmp(template, "TO", 2)) {
            AppendStr(&msg, to->name);
            template += 2;
        } else {
            Append(&msg, template[0]);
            template++;
        }
    }
    fail(location, "%.*s", msg.len, msg.ptr);
}

static bool can_cast_implicitly(const Type *from, const Type *to)
{
    return
        from == to
        || (
            // array to pointer with same item type
            from->kind == TypeKind::Array && to->kind == TypeKind::Pointer && from->data.array.membertype == to->data.valuetype
        ) || (
            // array to void*
            from->kind == TypeKind::Array && to->kind == TypeKind::VoidPointer
        ) || (
            // Cast to bigger integer types implicitly, unless it is signed-->unsigned.
            is_integer_type(from)
            && is_integer_type(to)
            && from->data.width_in_bits < to->data.width_in_bits
            && !(from->kind == TypeKind::SignedInteger && to->kind == TypeKind::UnsignedInteger)
        ) || (
            // Cast to bigger floating-point type.
            from == floatType && to == doubleType
        ) || (
            // Cast from any integer type to float/double.
            is_integer_type(from) && to->kind == TypeKind::FloatingPoint
        ) || (
            // Cast implicitly between void pointer and any other pointer.
            (from->kind == TypeKind::Pointer && to->kind == TypeKind::VoidPointer)
            || (from->kind == TypeKind::VoidPointer && to->kind == TypeKind::Pointer)
        );
}

static void do_implicit_cast(
    const FunctionOrMethodTypes *fom,
    ExpressionTypes *types,
    const Type *to,
    Location location,
    const char *errormsg_template)
{
    assert(!types->implicit_cast_type);
    assert(!types->implicit_array_to_pointer_cast);
    const Type *from = types->type;
    if (from == to)
        return;

    if (
        types->expr->kind == AstExpressionKind::Constant
        && types->expr->data.constant.kind == ConstantKind::String
        && from == get_pointer_type(byteType)
        && to->kind == TypeKind::Array
        && to->data.array.membertype == byteType
    )
    {
        int string_size = strlen(types->expr->data.constant.data.str) + 1;
        if (to->data.array.len < string_size) {
            fail(location, "a string of %d bytes (including '\\0') does not fit into %s", string_size, to->name);
        }
        types->implicit_string_to_array_cast = true;
    }
    // Passing in NULL for errormsg_template can be used to "force" a cast to happen.
    else if (errormsg_template != NULL && !can_cast_implicitly(from, to))
        fail_with_implicit_cast_error(location, errormsg_template, from, to);

    types->implicit_cast_type = to;
    types->implicit_array_to_pointer_cast = (from->kind == TypeKind::Array && is_pointer_type(to));
    if (types->implicit_array_to_pointer_cast)
        ensure_can_take_address(
            fom,
            types->expr,
            "cannot create a pointer into an array that comes from %s (try storing it to a local variable first)"
        );
}

static void cast_array_to_pointer(const FunctionOrMethodTypes *fom, ExpressionTypes *types)
{
    assert(types->type->kind == TypeKind::Array);
    do_implicit_cast(fom, types, get_pointer_type(types->type->data.array.membertype), (Location){0}, NULL);
}

static void do_explicit_cast(const FunctionOrMethodTypes *fom, ExpressionTypes *types, const Type *to, Location location)
{
    assert(!types->implicit_cast_type);
    const Type *from = types->type;

    if (from == to)
        show_warning(location, "unnecessary cast from %s to %s", from->name, to->name);

    if (
        from != to
        && !(from->kind == TypeKind::Array && to->kind == TypeKind::Pointer && from->data.array.membertype == to->data.valuetype)
        && !(from->kind == TypeKind::Array && to->kind == TypeKind::VoidPointer)
        && !(is_pointer_type(from) && is_pointer_type(to))
        && !(is_number_type(from) && is_number_type(to))
        && !(is_integer_type(from) && to->kind == TypeKind::Enum)
        && !(from->kind == TypeKind::Enum && is_integer_type(to))
        && !(from->kind == TypeKind::Bool && is_integer_type(to))
        && !(is_pointer_type(from) && to == longType)
        && !(from == longType && is_pointer_type(to))
    )
    {
        fail(location, "cannot cast from type %s to %s", from->name, to->name);
    }

    if (from->kind == TypeKind::Array && is_pointer_type(to))
        cast_array_to_pointer(fom, types);
}

static ExpressionTypes *typecheck_expression(FileTypes *ft, const AstExpression *expr);

static ExpressionTypes *typecheck_expression_not_void(FileTypes *ft, const AstExpression *expr)
{
    ExpressionTypes *types = typecheck_expression(ft, expr);
    if (!types) {
        switch(expr->kind) {
        case AstExpressionKind::FunctionCall:
            fail(
                expr->location, "function '%s' does not return a value", expr->data.call.calledname);
            break;
        case AstExpressionKind::CallMethod:
            fail(
                expr->location, "method '%s' does not return a value", expr->data.methodcall.call.calledname);
            break;
        default:
            assert(0);
        }
    }
    return types;
}

static void typecheck_expression_with_implicit_cast(
    FileTypes *ft,
    const AstExpression *expr,
    const Type *casttype,
    const char *errormsg_template)
{
    ExpressionTypes *types = typecheck_expression_not_void(ft, expr);
    do_implicit_cast(ft->current_fom_types, types, casttype, expr->location, errormsg_template);
}

static const Type *check_binop(
    const FunctionOrMethodTypes *fom,
    enum AstExpressionKind op,
    Location location,
    ExpressionTypes *lhstypes,
    ExpressionTypes *rhstypes)
{
    const char *do_what;
    switch(op) {
    case AstExpressionKind::Add: do_what = "add"; break;
    case AstExpressionKind::Sub: do_what = "subtract"; break;
    case AstExpressionKind::Mul: do_what = "multiply"; break;
    case AstExpressionKind::Div: do_what = "divide"; break;
    case AstExpressionKind::Mod: do_what = "take remainder with"; break;

    case AstExpressionKind::Eq:
    case AstExpressionKind::Ne:
    case AstExpressionKind::Gt:
    case AstExpressionKind::Ge:
    case AstExpressionKind::Lt:
    case AstExpressionKind::Le:
        do_what = "compare";
        break;

    default:
        assert(0);
    }

    bool got_bools = lhstypes->type == boolType && rhstypes->type == boolType;
    bool got_integers = is_integer_type(lhstypes->type) && is_integer_type(rhstypes->type);
    bool got_numbers = is_number_type(lhstypes->type) && is_number_type(rhstypes->type);
    bool got_enums = lhstypes->type->kind == TypeKind::Enum && rhstypes->type->kind == TypeKind::Enum;
    bool got_pointers = (
        is_pointer_type(lhstypes->type)
        && is_pointer_type(rhstypes->type)
        && (
            // Ban comparisons like int* == byte*, unless one of the two types is void*
            lhstypes->type == rhstypes->type
            || lhstypes->type == voidPtrType
            || rhstypes->type == voidPtrType
        )
    );

    if (
        (!got_bools && !got_numbers && !got_enums && !got_pointers)
        || ((got_bools || got_enums) && op != AstExpressionKind::Eq && op != AstExpressionKind::Ne)
        || (got_pointers && op != AstExpressionKind::Eq && op != AstExpressionKind::Ne && op != AstExpressionKind::Gt && op != AstExpressionKind::Ge && op != AstExpressionKind::Lt && op != AstExpressionKind::Le)
    )
        fail(location, "wrong types: cannot %s %s and %s", do_what, lhstypes->type->name, rhstypes->type->name);

    const Type *cast_type = NULL;
    if (got_bools)
        cast_type = boolType;
    if (got_integers) {
        cast_type = get_integer_type(
            max(lhstypes->type->data.width_in_bits, rhstypes->type->data.width_in_bits),
            lhstypes->type->kind == TypeKind::SignedInteger || rhstypes->type->kind == TypeKind::SignedInteger
        );
    }
    if (got_numbers && !got_integers)
        cast_type = (lhstypes->type == doubleType || rhstypes->type == doubleType) ? doubleType : floatType;
    if (got_pointers)
        cast_type = get_integer_type(64, false);  // unsigned long
    if (got_enums)
        cast_type = intType;
    assert(cast_type);

    do_implicit_cast(fom, lhstypes, cast_type, (Location){0}, NULL);
    do_implicit_cast(fom, rhstypes, cast_type, (Location){0}, NULL);

    switch(op) {
        case AstExpressionKind::Add:
        case AstExpressionKind::Sub:
        case AstExpressionKind::Mul:
        case AstExpressionKind::Div:
        case AstExpressionKind::Mod:
            return cast_type;
        case AstExpressionKind::Eq:
        case AstExpressionKind::Ne:
        case AstExpressionKind::Gt:
        case AstExpressionKind::Ge:
        case AstExpressionKind::Lt:
        case AstExpressionKind::Le:
            return boolType;
        default:
            assert(0);
    }
}

static const Type *check_increment_or_decrement(FileTypes *ft, const AstExpression *expr)
{
    const char *bad_type_fmt, *bad_expr_fmt;
    switch(expr->kind) {
    case AstExpressionKind::PreIncrement:
    case AstExpressionKind::PostIncrement:
        bad_type_fmt = "cannot increment a value of type %s";
        bad_expr_fmt = "cannot increment %s";
        break;
    case AstExpressionKind::PreDecrement:
    case AstExpressionKind::PostDecrement:
        bad_type_fmt = "cannot decrement a value of type %s";
        bad_expr_fmt = "cannot decrement %s";
        break;
    default:
        assert(0);
    }

    ensure_can_take_address(ft->current_fom_types, &expr->data.operands[0], bad_expr_fmt);
    const Type *t = typecheck_expression_not_void(ft, &expr->data.operands[0])->type;
    if (!is_integer_type(t) && !is_pointer_type(t))
        fail(expr->location, bad_type_fmt, t->name);
    return t;
}

static void typecheck_dereferenced_pointer(Location location, const Type *t)
{
    // TODO: improved error message for dereferencing void*
    if (t->kind != TypeKind::Pointer)
        fail(location, "the dereference operator '*' is only for pointers, not for %s", t->name);
}

// ptr[index]
static const Type *typecheck_indexing(
    FileTypes *ft, const AstExpression *ptrexpr, const AstExpression *indexexpr)
{
    ExpressionTypes *types = typecheck_expression_not_void(ft, ptrexpr);

    const Type *ptrtype;
    if (types->type->kind == TypeKind::Array) {
        cast_array_to_pointer(ft->current_fom_types, types);
        ptrtype = types->implicit_cast_type;
    } else {
        if (types->type->kind != TypeKind::Pointer)
            fail(ptrexpr->location, "value of type %s cannot be indexed", types->type->name);
        ptrtype = types->type;
    }
    assert(ptrtype->kind == TypeKind::Pointer);

    ExpressionTypes *indextypes = typecheck_expression_not_void(ft, indexexpr);
    if (!is_integer_type(indextypes->type)) {
        fail(
            indexexpr->location,
            "the index inside [...] must be an integer, not %s",
            indextypes->type->name);
    }

    // LLVM assumes that indexes smaller than 64 bits are signed.
    // https://github.com/Akuli/jou/issues/48
    do_implicit_cast(ft->current_fom_types, indextypes, longType, (Location){0}, NULL);

    return ptrtype->data.valuetype;
}

static void typecheck_and_or(
    FileTypes *ft, const AstExpression *lhsexpr, const AstExpression *rhsexpr, const char *and_or)
{
    assert(!strcmp(and_or, "and") || !strcmp(and_or, "or"));
    char errormsg[100];
    sprintf(errormsg, "'%s' only works with booleans, not FROM", and_or);

    typecheck_expression_with_implicit_cast(ft, lhsexpr, boolType, errormsg);
    typecheck_expression_with_implicit_cast(ft, rhsexpr, boolType, errormsg);
}

static const char *nth(int n)
{
    assert(n >= 1);

    const char *first_few[] = { NULL, "first", "second", "third", "fourth", "fifth", "sixth" };
    if (n < (int)(sizeof(first_few)/sizeof(first_few[0])))
        return first_few[n];

    static char result[100];
    sprintf(result, "%dth", n);
    return result;
}

// returns NULL if the function doesn't return anything, otherwise non-owned pointer to non-owned type
static const Type *typecheck_function_or_method_call(FileTypes *ft, const AstCall *call, const Type *self_type, Location location)
{
    const Signature *sig = find_function_or_method(ft, self_type, call->calledname);
    if (!sig) {
        if (!self_type)
            fail(location, "function '%s' not found", call->calledname);

        // If self type is a pointer to a struct that has the method, mention it in the error message
        if (self_type->kind == TypeKind::Pointer && find_method(self_type->data.valuetype, call->calledname)) {
            fail(
                location,
                "the method '%s' is defined on class %s, not on the pointer type %s,"
                " so you need to dereference the pointer first (e.g. by using '->' instead of '.')",
                call->calledname, self_type->data.valuetype->name, self_type->name);
        }
        // If it is not a class, explain to the user that there are no methods
        if (self_type->kind != TypeKind::Class) {
            fail(
                location,
                "type %s does not have any methods because it is %s, not a class",
                self_type->name, short_type_description(self_type));
        }
        fail(location, "class %s does not have a method named '%s'",
            self_type->name, call->calledname);
    }

    char *sigstr = signature_to_string(sig, false, false);

    int nargs = sig->nargs;
    if (self_type)
        nargs--;
    if (call->nargs < nargs || (call->nargs > nargs && !sig->takes_varargs)) {
        fail(
            location,
            "%s %s takes %d argument%s, but it was called with %d argument%s",
            self_type ? "method" : "function",
            sigstr,
            nargs,
            nargs==1?"":"s",
            call->nargs,
            call->nargs==1?"":"s"
        );
    }

    int k = 0;
    for (int i = 0; i < sig->nargs; i++) {
        if (!strcmp(sig->argnames[i], "self"))
            continue;
        // This is a common error, so worth spending some effort to get a good error message.
        char msg[500];
        snprintf(msg, sizeof msg, "%s argument of %s %s should have type TO, not FROM", nth(i+1), self_type ? "method" : "function", sigstr);
        typecheck_expression_with_implicit_cast(ft, &call->args[k++], sig->argtypes[i], msg);
    }

    for (int i = k; i < call->nargs; i++) {
        // This code runs for varargs, e.g. the things to format in printf().
        ExpressionTypes *types = typecheck_expression_not_void(ft, &call->args[i]);

        if (types->type->kind == TypeKind::Array)
            cast_array_to_pointer(ft->current_fom_types, types);
        else if (
            (is_integer_type(types->type) && types->type->data.width_in_bits < 32)
            || types->type == boolType)
        {
            // Add implicit cast to signed int, just like in C.
            do_implicit_cast(ft->current_fom_types, types, intType, (Location){0}, NULL);
        }
        else if (types->type == floatType)
            do_implicit_cast(ft->current_fom_types, types, doubleType, (Location){0}, NULL);
    }

    free(sigstr);
    return sig->returntype;
}

static const struct ClassField *typecheck_class_field(
    const Type *classtype, const char *fieldname, Location location)
{
    assert(classtype->kind == TypeKind::Class);
    for (struct ClassField *f = classtype->data.classdata.fields.ptr; f < End(classtype->data.classdata.fields); f++)
        if (!strcmp(f->name, fieldname))
            return f;
    fail(location, "class %s has no field named '%s'", classtype->name, fieldname);
}

static const Type *typecheck_instantiation(FileTypes *ft, const AstCall *call, Location location)
{
    struct AstType tmp = { .kind = AstTypeKind::Named, .location = location };
    safe_strcpy(tmp.data.name, call->calledname);
    const Type *t = type_from_ast(ft, &tmp);

    if (t->kind != TypeKind::Class) {
        fail(location,
            "the %s{...} syntax is only for classes, but %s is %s",
            t->name, t->name, short_type_description(t));
    }

    const struct ClassField ** specified_fields = malloc(sizeof(specified_fields[0]) * call->nargs);  // NOLINT

    for (int i = 0; i < call->nargs; i++) {
        const struct ClassField *f = typecheck_class_field(t, call->argnames[i], call->args[i].location);
        char msg[1000];
        snprintf(msg, sizeof msg,
            "value for field '%s' of class %s must be of type TO, not FROM",
            call->argnames[i], call->calledname);
        typecheck_expression_with_implicit_cast(ft, &call->args[i], f->type, msg);
        specified_fields[i] = f;
    }

    for (int i1 = 0; i1 < call->nargs; i1++) {
        for (int i2 = i1+1; i2 < call->nargs; i2++) {
            if (specified_fields[i1]->union_id == specified_fields[i2]->union_id) {
                fail(
                    call->args[i2].location,
                    "fields '%s' and '%s' cannot be set simultaneously because they belong to the same union",
                    specified_fields[i1]->name, specified_fields[i2]->name);
            }
        }
    }

    free(specified_fields);
    return t;
}

static bool enum_member_exists(const Type *t, const char *name)
{
    assert(t->kind == TypeKind::Enum);
    for (int i = 0; i < t->data.enummembers.count; i++)
        if (!strcmp(t->data.enummembers.names[i], name))
            return true;
    return false;
}

static const Type *cast_array_members_to_a_common_type(const FunctionOrMethodTypes *fom, Location error_location, ExpressionTypes **exprtypes)
{
    // Avoid O(ntypes^2) code in a long array where all or almost all items have the same type.
    // This is at most O(ntypes*k) where k is the number of distinct types.
    List(const Type *) distinct = {0};
    for (ExpressionTypes **et = exprtypes; *et; et++) {
        bool found = false;
        for (const Type **t = distinct.ptr; t < End(distinct); t++) {
            if ((*et)->type == *t) {
                found = true;
                break;
            }
        }
        if (!found)
            Append(&distinct, (*et)->type);
    }

    List(const Type *) compatible_with_all = {0};
    for (const Type **t = distinct.ptr; t < End(distinct); t++) {
        bool t_compatible_with_all_others = true;
        for (const Type **t2 = distinct.ptr; t2 < End(distinct); t2++) {
            if (!can_cast_implicitly(*t2,*t)) {
                t_compatible_with_all_others = false;
                break;
            }
        }
        if (t_compatible_with_all_others)
            Append(&compatible_with_all, *t);
    }

    if (compatible_with_all.len != 1) {
        List(char) namestr = {0};
        for (const Type **t = distinct.ptr; t < End(distinct); t++) {
            AppendStr(&namestr, (*t)->name);
            AppendStr(&namestr, ", ");
        }
        fail(
            error_location, "array items have different types (%.*s)",
            namestr.len - 2, namestr.ptr);
    }
    const Type *elemtype = compatible_with_all.ptr[0];
    free(distinct.ptr);
    free(compatible_with_all.ptr);

    for (ExpressionTypes **et = exprtypes; *et; et++)
        do_implicit_cast(fom, *et, elemtype, error_location, NULL);
    return elemtype;
}

static ExpressionTypes *typecheck_expression(FileTypes *ft, const AstExpression *expr)
{
    const Type *temptype;
    const Type *result;

    switch(expr->kind) {
    case AstExpressionKind::GetEnumMember:
        result = find_type(ft, expr->data.enummember.enumname);
        if (!result)
            fail(
                expr->location, "there is no type named '%s'", expr->data.enummember.enumname);
        if (result->kind != TypeKind::Enum)
            fail(
                expr->location, "the '::' syntax is only for enums, but %s is %s",
                expr->data.enummember.enumname, short_type_description(result));
        if (!enum_member_exists(result, expr->data.enummember.membername))
            fail(expr->location, "enum %s has no member named '%s'",
                expr->data.enummember.enumname, expr->data.enummember.membername);
        break;
    case AstExpressionKind::FunctionCall:
        result = typecheck_function_or_method_call(ft, &expr->data.call, NULL, expr->location);
        if (!result)
            return NULL;
        break;
    case AstExpressionKind::SizeOf:
        typecheck_expression_not_void(ft, &expr->data.operands[0]);
        result = longType;
        break;
    case AstExpressionKind::BraceInit:
        result = typecheck_instantiation(ft, &expr->data.call, expr->location);
        break;
    case AstExpressionKind::Array:
        {
            int n = expr->data.array.count;
            ExpressionTypes **exprtypes = calloc(sizeof(exprtypes[0]), n+1);  // NOLINT
            for (int i = 0; i < n; i++)
                exprtypes[i] = typecheck_expression_not_void(ft, &expr->data.array.items[i]);

            const Type *membertype = cast_array_members_to_a_common_type(ft->current_fom_types, expr->location, exprtypes);
            free(exprtypes);
            result = get_array_type(membertype, n);
        }
        break;
    case AstExpressionKind::GetField:
        temptype = typecheck_expression_not_void(ft, expr->data.classfield.obj)->type;
        if (temptype->kind != TypeKind::Class)
            fail(
                expr->location,
                "left side of the '.' operator must be an instance of a class, not %s",
                temptype->name);
        result = typecheck_class_field(temptype, expr->data.classfield.fieldname, expr->location)->type;
        break;
    case AstExpressionKind::DerefAndGetField:
        temptype = typecheck_expression_not_void(ft, expr->data.classfield.obj)->type;
        if (temptype->kind != TypeKind::Pointer || temptype->data.valuetype->kind != TypeKind::Class)
            fail(
                expr->location,
                "left side of the '->' operator must be a pointer to a class, not %s",
                temptype->name);
        result = typecheck_class_field(temptype->data.valuetype, expr->data.classfield.fieldname, expr->location)->type;
        break;
    case AstExpressionKind::DerefAndCallMethod:
        temptype = typecheck_expression_not_void(ft, expr->data.classfield.obj)->type;
        if (temptype->kind != TypeKind::Pointer)
            fail(
                expr->location,
                "left side of the '->' operator must be a pointer, not %s",
                temptype->name);
        result = typecheck_function_or_method_call(ft, &expr->data.methodcall.call, temptype->data.valuetype, expr->location);
        break;
    case AstExpressionKind::CallMethod:
        temptype = typecheck_expression_not_void(ft, expr->data.methodcall.obj)->type;
        result = typecheck_function_or_method_call(ft, &expr->data.methodcall.call, temptype, expr->location);

        // If self argument is passed by pointer, make sure we can create that pointer
        assert(temptype->kind == TypeKind::Class);
        bool found = false;
        for (const Signature *m = temptype->data.classdata.methods.ptr; m < End(temptype->data.classdata.methods); m++) {
            if (!strcmp(m->name, expr->data.methodcall.call.calledname)) {
                if (is_pointer_type(m->argtypes[0])) {
                    char tmp[500];
                    snprintf(
                        tmp, sizeof tmp,
                        "cannot take address of %%s, needed for calling the %s() method",
                        expr->data.methodcall.call.calledname);
                    ensure_can_take_address(ft->current_fom_types, expr->data.methodcall.obj, tmp);
                }
                found = true;
                break;
            }
        }
        assert(found);

        if (!result)
            return NULL;
        break;
    case AstExpressionKind::Indexing:
        result = typecheck_indexing(ft, &expr->data.operands[0], &expr->data.operands[1]);
        break;
    case AstExpressionKind::AddressOf:
        ensure_can_take_address(ft->current_fom_types, &expr->data.operands[0], "the '&' operator cannot be used with %s");
        temptype = typecheck_expression_not_void(ft, &expr->data.operands[0])->type;
        result = get_pointer_type(temptype);
        break;
    case AstExpressionKind::GetVariable:
        result = find_any_var(ft, expr->data.varname);
        if (!result)
            fail(expr->location, "no variable named '%s'", expr->data.varname);
        break;
    case AstExpressionKind::Dereference:
        temptype = typecheck_expression_not_void(ft, &expr->data.operands[0])->type;
        typecheck_dereferenced_pointer(expr->location, temptype);
        result = temptype->data.valuetype;
        break;
    case AstExpressionKind::Constant:
        result = type_of_constant(&expr->data.constant);
        break;
    case AstExpressionKind::And:
        typecheck_and_or(ft, &expr->data.operands[0], &expr->data.operands[1], "and");
        result = boolType;
        break;
    case AstExpressionKind::Or:
        typecheck_and_or(ft, &expr->data.operands[0], &expr->data.operands[1], "or");
        result = boolType;
        break;
    case AstExpressionKind::Not:
        typecheck_expression_with_implicit_cast(
            ft, &expr->data.operands[0], boolType,
            "value after 'not' must be a boolean, not FROM");
        result = boolType;
        break;
    case AstExpressionKind::Neg:
        result = typecheck_expression_not_void(ft, &expr->data.operands[0])->type;
        if (result->kind != TypeKind::SignedInteger && result->kind != TypeKind::FloatingPoint)
            fail(
                expr->location,
                "value after '-' must be a float or double or a signed integer, not %s",
                result->name);
        break;
    case AstExpressionKind::Add:
    case AstExpressionKind::Sub:
    case AstExpressionKind::Mul:
    case AstExpressionKind::Div:
    case AstExpressionKind::Mod:
    case AstExpressionKind::Eq:
    case AstExpressionKind::Ne:
    case AstExpressionKind::Gt:
    case AstExpressionKind::Ge:
    case AstExpressionKind::Lt:
    case AstExpressionKind::Le:
        {
            ExpressionTypes *lhstypes = typecheck_expression_not_void(ft, &expr->data.operands[0]);
            ExpressionTypes *rhstypes = typecheck_expression_not_void(ft, &expr->data.operands[1]);
            result = check_binop(ft->current_fom_types, expr->kind, expr->location, lhstypes, rhstypes);
            break;
        }
    case AstExpressionKind::PreIncrement:
    case AstExpressionKind::PreDecrement:
    case AstExpressionKind::PostIncrement:
    case AstExpressionKind::PostDecrement:
        result = check_increment_or_decrement(ft, expr);
        break;
    case AstExpressionKind::As:
        {
            ExpressionTypes *origtypes = typecheck_expression_not_void(ft, expr->data.as.obj);
            result = type_from_ast(ft, &expr->data.as.type);
            do_explicit_cast(ft->current_fom_types, origtypes, result, expr->location);
        }
        break;
    }

    ExpressionTypes *types = calloc(1, sizeof *types);
    types->expr = expr;
    types->type = result;
    Append(&ft->current_fom_types->expr_types, types);
    return types;
}

static void typecheck_statement(FileTypes *ft, const AstStatement *stmt);

static void typecheck_body(FileTypes *ft, const AstBody *body)
{
    for (int i = 0; i < body->nstatements; i++)
        typecheck_statement(ft, &body->statements[i]);
}

static void typecheck_if_statement(FileTypes *ft, const AstIfStatement *ifstmt)
{
    for (int i = 0; i < ifstmt->n_if_and_elifs; i++) {
        const char *errmsg;
        if (i == 0)
            errmsg = "'if' condition must be a boolean, not FROM";
        else
            errmsg = "'elif' condition must be a boolean, not FROM";

        typecheck_expression_with_implicit_cast(
            ft, &ifstmt->if_and_elifs[i].condition, boolType, errmsg);
        typecheck_body(ft, &ifstmt->if_and_elifs[i].body);
    }
    typecheck_body(ft, &ifstmt->elsebody);
}

static void typecheck_statement(FileTypes *ft, const AstStatement *stmt)
{
    switch(stmt->kind) {
    case AstStatementKind::If:
        typecheck_if_statement(ft, &stmt->data.ifstatement);
        break;

    case AstStatementKind::While:
        typecheck_expression_with_implicit_cast(
            ft, &stmt->data.whileloop.condition, boolType,
            "'while' condition must be a boolean, not FROM");
        typecheck_body(ft, &stmt->data.whileloop.body);
        break;

    case AstStatementKind::For:
        typecheck_statement(ft, stmt->data.forloop.init);
        typecheck_expression_with_implicit_cast(
            ft, &stmt->data.forloop.cond, boolType,
            "'for' condition must be a boolean, not FROM");
        typecheck_body(ft, &stmt->data.forloop.body);
        typecheck_statement(ft, stmt->data.forloop.incr);
        break;

    case AstStatementKind::Break:
        break;

    case AstStatementKind::Continue:
        break;

    case AstStatementKind::Assign:
        {
            const AstExpression *targetexpr = &stmt->data.assignment.target;
            const AstExpression *valueexpr = &stmt->data.assignment.value;
            if (targetexpr->kind == AstExpressionKind::GetVariable
                && !find_any_var(ft, targetexpr->data.varname))
            {
                // Making a new variable. Use the type of the value being assigned.
                const ExpressionTypes *types = typecheck_expression_not_void(ft, valueexpr);
                add_variable(ft, types->type, targetexpr->data.varname);
            } else {
                // Convert value to the type of an existing variable or other assignment target.
                ensure_can_take_address(ft->current_fom_types, targetexpr, "cannot assign to %s");

                char errmsg[500];
                if (targetexpr->kind == AstExpressionKind::Dereference) {
                    strcpy(errmsg, "cannot place a value of type FROM into a pointer of type TO*");
                } else {
                    snprintf(errmsg, sizeof errmsg,
                        "cannot assign a value of type FROM to %s of type TO",
                        short_expression_description(targetexpr));
                }
                const ExpressionTypes *targettypes = typecheck_expression_not_void(ft, targetexpr);
                typecheck_expression_with_implicit_cast(ft, valueexpr, targettypes->type, errmsg);
            }
            break;
        }

    case AstStatementKind::InPlaceAdd:
    case AstStatementKind::InPlaceSub:
    case AstStatementKind::InPlaceMul:
    case AstStatementKind::InPlaceDiv:
    case AstStatementKind::InPlaceMod:
    {
        const AstExpression *targetexpr = &stmt->data.assignment.target;
        const AstExpression *valueexpr = &stmt->data.assignment.value;

        enum AstExpressionKind op;
        const char *opname;

        switch(stmt->kind) {
            case AstStatementKind::InPlaceAdd: op = AstExpressionKind::Add; opname = "addition"; break;
            case AstStatementKind::InPlaceSub: op = AstExpressionKind::Sub; opname = "subtraction"; break;
            case AstStatementKind::InPlaceMul: op = AstExpressionKind::Mul; opname = "multiplication"; break;
            case AstStatementKind::InPlaceDiv: op = AstExpressionKind::Div; opname = "division"; break;
            case AstStatementKind::InPlaceMod: op = AstExpressionKind::Mod; opname = "modulo"; break;
            default: assert(0);
        }

        ensure_can_take_address(ft->current_fom_types, targetexpr, "cannot assign to %s");
        ExpressionTypes *targettypes = typecheck_expression_not_void(ft, targetexpr);
        ExpressionTypes *valuetypes = typecheck_expression_not_void(ft, valueexpr);

        const Type *t = check_binop(ft->current_fom_types, op, stmt->location, targettypes, valuetypes);
        ExpressionTypes tempvalue_types = { .expr = targetexpr, .type = t };

        char msg[500];
        snprintf(msg, sizeof msg, "%s produced a value of type FROM which cannot be assigned back to TO", opname);
        do_implicit_cast(ft->current_fom_types, &tempvalue_types, targettypes->type, stmt->location, msg);

        // I think it is currently impossible to cast target.
        // If this assert fails, we probably need to add another error message for it.
        assert(!targettypes->implicit_cast_type);
        break;
    }

    case AstStatementKind::Return:
        if (ft->current_fom_types->signature.is_noreturn)
            fail(
                stmt->location,
                "function '%s' cannot return because it was defined with '-> noreturn'",
                ft->current_fom_types->signature.name);

        const Type *returntype = ft->current_fom_types->signature.returntype;
        if (stmt->data.returnvalue && !returntype) {
            fail(
                stmt->location,
                "function '%s' cannot return a value because it was defined with '-> None'",
                ft->current_fom_types->signature.name);
        }
        if (returntype && !stmt->data.returnvalue) {
            fail(
                stmt->location,
                "a return value is needed, because the return type of function '%s' is %s",
                ft->current_fom_types->signature.name,
                ft->current_fom_types->signature.returntype->name);
        }

        if (stmt->data.returnvalue) {
            char msg[200];
            snprintf(msg, sizeof msg,
                "attempting to return a value of type FROM from function '%s' defined with '-> TO'",
                ft->current_fom_types->signature.name);
            typecheck_expression_with_implicit_cast(
                ft, stmt->data.returnvalue, find_local_var(ft, "return")->type, msg);
        }

        break;

    case AstStatementKind::DeclareLocalVar:
        if (find_any_var(ft, stmt->data.vardecl.name))
            fail(stmt->location, "a variable named '%s' already exists", stmt->data.vardecl.name);

        const Type *type = type_from_ast(ft, &stmt->data.vardecl.type);
        add_variable(ft, type, stmt->data.vardecl.name);
        if (stmt->data.vardecl.value) {
            typecheck_expression_with_implicit_cast(
                ft, stmt->data.vardecl.value, type,
                "initial value for variable of type TO cannot be of type FROM");
        }
        break;

    case AstStatementKind::ExpressionStatement:
        typecheck_expression(ft, &stmt->data.expression);
        break;

    case AstStatementKind::Assert:
        typecheck_expression_with_implicit_cast(ft, &stmt->data.expression, boolType, "assertion must be a boolean, not FROM");
        break;

    case AstStatementKind::Pass:
        break;

    case AstStatementKind::GlobalVariableDeclaration:
    case AstStatementKind::DefineClass:
    case AstStatementKind::DefineEnum:
    case AstStatementKind::GlobalVariableDefinition:
    case AstStatementKind::Function:
        assert(0);
    }
}

static void typecheck_function_or_method_body(FileTypes *ft, const Signature *sig, const AstBody *body)
{
    assert(!ft->current_fom_types);
    Append(&ft->fomtypes, (struct FunctionOrMethodTypes){0});
    ft->current_fom_types = End(ft->fomtypes) - 1;
    ft->current_fom_types->signature = copy_signature(sig);

    for (int i = 0; i < sig->nargs; i++) {
        LocalVariable *v = add_variable(ft, sig->argtypes[i], sig->argnames[i]);
        v->is_argument = true;
    }
    if (sig->returntype)
        add_variable(ft, sig->returntype, "return");

    typecheck_body(ft, body);
    ft->current_fom_types = NULL;
}

void typecheck_stage3_function_and_method_bodies(FileTypes *ft, const AstFile *ast)
{
    for (int i = 0; i < ast->body.nstatements; i++) {
        const AstStatement *stmt = &ast->body.statements[i];
        if (stmt->kind == AstStatementKind::Function && stmt->data.function.body.nstatements > 0) {
            const Signature *sig = NULL;
            for (struct SignatureAndUsedPtr *f = ft->functions.ptr; f < End(ft->functions); f++) {
                if (!strcmp(f->signature.name, stmt->data.function.signature.name)) {
                    sig = &f->signature;
                    break;
                }
            }
            assert(sig);
            typecheck_function_or_method_body(ft, sig, &stmt->data.function.body);
        }

        if (stmt->kind == AstStatementKind::DefineClass) {
            Type *classtype = NULL;
            for (Type **t = ft->owned_types.ptr; t < End(ft->owned_types); t++) {
                if (!strcmp((*t)->name, stmt->data.classdef.name)) {
                    classtype = *t;
                    break;
                }
            }
            assert(classtype);

            for (AstClassMember *m = stmt->data.classdef.members.ptr; m < End(stmt->data.classdef.members); m++) {
                if (m->kind != AstClassMemberKind::Method)
                    continue;
                const AstFunction *method = &m->data.method;

                Signature *sig = NULL;
                for (Signature *s = classtype->data.classdata.methods.ptr; s < End(classtype->data.classdata.methods); s++) {
                    if (!strcmp(s->name, method->signature.name)) {
                        sig = s;
                        break;
                    }
                }
                assert(sig);
                typecheck_function_or_method_body(ft, sig, &method->body);
            }
        }
    }
}
