# Type checking is split into several stages:
#    1. Create types. After this, classes defined in Jou exist, but
#       they are opaque and contain no members. Enums exist and contain
#       their members (although it doesn't really matter whether enum
#       members are handled in stage 1 or 2).
#    2. Check signatures, global variables and class bodies, without
#       checking bodies of methods. This stage assumes that all types
#       exist, but doesn't need to know what fields each class has.
#    3. Check function and method bodies.
#
# The goal of this design is to make cyclic imports possible. At each
# stage, we don't need the results from the same stage, only from
# previous stages. This means that cyclic imports "just work" if we do
# each stage on all files before moving on to the next stage.

import "stdlib/io.jou"
import "stdlib/str.jou"
import "stdlib/mem.jou"
import "./ast.jou"
import "./types.jou"
import "./errors_and_warnings.jou"


def can_cast_implicitly(from: Type*, to: Type*) -> bool:
    return from == to or (
        # Cast to bigger integer types implicitly, unless it is signed-->unsigned.
        from->is_integer_type()
        and to->is_integer_type()
        and from->size_in_bits < to->size_in_bits
        and not (from->kind == TypeKind::SignedInteger and to->kind == TypeKind::SignedInteger)
#    ) or (
#        # Cast to bigger floating-point type.
#        from == floatType and to == doubleType
#    ) or (
#        # Cast from any integer type to float/double.
#        is_integer_type(from) and to->kind == TYPE_FLOATING_POINT
#    ) or (
#        # Cast implicitly between void pointer and any other pointer.
#        (from->kind == TYPE_POINTER and to->kind == TYPE_VOID_POINTER)
#        or (from->kind == TYPE_VOID_POINTER and to->kind == TYPE_POINTER)
    )

# Implicit casts are used in many places, e.g. function arguments.
#
# When you pass an argument of the wrong type, it's best to give an error message
# that says so, instead of some generic "expected type foo, got object of type bar"
# kind of message.
#
# The template can contain "<from>" and "<to>". They will be substituted with names
# of types. We cannot use printf() style functions because the arguments can be in
# any order.
def fail_with_implicit_cast_error(location: Location, template: byte*, from: Type*, to: Type*) -> void:
    n = 0
    for i = 0; template[i] != '\0'; i++:
        if template[i] == '<':
            n++

    message: byte* = malloc(sizeof(from->name)*n + strlen(template) + 1)
    message[0] = '\0'
    while *template != '\0':
        if starts_with(template, "<from>"):
            template = &template[6]
            strcat(message, &from->name[0])
        elif starts_with(template, "<to>"):
            template = &template[4]
            strcat(message, &to->name[0])
        else:
            s = [*template++, '\0']
            strcat(message, &s[0])

    fail(location, message)


# To understand the purpose of ExportSymbol, suppose file A imports file B.
#   - Type checking file B produces an ExportSymbol that matches the import in file A.
#   - Before the next type checking stage, the ExportSymbol is added to file A's types.
#   - During the next stage, file A can use the imported symbol.

enum ExportSymbolKind:
    Function
    Type

class ExportSymbol:
    kind: ExportSymbolKind
    name: byte[100]

    union:
        signature: Signature    # ExportSymbolKind::Function
        type: Type*             # ExportSymbolKind::Type

class ExpressionTypes:
    expression: AstExpression*
    original_type: Type*
    implicit_cast_type: Type*  # NULL if no implicit casting is needed
    next: ExpressionTypes*  # TODO: switch to more efficient structure than linked list?

    def do_implicit_cast(self, to: Type*, error_location: Location, error_template: byte*) -> void:
        assert self->implicit_cast_type == NULL  # This cannot be called multiple times

        from = self->original_type
        if from == to:
            return

        # Passing in NULL for error_template can be used to force a cast to happen.
        if error_template != NULL and not can_cast_implicitly(from, to):
            fail_with_implicit_cast_error(error_location, error_template, from, to)

        self->implicit_cast_type = to

class LocalVariable:
    name: byte[100]
    type: Type*
    next: LocalVariable*  # TODO: switch to more efficient structure than linked list?

class FunctionOrMethodTypes:
    signature: Signature
    expression_types: ExpressionTypes*
    local_vars: LocalVariable*

    def get_expression_types(self, expr: AstExpression*) -> ExpressionTypes*:
        for et = self->expression_types; et != NULL; et = et->next:
            if et->expression == expr:
                return et
        return NULL

    def find_local_var(self, name: byte*) -> LocalVariable*:
        for v = self->local_vars; v != NULL; v = v->next:
            if strcmp(&v->name[0], name) == 0:
                return v
        return NULL

# All type information for a Jou file. This is initially empty, and is filled during each stage of type checking.
class FileTypes:
    # Includes imported and defined functions.
    all_functions: Signature*
    n_all_functions: int

    defined_functions: FunctionOrMethodTypes*
    n_defined_functions: int

    types: Type**
    ntypes: int

    def add_imported_symbol(self, symbol: ExportSymbol*) -> void:
        if symbol->kind != ExportSymbolKind::Function:
            # TODO
            return
        self->all_functions = realloc(self->all_functions, sizeof self->all_functions[0] * (self->n_all_functions + 1))
        self->all_functions[self->n_all_functions++] = symbol->signature.copy()

    def find_function(self, name: byte*) -> Signature*:
        for i = 0; i < self->n_all_functions; i++:
            if strcmp(&self->all_functions[i].name[0], name) == 0:
                return &self->all_functions[i]
        return NULL

    def find_defined_function(self, name: byte*) -> FunctionOrMethodTypes*:
        for i = 0; i < self->n_defined_functions; i++:
            if strcmp(&self->defined_functions[i].signature.name[0], name) == 0:
                return &self->defined_functions[i]
        return NULL

    def find_type(self, name: byte*) -> Type*:
        for i = 0; i < self->ntypes; i++:
            if strcmp(&self->types[i]->name[0], name) == 0:
                return self->types[i]
        return NULL

def typecheck_stage1_create_types(ft: FileTypes*, file: AstFile*) -> ExportSymbol*:
    exports: ExportSymbol* = NULL
    nexports = 0

    for i = 0; i < file->body_len; i++:
        if file->body[i].kind == AstToplevelStatementKind::ClassDefinition:
            classdef = &file->body[i].classdef
            t = create_opaque_class(&classdef->name[0])
            ft->types = realloc(ft->types, (ft->ntypes + 1) * sizeof ft->types[0])
            ft->types[ft->ntypes++] = t

        if file->body[i].kind == AstToplevelStatementKind::Enum:
            enumdef = &file->body[i].enumdef
            t = create_enum(&enumdef->name[0], enumdef->member_count, enumdef->member_names)
            ft->types = realloc(ft->types, (ft->ntypes + 1) * sizeof ft->types[0])
            ft->types[ft->ntypes++] = t
            exports = realloc(exports, (nexports + 1) * sizeof exports[0])
            exports[nexports++] = ExportSymbol{
                kind = ExportSymbolKind::Type,
                name = enumdef->name,
                type = t,
            }

    exports = realloc(exports, sizeof exports[0] * (nexports + 1))
    exports[nexports] = ExportSymbol{}
    return exports


def type_from_ast(ft: FileTypes*, ast_type: AstType*) -> Type*:
    if ast_type->is_void():
        fail(ast_type->location, "'void' cannot be used here because it is not a type")
    if ast_type->is_noreturn():
        fail(ast_type->location, "'noreturn' cannot be used here because it is not a type")

    if ast_type->kind == AstTypeKind::Named:
        if strcmp(&ast_type->name[0], "int") == 0:
            return int_type
        if strcmp(&ast_type->name[0], "long") == 0:
            return long_type
        if strcmp(&ast_type->name[0], "byte") == 0:
            return byte_type
        if strcmp(&ast_type->name[0], "bool") == 0:
            return &bool_type
        # TODO: float, double

        result = ft->find_type(&ast_type->name[0])
        if result != NULL:
            return result

        message: byte* = malloc(strlen(&ast_type->name[0]) + 100)
        sprintf(message, "there is no type named '%s'", &ast_type->name[0])
        fail(ast_type->location, message)

    if ast_type->kind == AstTypeKind::Pointer:
        if ast_type->value_type->is_void():
            return &void_ptr_type
        return type_from_ast(ft, ast_type->value_type)->get_pointer_type()

    ast_type->print(True)
    printf("\n")
    assert False  # TODO

def handle_signature(ft: FileTypes*, astsig: AstSignature*) -> Signature:
    sig = Signature{
        name = astsig->name,
        nargs = astsig->nargs,
        takes_varargs = astsig->takes_varargs,
    }

    if astsig->return_type.is_void() or astsig->return_type.is_noreturn():
        sig.return_type = NULL
    else:
        sig.return_type = type_from_ast(ft, &astsig->return_type)

    sig.argnames = malloc(sizeof sig.argnames[0] * sig.nargs)
    for i = 0; i < sig.nargs; i++:
        sig.argnames[i] = astsig->args[i].name

    sig.argtypes = malloc(sizeof sig.argtypes[0] * sig.nargs)
    for i = 0; i < sig.nargs; i++:
        sig.argtypes[i] = type_from_ast(ft, &astsig->args[i].type)

    return sig

# Returned array is terminated by ExportSymbol with empty name.
def typecheck_stage2_populate_types(ft: FileTypes*, ast_file: AstFile*) -> ExportSymbol*:
    exports: ExportSymbol* = NULL
    nexports = 0

    for i = 0; i < ast_file->body_len; i++:
        ts = &ast_file->body[i]
        if ts->kind == AstToplevelStatementKind::Function:
            sig = handle_signature(ft, &ts->function.signature)
            ft->all_functions = realloc(ft->all_functions, sizeof ft->all_functions[0] * (ft->n_all_functions + 1))
            ft->all_functions[ft->n_all_functions++] = sig.copy()
            exports = realloc(exports, sizeof exports[0] * (nexports + 1))
            exports[nexports++] = ExportSymbol{
                kind = ExportSymbolKind::Function,
                name = sig.name,
                signature = sig,
            }

    exports = realloc(exports, sizeof exports[0] * (nexports + 1))
    exports[nexports] = ExportSymbol{}
    return exports


def plural_s(n: int) -> byte*:
    if n == 1:
        return ""
    return "s"

def nth(n: int) -> byte*:
    first_few = [NULL as byte*, "first", "second", "third", "fourth", "fifth", "sixth"]
    if n < sizeof first_few / sizeof first_few[0]:
        return strdup(first_few[n])

    result = malloc(100)
    sprintf(result, "%dth", n)
    return result

def check_explicit_cast(from: Type*, to: Type*, location: Location) -> void:
    if (
        from == to  # TODO: should probably be error if it's the same type.
        or (from->is_pointer_type() and to->is_pointer_type())
        or (from->is_number_type() and to->is_number_type())
        or (from->is_integer_type() and to->kind == TypeKind::Enum)
        or (from->kind == TypeKind::Enum and to->is_integer_type())  # TODO: disallow for too small type
        or (from == &bool_type and to->is_integer_type())
    ):
        return

    message: byte[500]
    snprintf(
        &message[0], sizeof message,
        "cannot cast from type %s to %s", &from->name[0], &to->name[0],
    )
    fail(location, &message[0])

def very_short_type_description(t: Type*) -> byte*:
    if t->kind == TypeKind::OpaqueClass:
        assert False
    if t->kind == TypeKind::Class:
        return "a class"
    if t->kind == TypeKind::Enum:
        return "an enum"
    if t->is_pointer_type():
        return "a pointer type"
    if t->is_number_type():
        return "a number type"
#    if t->kind == TypeKind::Array:
#        return "an array type"
    if t == &bool_type:
        return "the built-in boolean type"

    assert False

def max(a: int, b: int) -> int:
    if a > b:
        return a
    return b

def check_binop(
    op: AstExpressionKind,
    location: Location,
    lhs_types: ExpressionTypes*,
    rhs_types: ExpressionTypes*,
) -> Type*:
    result_is_bool = False
    if op == AstExpressionKind::Add:
        do_what = "add"
    elif op == AstExpressionKind::Subtract:
        do_what = "subtract"
    elif op == AstExpressionKind::Multiply:
        do_what = "multiply"
    elif op == AstExpressionKind::Divide:
        do_what = "divide"
    elif op == AstExpressionKind::Modulo:
        do_what = "take remainder with"
    else:
        assert (
            op == AstExpressionKind::Eq
            or op == AstExpressionKind::Ne
            or op == AstExpressionKind::Gt
            or op == AstExpressionKind::Ge
            or op == AstExpressionKind::Lt
            or op == AstExpressionKind::Le
        )
        do_what = "compare"
        result_is_bool = True

    got_integers = lhs_types->original_type->is_integer_type() and rhs_types->original_type->is_integer_type()
    got_numbers = lhs_types->original_type->is_number_type() and rhs_types->original_type->is_number_type()
    got_enums = lhs_types->original_type->kind == TypeKind::Enum and rhs_types->original_type->kind == TypeKind::Enum
    got_pointers = (
        lhs_types->original_type->is_pointer_type()
        and rhs_types->original_type->is_pointer_type()
        and (
            # Ban comparisons like int* == byte*, unless one of the two types is void*
            lhs_types->original_type == rhs_types->original_type
            or lhs_types->original_type == &void_ptr_type
            or rhs_types->original_type == &void_ptr_type
        )
    )

    if (
        (not got_numbers and not got_enums and not got_pointers)
        or (op != AstExpressionKind::Eq and op != AstExpressionKind::Ne and not got_numbers)
    ):
        message: byte[500]
        snprintf(
            &message[0], sizeof message,
            "wrong types: cannot %s %s and %s",
            do_what, &lhs_types->original_type->name[0], &rhs_types->original_type->name[0],
        )
        fail(location, &message[0])

    if got_integers:
        size = max(lhs_types->original_type->size_in_bits, rhs_types->original_type->size_in_bits)
        if (
            lhs_types->original_type->kind == TypeKind::SignedInteger
            or rhs_types->original_type->kind == TypeKind::SignedInteger
        ):
            cast_type = &signed_integers[size]
        else:
            cast_type = &unsigned_integers[size]
    elif got_numbers:
        assert False   # TODO: use float/double
    elif got_pointers:
        cast_type = &void_ptr_type
    elif got_enums:
        cast_type = int_type
    else:
        assert False

    lhs_types->do_implicit_cast(cast_type, Location{}, NULL)
    rhs_types->do_implicit_cast(cast_type, Location{}, NULL)

    if result_is_bool:
        return &bool_type
    else:
        return cast_type


class Stage3TypeChecker:
    file_types: FileTypes*
    current_function_or_method: FunctionOrMethodTypes*

    def add_local_var(self, name: byte*, type: Type*) -> LocalVariable*:
        v: LocalVariable* = calloc(1, sizeof *v)
        assert strlen(name) < sizeof v->name
        strcpy(&v->name[0], name)
        v->type = type

        dest_pointer = &self->current_function_or_method->local_vars
        while *dest_pointer != NULL:
            dest_pointer = &(*dest_pointer)->next

        *dest_pointer = v
        return v

    def find_var(self, name: byte*) -> Type*:
        local_var = self->current_function_or_method->find_local_var(name)
        if local_var != NULL:
            return local_var->type
        # TODO: check global vars (they don't exist yet)
        return NULL

    def do_function_call(self, call: AstCall*) -> Type*:
        message: byte[500]

        signature = self->file_types->find_function(&call->called_name[0])
        if signature == NULL:
            snprintf(&message[0], sizeof message, "function '%s' not found", &call->called_name[0])
            fail(call->location, &message[0])

        signature_string = signature->to_string(False)

        if (
            call->nargs < signature->nargs
            or (call->nargs > signature->nargs and not signature->takes_varargs)
        ):
            snprintf(
                &message[0], sizeof message,
                "function %s takes %d argument%s, but it was called with %d argument%s",
                signature_string,
                signature->nargs,
                plural_s(signature->nargs),
                call->nargs,
                plural_s(call->nargs),
            )
            fail(call->location, &message[0])

        for i = 0; i < signature->nargs; i++:
            # This is a common error, so worth spending some effort to get a good error message.
            tmp = nth(i+1)
            snprintf(
                &message[0], sizeof message,
                "%s argument of function %s should have type <to>, not <from>",
                tmp, signature_string)
            free(tmp)
            self->do_expression_and_implicit_cast(&call->args[i], signature->argtypes[i], &message[0])

        for i = signature->nargs; i < call->nargs; i++:
            # This code runs for varargs, e.g. the things to format in printf().
            types = self->do_expression(&call->args[i])

            # TODO: do something to arrays

            if (
                (types->original_type->is_integer_type() and types->original_type->size_in_bits < 32)
                or types->original_type == &bool_type
            ):
                # Add implicit cast to signed int, just like in C.
                types->do_implicit_cast(int_type, Location{}, NULL)

            # TODO: cast float to double implicitly

        free(signature_string)
        return signature->return_type

    def do_expression_maybe_void(self, expression: AstExpression*) -> ExpressionTypes*:
        result: Type*
        message: byte[200]

        if expression->kind == AstExpressionKind::String:
            result = byte_type->get_pointer_type()
        elif expression->kind == AstExpressionKind::Byte:
            result = byte_type
        elif expression->kind == AstExpressionKind::Int:
            result = int_type
        elif expression->kind == AstExpressionKind::Long:
            result = long_type
        elif expression->kind == AstExpressionKind::FunctionCall:
            result = self->do_function_call(&expression->call)
            if result == NULL:
                return NULL
        elif expression->kind == AstExpressionKind::GetVariable:
            result = self->find_var(&expression->varname[0])
            if result == NULL:
                snprintf(&message[0], sizeof message, "no variable named '%s'", &expression->varname[0])
                fail(expression->location, &message[0])
        elif expression->kind == AstExpressionKind::As:
            old_type = self->do_expression(&expression->as_expression->value)->original_type
            result = type_from_ast(self->file_types, &expression->as_expression->type)
            check_explicit_cast(old_type, result, expression->location)
        elif expression->kind == AstExpressionKind::GetEnumMember:
            result = self->file_types->find_type(&expression->enum_member.enum_name[0])
            if result == NULL:
                printf("find_type(%s) returned NULL\n", &expression->enum_member.enum_name[0])
                snprintf(&message[0], sizeof message, "there is no type named '%s'", &expression->enum_member.enum_name[0])
                fail(expression->location, &message[0])
            if result->kind != TypeKind::Enum:
                snprintf(
                    &message[0], sizeof message,
                    "the '::' syntax is only for enums, but %s is %s",
                    &expression->enum_member.enum_name[0], very_short_type_description(result),
                )
                fail(expression->location, &message[0])
            if result->enum_members.find_index(&expression->enum_member.member_name[0]) == -1:
                snprintf(
                    &message[0], sizeof message,
                    "enum %s has no member named '%s'",
                    &expression->enum_member.enum_name[0], &expression->enum_member.member_name[0],
                )
                fail(expression->location, &message[0])
        elif expression->kind == AstExpressionKind::Eq:
            lhs_types = self->do_expression(&expression->operands[0])
            rhs_types = self->do_expression(&expression->operands[1])
            result = check_binop(expression->kind, expression->location, lhs_types, rhs_types)
        elif expression->kind == AstExpressionKind::Negate:
            result = self->do_expression(&expression->operands[0])->original_type
            # TODO: check for floats/doubles too
            if result->kind != TypeKind::SignedInteger:
                snprintf(
                    &message[0], sizeof message,
                    "value after '-' must be a float or double or a signed integer, not %s",
                    &result->name[0],
                )
                fail(expression->location, &message[0])
        else:
            printf("*** %d\n", expression->kind as int)
            assert False

        p: ExpressionTypes* = malloc(sizeof *p)
        *p = ExpressionTypes{
            expression = expression,
            original_type = result,
            next = self->current_function_or_method->expression_types,
        }
        self->current_function_or_method->expression_types = p
        return p

    def do_expression(self, expression: AstExpression*) -> ExpressionTypes*:
        types = self->do_expression_maybe_void(expression)
        if types == NULL:
            assert expression->kind == AstExpressionKind::FunctionCall
            name = &expression->call.called_name[0]
            message = malloc(strlen(name) + 100)
            sprintf(message, "function '%s' does not return a value", name)
            fail(expression->location, message)
        return types

    def do_expression_and_implicit_cast(
        self,
        expression: AstExpression*,
        cast_type: Type*,
        error_message_template: byte*,
    ) -> ExpressionTypes*:
        types = self->do_expression(expression)
        types->do_implicit_cast(cast_type, expression->location, error_message_template)
        return types

    def do_statement(self, statement: AstStatement*) -> void:
        if statement->kind == AstStatementKind::ExpressionStatement:
            self->do_expression_maybe_void(&statement->expression)

        elif statement->kind == AstStatementKind::Return:
            sig = &self->current_function_or_method->signature

            # TODO: check for noreturn functions

            msg: byte[500]

            if statement->return_value != NULL and sig->return_type == NULL:
                snprintf(
                    &msg[0], sizeof msg,
                    "%s '%s' cannot return a value because it was defined with '-> void'",
                    sig->function_or_method(), &sig->name[0],
                )
                fail(statement->location, &msg[0])
            if statement->return_value == NULL and sig->return_type != NULL:
                snprintf(
                    &msg[0], sizeof msg,
                    "%s '%s' must return a value because it was defined with '-> %s'",
                    sig->function_or_method(), &sig->name[0], &sig->return_type->name[0],
                )
                fail(statement->location, &msg[0])

            if statement->return_value != NULL:
                cast_error_msg: byte[500]
                snprintf(
                    &cast_error_msg[0], sizeof cast_error_msg,
                    "attempting to return a value of type <from> from %s '%s' defined with '-> <to>'",
                    sig->function_or_method(), &sig->name[0],
                )
                self->do_expression_and_implicit_cast(
                    statement->return_value, sig->return_type, &cast_error_msg[0]
                )

        elif statement->kind == AstStatementKind::Assign:
            target_expr = &statement->assignment.target
            value_expr = &statement->assignment.value

            if (
                target_expr->kind == AstExpressionKind::GetVariable
                and self->find_var(&target_expr->varname[0]) == NULL
            ):
                # Making a new variable. Use the type of the value being assigned.
                types = self->do_expression(value_expr)
                self->add_local_var(&target_expr->varname[0], types->original_type)
            else:
                # Convert value to the type of an existing variable or other assignment target.
                #ensure_can_take_address(targetexpr, "cannot assign to %s")

                # This is a common error, so try to produce a helpful error message.
                if target_expr->kind == AstExpressionKind::Dereference:
                    error_template = "cannot place a value of type <from> into a pointer of type <to>*"
                else:
                    # TODO: improve this error message.
                    # See short_expression_description() in the other compiler.
                    error_template = "cannot assign a value of type FROM to target of type TO"

                target_types = self->do_expression(target_expr)
                self->do_expression_and_implicit_cast(value_expr, target_types->original_type, error_template)

        elif statement->kind == AstStatementKind::DeclareLocalVar:
            ntv: AstNameTypeValue* = &statement->var_declaration
            if self->find_var(&ntv->name[0]) != NULL:
                message: byte[200]
                snprintf(&message[0], sizeof message, "a variable named '%s' already exists", &ntv->name[0])
                fail(statement->location, &message[0])

            type = type_from_ast(self->file_types, &ntv->type)
            self->add_local_var(&ntv->name[0], type)
            if ntv->value != NULL:
                self->do_expression_and_implicit_cast(
                    ntv->value, type,
                    "initial value for variable of type TO cannot be of type FROM",
                )

        elif statement->kind == AstStatementKind::If:
            for i = 0; i < statement->if_statement.n_if_and_elifs; i++:
                self->do_expression_and_implicit_cast(
                    &statement->if_statement.if_and_elifs[i].condition,
                    &bool_type,
                    "'if' condition must be a boolean, not <from>",
                )
                self->do_body(&statement->if_statement.if_and_elifs[i].body)
            self->do_body(&statement->if_statement.else_body)

        else:
            printf("*** typecheck: unknown statement kind %d\n", statement->kind)
            assert False

    def do_body(self, body: AstBody*) -> void:
        for i = 0; i < body->nstatements; i++:
            self->do_statement(&body->statements[i])


def typecheck_stage3_function_and_method_bodies(file_types: FileTypes*, ast_file: AstFile*) -> void:
    checker = Stage3TypeChecker{file_types = file_types}
    for i = 0; i < ast_file->body_len; i++:
        ts = &ast_file->body[i]
        if ts->kind != AstToplevelStatementKind::Function or ts->function.body.nstatements == 0:
            continue

        sig = file_types->find_function(&ts->function.signature.name[0])
        assert sig != NULL

        assert checker.current_function_or_method == NULL
        file_types->defined_functions = realloc(file_types->defined_functions, (file_types->n_defined_functions + 1) * sizeof file_types->defined_functions[0])
        checker.current_function_or_method = &file_types->defined_functions[file_types->n_defined_functions++]
        *checker.current_function_or_method = FunctionOrMethodTypes{signature = sig->copy()}

        for k = 0; k < sig->nargs; k++:
            checker.add_local_var(&sig->argnames[k][0], sig->argtypes[k])

        checker.do_body(&ts->function.body)
        checker.current_function_or_method = NULL
