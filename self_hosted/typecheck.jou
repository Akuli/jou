# Type checking is split into several stages:
#    1. Create types. After this, classes defined in Jou exist, but
#       they are opaque and contain no members. Enums exist and contain
#       their members (although it doesn't really matter whether enum
#       members are handled in stage 1 or 2).
#    2. Check signatures, global variables and class bodies, without
#       checking bodies of methods. This stage assumes that all types
#       exist, but doesn't need to know what fields each class has.
#    3. Check function and method bodies.
#
# The goal of this design is to make cyclic imports possible. At each
# stage, we don't need the results from the same stage, only from
# previous stages. This means that cyclic imports "just work" if we do
# each stage on all files before moving on to the next stage.

import "stdlib/io.jou"
import "stdlib/str.jou"
import "stdlib/mem.jou"
import "./ast.jou"
import "./types.jou"
import "./errors_and_warnings.jou"


def can_cast_implicitly(from: Type*, to: Type*) -> bool:
    return from == to or (
        # Cast to bigger integer types implicitly, unless it is signed-->unsigned.
        from->is_integer_type()
        and to->is_integer_type()
        and from->size_in_bits < to->size_in_bits
        and not (from->kind == TypeKind::SignedInteger and to->kind == TypeKind::SignedInteger)
#    ) or (
#        # Cast to bigger floating-point type.
#        from == floatType and to == doubleType
#    ) or (
#        # Cast from any integer type to float/double.
#        is_integer_type(from) and to->kind == TYPE_FLOATING_POINT
#    ) or (
#        # Cast implicitly between void pointer and any other pointer.
#        (from->kind == TYPE_POINTER and to->kind == TYPE_VOID_POINTER)
#        or (from->kind == TYPE_VOID_POINTER and to->kind == TYPE_POINTER)
    )

# Implicit casts are used in many places, e.g. function arguments.
#
# When you pass an argument of the wrong type, it's best to give an error message
# that says so, instead of some generic "expected type foo, got object of type bar"
# kind of message.
#
# The template can contain "<from>" and "<to>". They will be substituted with names
# of types. We cannot use printf() style functions because the arguments can be in
# any order.
def fail_with_implicit_cast_error(location: Location, template: byte*, from: Type*, to: Type*) -> void:
    n = 0
    for i = 0; template[i] != '\0'; i++:
        if template[i] == '<':
            n++

    message: byte* = malloc(sizeof(from->name)*n + strlen(template) + 1)
    message[0] = '\0'
    while *template != '\0':
        if starts_with(template, "<from>"):
            template = &template[6]
            strcat(message, from->name)
        elif starts_with(template, "<to>"):
            template = &template[4]
            strcat(message, to->name)
        else:
            s = [*template++, '\0']
            strcat(message, s)

    fail(location, message)


# To understand the purpose of ExportSymbol, suppose file A imports file B.
#   - Type checking file B produces an ExportSymbol that matches the import in file A.
#   - Before the next type checking stage, the ExportSymbol is added to file A's types.
#   - During the next stage, file A can use the imported symbol.

enum ExportSymbolKind:
    Function
    Type

class ExportSymbol:
    kind: ExportSymbolKind
    name: byte[100]

    union:
        signature: Signature    # ExportSymbolKind::Function
        type: Type*             # ExportSymbolKind::Type

class ExpressionTypes:
    expression: AstExpression*
    original_type: Type*
    implicit_cast_type: Type*  # NULL if no implicit casting is needed
    next: ExpressionTypes*  # TODO: switch to more efficient structure than linked list?

    def do_implicit_cast(self, to: Type*, error_location: Location, error_template: byte*) -> void:
        assert self->implicit_cast_type == NULL  # This cannot be called multiple times

        from = self->original_type
        if from == to:
            return

        # Passing in NULL for error_template can be used to force a cast to happen.
        if error_template != NULL and not can_cast_implicitly(from, to):
            fail_with_implicit_cast_error(error_location, error_template, from, to)

        self->implicit_cast_type = to

class LocalVariable:
    name: byte[100]
    type: Type*
    next: LocalVariable*  # TODO: switch to more efficient structure than linked list?

class FunctionOrMethodTypes:
    signature: Signature
    expression_types: ExpressionTypes*
    local_vars: LocalVariable*

    def get_expression_types(self, expr: AstExpression*) -> ExpressionTypes*:
        for et = self->expression_types; et != NULL; et = et->next:
            if et->expression == expr:
                return et
        return NULL

    def find_local_var(self, name: byte*) -> LocalVariable*:
        for v = self->local_vars; v != NULL; v = v->next:
            if strcmp(v->name, name) == 0:
                return v
        return NULL

# All type information for a Jou file. This is initially empty, and is filled during each stage of type checking.
class FileTypes:
    # Includes imported and defined functions.
    all_functions: Signature*
    n_all_functions: int

    defined_functions: FunctionOrMethodTypes*
    n_defined_functions: int

    types: Type**
    ntypes: int

    def add_imported_symbol(self, symbol: ExportSymbol*) -> void:
        if symbol->kind != ExportSymbolKind::Function:
            # TODO
            return
        self->all_functions = realloc(self->all_functions, sizeof self->all_functions[0] * (self->n_all_functions + 1))
        self->all_functions[self->n_all_functions++] = symbol->signature.copy()

    def find_function(self, name: byte*) -> Signature*:
        for i = 0; i < self->n_all_functions; i++:
            if strcmp(self->all_functions[i].name, name) == 0:
                return &self->all_functions[i]
        return NULL

    def find_defined_function(self, name: byte*) -> FunctionOrMethodTypes*:
        for i = 0; i < self->n_defined_functions; i++:
            if strcmp(self->defined_functions[i].signature.name, name) == 0:
                return &self->defined_functions[i]
        return NULL

    def find_type(self, name: byte*) -> Type*:
        for i = 0; i < self->ntypes; i++:
            if strcmp(self->types[i]->name, name) == 0:
                return self->types[i]
        return NULL

def check_type_doesnt_exist(ft: FileTypes*, name: byte*, location: Location) -> void:
    existing = ft->find_type(name)
    if existing != NULL:
        description = short_type_description(existing)
        message: byte[500]
        snprintf(message, sizeof message, "%s named '%s' already exists", description, name)
        fail(location, message)

def typecheck_stage1_create_types(ft: FileTypes*, file: AstFile*) -> ExportSymbol*:
    exports: ExportSymbol* = NULL
    nexports = 0

    for i = 0; i < file->body_len; i++:
        if file->body[i].kind == AstToplevelStatementKind::Class:
            classdef = &file->body[i].classdef
            check_type_doesnt_exist(ft, classdef->name, classdef->name_location)
            t = create_opaque_class(classdef->name)
            ft->types = realloc(ft->types, (ft->ntypes + 1) * sizeof ft->types[0])
            ft->types[ft->ntypes++] = t

        if file->body[i].kind == AstToplevelStatementKind::Enum:
            enumdef = &file->body[i].enumdef
            check_type_doesnt_exist(ft, enumdef->name, enumdef->name_location)
            t = create_enum(enumdef->name, enumdef->member_count, enumdef->member_names)
            ft->types = realloc(ft->types, (ft->ntypes + 1) * sizeof ft->types[0])
            ft->types[ft->ntypes++] = t
            exports = realloc(exports, (nexports + 1) * sizeof exports[0])
            exports[nexports++] = ExportSymbol{
                kind = ExportSymbolKind::Type,
                name = enumdef->name,
                type = t,
            }

    exports = realloc(exports, sizeof exports[0] * (nexports + 1))
    exports[nexports] = ExportSymbol{}
    return exports


def type_from_ast(ft: FileTypes*, ast_type: AstType*) -> Type*:
    if ast_type->is_void():
        fail(ast_type->location, "'void' cannot be used here because it is not a type")
    if ast_type->is_noreturn():
        fail(ast_type->location, "'noreturn' cannot be used here because it is not a type")

    if ast_type->kind == AstTypeKind::Named:
        if strcmp(ast_type->name, "short") == 0:
            return short_type
        if strcmp(ast_type->name, "int") == 0:
            return int_type
        if strcmp(ast_type->name, "long") == 0:
            return long_type
        if strcmp(ast_type->name, "byte") == 0:
            return byte_type
        if strcmp(ast_type->name, "bool") == 0:
            return &bool_type
        # TODO: float, double

        result = ft->find_type(ast_type->name)
        if result != NULL:
            return result

        message: byte* = malloc(strlen(ast_type->name) + 100)
        sprintf(message, "there is no type named '%s'", ast_type->name)
        fail(ast_type->location, message)

    if ast_type->kind == AstTypeKind::Pointer:
        if ast_type->value_type->is_void():
            return &void_ptr_type
        return type_from_ast(ft, ast_type->value_type)->get_pointer_type()

    ast_type->print(True)
    printf("\n")
    assert False  # TODO

def handle_signature(ft: FileTypes*, astsig: AstSignature*) -> Signature:
    sig = Signature{
        name = astsig->name,
        nargs = astsig->nargs,
        takes_varargs = astsig->takes_varargs,
    }

    if astsig->return_type.is_void() or astsig->return_type.is_noreturn():
        sig.return_type = NULL
    else:
        sig.return_type = type_from_ast(ft, &astsig->return_type)

    sig.argnames = malloc(sizeof sig.argnames[0] * sig.nargs)
    for i = 0; i < sig.nargs; i++:
        sig.argnames[i] = astsig->args[i].name

    sig.argtypes = malloc(sizeof sig.argtypes[0] * sig.nargs)
    for i = 0; i < sig.nargs; i++:
        sig.argtypes[i] = type_from_ast(ft, &astsig->args[i].type)

    return sig

def handle_class_members_stage2(ft: FileTypes*, classdef: AstClassDef*) -> void:
    # Previous type-checking stage created an opaque type.
    type: Type* = NULL
    for i = 0; i < ft->ntypes; i++:
        if strcmp(ft->types[i]->name, classdef->name) == 0:
            type = ft->types[i]
            break
    assert type != NULL

    assert type->kind == TypeKind::OpaqueClass
    type->kind = TypeKind::Class

    memset(&type->class_members, 0, sizeof type->class_members)

    union_id = 0
    for i = 0; i < classdef->nmembers; i++:
        member = &classdef->members[i]
        if member->kind == AstClassMemberKind::Field:
            type->class_members.fields = realloc(type->class_members.fields, (type->class_members.nfields + 1) * sizeof type->class_members.fields[0])
            type->class_members.fields[type->class_members.nfields++] = ClassField{
                name = member->field.name,
                type = type_from_ast(ft, &member->field.type),
                union_id = union_id++,
            }
        elif member->kind == AstClassMemberKind::Union:
            uid = union_id++
            for k = 0; k < member->union_fields.nfields; k++:
                type->class_members.fields = realloc(type->class_members.fields, (type->class_members.nfields + 1) * sizeof type->class_members.fields[0])
                type->class_members.fields[type->class_members.nfields++] = ClassField{
                    name = member->union_fields.fields[k].name,
                    type = type_from_ast(ft, &member->union_fields.fields[k].type),
                    union_id = uid,
                }
        elif member->kind == AstClassMemberKind::Method:
#                // Don't handle the method body yet: that is a part of stage 3, not stage 2
#                Signature sig = handle_signature(ft, &m->data.method.signature, type);
#                Append(&type->data.classdata.methods, sig);
            assert False
        else:
            assert False

# Returned array is terminated by ExportSymbol with empty name.
def typecheck_stage2_populate_types(ft: FileTypes*, ast_file: AstFile*) -> ExportSymbol*:
    exports: ExportSymbol* = NULL
    nexports = 0

    for i = 0; i < ast_file->body_len; i++:
        ts = &ast_file->body[i]

        if ts->kind == AstToplevelStatementKind::Function:
            sig = handle_signature(ft, &ts->function.signature)
            ft->all_functions = realloc(ft->all_functions, sizeof ft->all_functions[0] * (ft->n_all_functions + 1))
            ft->all_functions[ft->n_all_functions++] = sig.copy()
            exports = realloc(exports, sizeof exports[0] * (nexports + 1))
            exports[nexports++] = ExportSymbol{
                kind = ExportSymbolKind::Function,
                name = sig.name,
                signature = sig,
            }

        if ts->kind == AstToplevelStatementKind::Class:
            handle_class_members_stage2(ft, &ts->classdef)

    exports = realloc(exports, sizeof exports[0] * (nexports + 1))
    exports[nexports] = ExportSymbol{}
    return exports


def plural_s(n: int) -> byte*:
    if n == 1:
        return ""
    return "s"

def nth(n: int) -> byte*:
    first_few = [NULL as byte*, "first", "second", "third", "fourth", "fifth", "sixth"]
    if n < sizeof first_few / sizeof first_few[0]:
        return strdup(first_few[n])

    result = malloc(100)
    sprintf(result, "%dth", n)
    return result

def check_explicit_cast(from: Type*, to: Type*, location: Location) -> void:
    if (
        from == to  # TODO: should probably be error if it's the same type.
        or (from->is_pointer_type() and to->is_pointer_type())
        or (from->is_number_type() and to->is_number_type())
        or (from->is_integer_type() and to->kind == TypeKind::Enum)
        or (from->kind == TypeKind::Enum and to->is_integer_type())  # TODO: disallow for too small type
        or (from == &bool_type and to->is_integer_type())
    ):
        return

    message: byte[500]
    snprintf(
        message, sizeof message,
        "cannot cast from type %s to %s", from->name, to->name,
    )
    fail(location, message)

def short_type_description(t: Type*) -> byte*:
    if t->kind == TypeKind::Class or t->kind == TypeKind::OpaqueClass:
        return "a class"
    if t->kind == TypeKind::Enum:
        return "an enum"
    if t->is_pointer_type():
        return "a pointer type"
    if t->is_number_type():
        return "a number type"
#    if t->kind == TypeKind::Array:
#        return "an array type"
    if t == &bool_type:
        return "the built-in bool type"
    assert False

def short_expression_description(expr: AstExpression*) -> byte[200]:
    result: byte[200]

    # Imagine "cannot assign to" in front of these, e.g. "cannot assign to a constant"
    if (
        expr->kind == AstExpressionKind::String
        or expr->kind == AstExpressionKind::Short
        or expr->kind == AstExpressionKind::Int
        or expr->kind == AstExpressionKind::Long
        or expr->kind == AstExpressionKind::Byte
        or expr->kind == AstExpressionKind::Bool
        or expr->kind == AstExpressionKind::Null
    ):
        strcpy(result, "a constant")
    elif (
        expr->kind == AstExpressionKind::Negate
        or expr->kind == AstExpressionKind::Add
        or expr->kind == AstExpressionKind::Subtract
        or expr->kind == AstExpressionKind::Multiply
        or expr->kind == AstExpressionKind::Divide
        or expr->kind == AstExpressionKind::Modulo
    ):
        strcpy(result, "the result of a calculation")
    elif (
        expr->kind == AstExpressionKind::Eq
        or expr->kind == AstExpressionKind::Ne
        or expr->kind == AstExpressionKind::Gt
        or expr->kind == AstExpressionKind::Ge
        or expr->kind == AstExpressionKind::Lt
        or expr->kind == AstExpressionKind::Le
    ):
        strcpy(result, "the result of a comparison")
    elif expr->kind == AstExpressionKind::FunctionCall:
        strcpy(result, "a function call")
    elif expr->kind == AstExpressionKind::Instantiate:
        strcpy(result, "a newly created instance")
    elif expr->kind == AstExpressionKind::GetVariable:
        strcpy(result, "a variable")
    elif expr->kind == AstExpressionKind::GetEnumMember:
        strcpy(result, "an enum member")
    elif expr->kind == AstExpressionKind::GetClassField:
        snprintf(result, sizeof result, "field '%s'", expr->class_field.field_name)
    elif expr->kind == AstExpressionKind::As:
        strcpy(result, "the result of a cast")
    elif expr->kind == AstExpressionKind::SizeOf:
        strcpy(result, "a sizeof expression")
    elif expr->kind == AstExpressionKind::AddressOf:
        subresult = short_expression_description(expr->operands)
        snprintf(result, sizeof result, "address of %s", subresult)
    elif expr->kind == AstExpressionKind::Dereference:
        strcpy(result, "the value of a pointer")
    elif expr->kind == AstExpressionKind::And:
        strcpy(result, "the result of 'and'")
    elif expr->kind == AstExpressionKind::Or:
        strcpy(result, "the result of 'or'")
    elif expr->kind == AstExpressionKind::Not:
        strcpy(result, "the result of 'not'")
    elif expr->kind == AstExpressionKind::PreIncr or expr->kind == AstExpressionKind::PostIncr:
        strcpy(result, "the result of incrementing a value")
    elif expr->kind == AstExpressionKind::PreDecr or expr->kind == AstExpressionKind::PostDecr:
        strcpy(result, "the result of decrementing a value")
    elif expr->kind == AstExpressionKind::Indexing:
        strcpy(result, "an indexed value")
    else:
        printf("*** %d\n", expr->kind)
        assert False

    return result

# The & operator can't go in front of most expressions.
# You can't do &(1 + 2), for example.
#
# The same rules apply to assignments: "foo = bar" is treated as setting the
# value of the pointer &foo to bar.
# 
# error_template can be e.g. "cannot take address of %s" or "cannot assign to %s"
def ensure_can_take_address(expression: AstExpression*, error_template: byte*) -> void:
    if expression->kind == AstExpressionKind::GetClassField:
        # &foo.bar --> must ensure we can take address of foo.
        # Doesn't apply to &foo->bar because that's foo + some offset, so foo is already a pointer.
        if not expression->class_field.uses_arrow_operator:
            # Turn "cannot assign to %s" into "cannot assign to a field of %s".
            # This assumes that error_template is relatively simple, i.e. it only contains one %s somewhere.
            new_template = malloc(strlen(error_template) + 50)
            sprintf(new_template, error_template, "a field of %s")
            ensure_can_take_address(&expression->operands[0], new_template)
            free(new_template)
        return

    if (
        expression->kind == AstExpressionKind::GetVariable  # &foo
        or expression->kind == AstExpressionKind::Dereference  # &*foo
        or expression->kind == AstExpressionKind::Indexing  # &foo[bar] = foo + some offset (foo is a pointer)
    ):
        return

    # Anything else is an error.
    desc: byte[200] = short_expression_description(expression)
    error = malloc(strlen(error_template) + 300)
    sprintf(error, error_template, desc)
    fail(expression->location, error)

def max(a: int, b: int) -> int:
    if a > b:
        return a
    return b

def check_binop(
    op: AstExpressionKind,
    location: Location,
    lhs_types: ExpressionTypes*,
    rhs_types: ExpressionTypes*,
) -> Type*:
    result_is_bool = False
    if op == AstExpressionKind::Add:
        do_what = "add"
    elif op == AstExpressionKind::Subtract:
        do_what = "subtract"
    elif op == AstExpressionKind::Multiply:
        do_what = "multiply"
    elif op == AstExpressionKind::Divide:
        do_what = "divide"
    elif op == AstExpressionKind::Modulo:
        do_what = "take remainder with"
    else:
        assert (
            op == AstExpressionKind::Eq
            or op == AstExpressionKind::Ne
            or op == AstExpressionKind::Gt
            or op == AstExpressionKind::Ge
            or op == AstExpressionKind::Lt
            or op == AstExpressionKind::Le
        )
        do_what = "compare"
        result_is_bool = True

    got_integers = lhs_types->original_type->is_integer_type() and rhs_types->original_type->is_integer_type()
    got_numbers = lhs_types->original_type->is_number_type() and rhs_types->original_type->is_number_type()
    got_enums = lhs_types->original_type->kind == TypeKind::Enum and rhs_types->original_type->kind == TypeKind::Enum
    got_pointers = (
        lhs_types->original_type->is_pointer_type()
        and rhs_types->original_type->is_pointer_type()
        and (
            # Ban comparisons like int* == byte*, unless one of the two types is void*
            lhs_types->original_type == rhs_types->original_type
            or lhs_types->original_type == &void_ptr_type
            or rhs_types->original_type == &void_ptr_type
        )
    )

    if (
        (not got_numbers and not got_enums and not got_pointers)
        or (op != AstExpressionKind::Eq and op != AstExpressionKind::Ne and not got_numbers)
    ):
        message: byte[500]
        snprintf(
            message, sizeof message,
            "wrong types: cannot %s %s and %s",
            do_what, lhs_types->original_type->name, rhs_types->original_type->name,
        )
        fail(location, message)

    if got_integers:
        size = max(lhs_types->original_type->size_in_bits, rhs_types->original_type->size_in_bits)
        if (
            lhs_types->original_type->kind == TypeKind::SignedInteger
            or rhs_types->original_type->kind == TypeKind::SignedInteger
        ):
            cast_type = &signed_integers[size]
        else:
            cast_type = &unsigned_integers[size]
    elif got_numbers:
        assert False   # TODO: use float/double
    elif got_pointers:
        cast_type = &void_ptr_type
    elif got_enums:
        cast_type = int_type
    else:
        assert False

    lhs_types->do_implicit_cast(cast_type, Location{}, NULL)
    rhs_types->do_implicit_cast(cast_type, Location{}, NULL)

    if result_is_bool:
        return &bool_type
    else:
        return cast_type

def check_class_field(location: Location, class_type: Type*, field_name: byte*) -> ClassField*:
    assert class_type->kind == TypeKind::Class

    field = class_type->class_members.find_field(field_name)
    if field == NULL:
        message: byte[500]
        snprintf(message, sizeof message, "class %s has no field named '%s'", class_type->name, field_name)
        fail(location, message)
    return field

class Stage3TypeChecker:
    file_types: FileTypes*
    current_function_or_method: FunctionOrMethodTypes*
    nested_loop_count: int

    def add_local_var(self, name: byte*, type: Type*) -> LocalVariable*:
        v: LocalVariable* = calloc(1, sizeof *v)
        assert strlen(name) < sizeof v->name
        strcpy(v->name, name)
        v->type = type

        dest_pointer = &self->current_function_or_method->local_vars
        while *dest_pointer != NULL:
            dest_pointer = &(*dest_pointer)->next

        *dest_pointer = v
        return v

    def find_var(self, name: byte*) -> Type*:
        local_var = self->current_function_or_method->find_local_var(name)
        if local_var != NULL:
            return local_var->type
        # TODO: check global vars (they don't exist yet)
        return NULL

    def do_function_call(self, call: AstCall*) -> Type*:
        message: byte[500]

        signature = self->file_types->find_function(call->called_name)
        if signature == NULL:
            snprintf(message, sizeof message, "function '%s' not found", call->called_name)
            fail(call->location, message)

        signature_string = signature->to_string(False)

        if (
            call->nargs < signature->nargs
            or (call->nargs > signature->nargs and not signature->takes_varargs)
        ):
            snprintf(
                message, sizeof message,
                "function %s takes %d argument%s, but it was called with %d argument%s",
                signature_string,
                signature->nargs,
                plural_s(signature->nargs),
                call->nargs,
                plural_s(call->nargs),
            )
            fail(call->location, message)

        for i = 0; i < signature->nargs; i++:
            # This is a common error, so worth spending some effort to get a good error message.
            tmp = nth(i+1)
            snprintf(
                message, sizeof message,
                "%s argument of function %s should have type <to>, not <from>",
                tmp, signature_string)
            free(tmp)
            self->do_expression_and_implicit_cast(&call->args[i], signature->argtypes[i], message)

        for i = signature->nargs; i < call->nargs; i++:
            # This code runs for varargs, e.g. the things to format in printf().
            types = self->do_expression(&call->args[i])

            # TODO: do something to arrays

            if (
                (types->original_type->is_integer_type() and types->original_type->size_in_bits < 32)
                or types->original_type == &bool_type
            ):
                # Add implicit cast to signed int, just like in C.
                types->do_implicit_cast(int_type, Location{}, NULL)

            # TODO: cast float to double implicitly

        free(signature_string)
        return signature->return_type

    def do_increment_or_decrement(self, expression: AstExpression*, increment_or_decrement: byte*) -> Type*:
        assert strcmp(increment_or_decrement, "increment") == 0 or strcmp(increment_or_decrement, "decrement") == 0

        bad_expression_error_template: byte[50]
        sprintf(bad_expression_error_template, "cannot %s %%s", increment_or_decrement)
        ensure_can_take_address(&expression->operands[0], bad_expression_error_template)

        t = self->do_expression(&expression->operands[0])->original_type
        if not t->is_integer_type() and not t->is_pointer_type():
            error: byte* = malloc(strlen(t->name) + 100)
            sprintf(error, "cannot %s a value of type %s", increment_or_decrement, t->name)
            fail(expression->location, error)
        return t

    def do_enum_member(self, location: Location, enum_name: byte*, member_name: byte*) -> Type*:
        message: byte[200]

        enum_type = self->file_types->find_type(enum_name)
        if enum_type == NULL:
            snprintf(message, sizeof message, "there is no type named '%s'", enum_name)
            fail(location, message)

        if enum_type->kind != TypeKind::Enum:
            snprintf(
                message, sizeof message,
                "the '::' syntax is only for enums, but %s is %s",
                enum_name, short_type_description(enum_type),
            )
            fail(location, message)

        if enum_type->enum_members.find_index(member_name) == -1:
            snprintf(message, sizeof message, "enum %s has no member named '%s'", enum_name, member_name)
            fail(location, message)

        return enum_type

    def do_instantiation(self, instantiation: AstInstantiation*) -> Type*:
        message:byte[500]

        t = self->file_types->find_type(instantiation->class_name)
        if t == NULL:
            snprintf(
                message, sizeof message,
                "there is no type named '%s'", instantiation->class_name,
            )
            fail(instantiation->class_name_location, message)

        if t->kind != TypeKind::Class:
            description = short_type_description(t)
            snprintf(
                message, sizeof message,
                "the %s{...} syntax is only for classes, but %s is %s",
                t->name, t->name, description,
            )
            fail(instantiation->class_name_location, message)

        specified_fields: ClassField** = malloc(sizeof specified_fields[0] * instantiation->nfields)
        for i = 0; i < instantiation->nfields; i++:
            snprintf(
                message, sizeof message,
                "value for field '%s' of class %s must be of type <to>, not <from>",
                instantiation->field_names[i], t->name,
            )
            specified_fields[i] = check_class_field(
                instantiation->field_values[i].location,
                t,
                instantiation->field_names[i],
            )
            self->do_expression_and_implicit_cast(
                &instantiation->field_values[i],
                specified_fields[i]->type,
                message,
            )

        for i1 = 0; i1 < instantiation->nfields; i1++:
            for i2 = i1+1; i2 < instantiation->nfields; i2++:
                if specified_fields[i1]->union_id == specified_fields[i2]->union_id:
                    snprintf(
                        message, sizeof message,
                        "fields '%s' and '%s' cannot be set simultaneously because they belong to the same union",
                        specified_fields[i1]->name,
                        specified_fields[i2]->name,
                    )
                    fail(instantiation->field_values[i2].location, message)

        return t

    def do_expression_maybe_void(self, expression: AstExpression*) -> ExpressionTypes*:
        result: Type*
        message: byte[200]

        if expression->kind == AstExpressionKind::String:
            result = byte_type->get_pointer_type()
        elif expression->kind == AstExpressionKind::Bool:
            result = &bool_type
        elif expression->kind == AstExpressionKind::Byte:
            result = byte_type
        elif expression->kind == AstExpressionKind::Short:
            result = short_type
        elif expression->kind == AstExpressionKind::Int:
            result = int_type
        elif expression->kind == AstExpressionKind::Long:
            result = long_type
        elif expression->kind == AstExpressionKind::Null:
            result = &void_ptr_type
        elif expression->kind == AstExpressionKind::FunctionCall:
            result = self->do_function_call(&expression->call)
            if result == NULL:
                return NULL
        elif expression->kind == AstExpressionKind::GetVariable:
            result = self->find_var(expression->varname)
            if result == NULL:
                snprintf(message, sizeof message, "no variable named '%s'", expression->varname)
                fail(expression->location, message)
        elif expression->kind == AstExpressionKind::As:
            old_type = self->do_expression(&expression->as_expression->value)->original_type
            result = type_from_ast(self->file_types, &expression->as_expression->type)
            check_explicit_cast(old_type, result, expression->location)
        elif expression->kind == AstExpressionKind::GetEnumMember:
            result = self->do_enum_member(
                expression->location,
                expression->enum_member.enum_name,
                expression->enum_member.member_name,
            )
        elif (
            expression->kind == AstExpressionKind::Add
            or expression->kind == AstExpressionKind::Subtract
            or expression->kind == AstExpressionKind::Multiply
            or expression->kind == AstExpressionKind::Divide
            or expression->kind == AstExpressionKind::Modulo
            or expression->kind == AstExpressionKind::Eq
            or expression->kind == AstExpressionKind::Ne
            or expression->kind == AstExpressionKind::Gt
            or expression->kind == AstExpressionKind::Ge
            or expression->kind == AstExpressionKind::Lt
            or expression->kind == AstExpressionKind::Le
        ):
            lhs_types = self->do_expression(&expression->operands[0])
            rhs_types = self->do_expression(&expression->operands[1])
            result = check_binop(expression->kind, expression->location, lhs_types, rhs_types)
        elif expression->kind == AstExpressionKind::Negate:
            result = self->do_expression(&expression->operands[0])->original_type
            # TODO: check for floats/doubles too
            if result->kind != TypeKind::SignedInteger:
                snprintf(
                    message, sizeof message,
                    "value after '-' must be a float or double or a signed integer, not %s",
                    result->name,
                )
                fail(expression->location, message)
        elif expression->kind == AstExpressionKind::PreIncr or expression->kind == AstExpressionKind::PostIncr:
            result = self->do_increment_or_decrement(expression, "increment")
        elif expression->kind == AstExpressionKind::PreDecr or expression->kind == AstExpressionKind::PostDecr:
            result = self->do_increment_or_decrement(expression, "decrement")
        elif expression->kind == AstExpressionKind::GetClassField:
            lhs_type = self->do_expression(expression->class_field.instance)->original_type
            if expression->class_field.uses_arrow_operator:
                if lhs_type->kind != TypeKind::Pointer or lhs_type->value_type->kind != TypeKind::Class:
                    snprintf(
                        message, sizeof message,
                        "left side of the '->' operator must be a pointer to a class, not %s",
                        lhs_type->name,
                    )
                    fail(expression->location, message)
                result = check_class_field(expression->location, lhs_type->value_type, expression->class_field.field_name)->type
            else:
                if lhs_type->kind != TypeKind::Class:
                    snprintf(
                        message, sizeof message,
                        "left side of the '.' operator must be an instance of a class, not %s",
                        lhs_type->name,
                    )
                    fail(expression->location, message)
                result = check_class_field(expression->location, lhs_type, expression->class_field.field_name)->type
        elif expression->kind == AstExpressionKind::AddressOf:
            result = self->do_expression(expression->operands)->original_type->get_pointer_type()
        elif expression->kind == AstExpressionKind::Instantiate:
            result = self->do_instantiation(&expression->instantiation)
        else:
            printf("*** %d\n", expression->kind as int)
            assert False

        p: ExpressionTypes* = malloc(sizeof *p)
        *p = ExpressionTypes{
            expression = expression,
            original_type = result,
            next = self->current_function_or_method->expression_types,
        }
        self->current_function_or_method->expression_types = p
        return p

    def do_expression(self, expression: AstExpression*) -> ExpressionTypes*:
        types = self->do_expression_maybe_void(expression)
        if types == NULL:
            assert expression->kind == AstExpressionKind::FunctionCall
            name = expression->call.called_name
            message = malloc(strlen(name) + 100)
            sprintf(message, "function '%s' does not return a value", name)
            fail(expression->location, message)
        return types

    def do_expression_and_implicit_cast(
        self,
        expression: AstExpression*,
        cast_type: Type*,
        error_message_template: byte*,
    ) -> ExpressionTypes*:
        types = self->do_expression(expression)
        types->do_implicit_cast(cast_type, expression->location, error_message_template)
        return types

    def do_statement(self, statement: AstStatement*) -> void:
        if statement->kind == AstStatementKind::ExpressionStatement:
            self->do_expression_maybe_void(&statement->expression)

        elif statement->kind == AstStatementKind::Return:
            sig = &self->current_function_or_method->signature

            # TODO: check for noreturn functions

            msg: byte[500]

            if statement->return_value != NULL and sig->return_type == NULL:
                snprintf(
                    msg, sizeof msg,
                    "%s '%s' cannot return a value because it was defined with '-> void'",
                    sig->function_or_method(), sig->name,
                )
                fail(statement->location, msg)
            if statement->return_value == NULL and sig->return_type != NULL:
                snprintf(
                    msg, sizeof msg,
                    "%s '%s' must return a value because it was defined with '-> %s'",
                    sig->function_or_method(), sig->name, sig->return_type->name,
                )
                fail(statement->location, msg)

            if statement->return_value != NULL:
                cast_error_msg: byte[500]
                snprintf(
                    cast_error_msg, sizeof cast_error_msg,
                    "attempting to return a value of type <from> from %s '%s' defined with '-> <to>'",
                    sig->function_or_method(), sig->name,
                )
                self->do_expression_and_implicit_cast(
                    statement->return_value, sig->return_type, cast_error_msg
                )

        elif statement->kind == AstStatementKind::Assign:
            target_expr = &statement->assignment.target
            value_expr = &statement->assignment.value

            if (
                target_expr->kind == AstExpressionKind::GetVariable
                and self->find_var(target_expr->varname) == NULL
            ):
                # Making a new variable. Use the type of the value being assigned.
                types = self->do_expression(value_expr)
                self->add_local_var(target_expr->varname, types->original_type)
            else:
                # Convert value to the type of an existing variable or other assignment target.
                ensure_can_take_address(target_expr, "cannot assign to %s")

                # This is a common error, so try to produce a helpful error message.
                error_template: byte[500]
                if target_expr->kind == AstExpressionKind::Dereference:
                    strcpy(
                        error_template,
                        "cannot place a value of type <from> into a pointer of type <to>*",
                    )
                else:
                    target_description: byte[200] = short_expression_description(target_expr)
                    snprintf(
                        error_template, sizeof error_template,
                        "cannot assign a value of type <from> to %s of type <to>",
                        target_description,
                    )

                target_types = self->do_expression(target_expr)
                self->do_expression_and_implicit_cast(value_expr, target_types->original_type, error_template)

        elif statement->kind == AstStatementKind::DeclareLocalVar:
            ntv: AstNameTypeValue* = &statement->var_declaration
            if self->find_var(ntv->name) != NULL:
                message: byte[200]
                snprintf(message, sizeof message, "a variable named '%s' already exists", ntv->name)
                fail(statement->location, message)

            type = type_from_ast(self->file_types, &ntv->type)
            self->add_local_var(ntv->name, type)
            if ntv->value != NULL:
                self->do_expression_and_implicit_cast(
                    ntv->value, type,
                    "initial value for variable of type TO cannot be of type FROM",
                )

        elif statement->kind == AstStatementKind::If:
            for i = 0; i < statement->if_statement.n_if_and_elifs; i++:
                self->do_expression_and_implicit_cast(
                    &statement->if_statement.if_and_elifs[i].condition,
                    &bool_type,
                    "'if' condition must be a boolean, not <from>",
                )
                self->do_body(&statement->if_statement.if_and_elifs[i].body)
            self->do_body(&statement->if_statement.else_body)

        elif statement->kind == AstStatementKind::WhileLoop:
            self->do_expression_and_implicit_cast(
                &statement->while_loop.condition, &bool_type,
                "'while' condition must be a boolean, not <from>",
            )
            self->nested_loop_count++
            self->do_body(&statement->while_loop.body)
            self->nested_loop_count--

        elif statement->kind == AstStatementKind::ForLoop:
            self->do_statement(statement->for_loop.init)
            self->do_expression_and_implicit_cast(
                &statement->for_loop.cond, &bool_type,
                "'for' condition must be a boolean, not <from>",
            )
            self->nested_loop_count++
            self->do_body(&statement->for_loop.body)
            self->nested_loop_count--
            self->do_statement(statement->for_loop.incr)

        elif statement->kind == AstStatementKind::Pass:
            pass
        
        elif statement->kind == AstStatementKind::Break:
            if self->nested_loop_count == 0:
                fail(statement->location, "'break' can only be used inside a loop")

        elif statement->kind == AstStatementKind::Continue:
            if self->nested_loop_count == 0:
                fail(statement->location, "'continue' can only be used inside a loop")

        else:
            printf("*** typecheck: unknown statement kind %d\n", statement->kind)
            assert False

    def do_body(self, body: AstBody*) -> void:
        for i = 0; i < body->nstatements; i++:
            self->do_statement(&body->statements[i])


def typecheck_stage3_function_and_method_bodies(file_types: FileTypes*, ast_file: AstFile*) -> void:
    checker = Stage3TypeChecker{file_types = file_types}
    for i = 0; i < ast_file->body_len; i++:
        ts = &ast_file->body[i]
        if ts->kind != AstToplevelStatementKind::Function or ts->function.body.nstatements == 0:
            continue

        sig = file_types->find_function(ts->function.signature.name)
        assert sig != NULL

        assert checker.current_function_or_method == NULL
        file_types->defined_functions = realloc(file_types->defined_functions, (file_types->n_defined_functions + 1) * sizeof file_types->defined_functions[0])
        checker.current_function_or_method = &file_types->defined_functions[file_types->n_defined_functions++]
        *checker.current_function_or_method = FunctionOrMethodTypes{signature = sig->copy()}

        for k = 0; k < sig->nargs; k++:
            checker.add_local_var(sig->argnames[k], sig->argtypes[k])

        checker.do_body(&ts->function.body)
        checker.current_function_or_method = NULL
