from "stdlib/mem.jou" import free
from "./errors_and_warnings.jou" import Location

class AstFile:
    body: AstToplevelStatement*
    body_len: int

    def free(self: AstFile*) -> void:
        for i = 0; i < self->body_len; i++:
            (&self->body[i]).free()
        free(self->body)

enum AstToplevelStatementKind:
    Import
    DefineFunction

class AstToplevelStatement:
    kind: AstToplevelStatementKind

    # TODO: union
    the_import: AstImport
    funcdef: AstFunctionDef

    def free(self: AstToplevelStatement*) -> void:
        if self->kind == AstToplevelStatementKind::Import:
            (&self->the_import).free()

class AstImport:
    filename: byte*
    symbol: byte[100]

    def free(self: AstImport*) -> void:
        free(self->filename)

enum AstTypeKind:
    Named
    Pointer
    Array

class AstArrayType:
    membertype: AstType*
    len: int

    def free(self: AstArrayType*) -> void:
        self->membertype.free()
        free(self->membertype)

class AstType:
    kind: AstTypeKind
    location: Location

    # TODO: union
    name: byte[100]     # AstTypeKind::Named
    valuetype: AstType* # AstTypeKind::Pointer
    array: AstArrayType # AstTypeKind::Array

    def free(self: AstType*) -> void:
        if self->kind == AstTypeKind::Pointer:
            self->valuetype.free()
            free(self->valuetype)
        if self->kind == AstTypeKind::Array:
            (&self->array).free()

class AstSignature:
    funcname_location: Location
    funcname: byte[100]
    returntype: AstType

    def free(self: AstSignature*) -> void:
        (&self->returntype).free()

class AstFunctionDef:
    signature: AstSignature
    body: AstBody

    def free(self: AstFunctionDef*) -> void:
        (&self->signature).free()
        (&self->body).free()

class AstBody:
    statements: AstStatement*
    nstatements: int

    def free(self: AstBody*) -> void:
        for i = 0; i < self->nstatements; i++:
            (&self->statements[i]).free()
        free(self->statements)

enum AstStatementKind:
    ExpressionStatement  # Evaluate an expression. Discard the result.

class AstStatement:
    location: Location
    kind: AstStatementKind

    # TODO: union
    expression: AstExpression  # AstStatementKind::ExpressionStatement

    def free(self: AstStatement*) -> void:
        if self->kind == AstStatementKind::ExpressionStatement:
            (&self->expression).free()

class AstExpression:
    todo: int

    def free(self: AstExpression*) -> void:
        return
