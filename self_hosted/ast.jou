from "stdlib/io.jou" import printf
from "stdlib/mem.jou" import free
from "./errors_and_warnings.jou" import Location, assert

class AstFile:
    path: byte*  # not owned
    body: AstToplevelStatement*
    body_len: int

    def print(self: AstFile*) -> void:
        printf("===== AST for file \"%s\" =====\n", self->path)
        for i = 0; i < self->body_len; i++:
            (&self->body[i]).print()

    def free(self: AstFile*) -> void:
        for i = 0; i < self->body_len; i++:
            (&self->body[i]).free()
        free(self->body)

enum AstToplevelStatementKind:
    Import
    DefineFunction

class AstToplevelStatement:
    kind: AstToplevelStatementKind
    location: Location

    # TODO: union
    the_import: AstImport
    funcdef: AstFunctionDef

    def print(self: AstToplevelStatement*) -> void:
        printf("line %d: ", self->location.lineno)
        if self->kind == AstToplevelStatementKind::Import:
            printf("Import \"%s\" from \"%s\".\n", &self->the_import.symbol[0], self->the_import.path)
        elif self->kind == AstToplevelStatementKind::DefineFunction:
            printf("hi\n")
        else:
            assert(False)
        printf("\n")

    def free(self: AstToplevelStatement*) -> void:
        if self->kind == AstToplevelStatementKind::Import:
            (&self->the_import).free()

class AstImport:
    path: byte*
    symbol: byte[100]

    def free(self: AstImport*) -> void:
        free(self->path)

enum AstTypeKind:
    Named
    Pointer
    Array

class AstArrayType:
    membertype: AstType*
    len: int

    def free(self: AstArrayType*) -> void:
        self->membertype.free()
        free(self->membertype)

class AstType:
    kind: AstTypeKind
    location: Location

    # TODO: union
    name: byte[100]     # AstTypeKind::Named
    valuetype: AstType* # AstTypeKind::Pointer
    array: AstArrayType # AstTypeKind::Array

    def free(self: AstType*) -> void:
        if self->kind == AstTypeKind::Pointer:
            self->valuetype.free()
            free(self->valuetype)
        if self->kind == AstTypeKind::Array:
            (&self->array).free()

class AstSignature:
    funcname_location: Location
    funcname: byte[100]
    returntype: AstType

    def free(self: AstSignature*) -> void:
        (&self->returntype).free()

class AstFunctionDef:
    signature: AstSignature
    body: AstBody

    def free(self: AstFunctionDef*) -> void:
        (&self->signature).free()
        (&self->body).free()

class AstBody:
    statements: AstStatement*
    nstatements: int

    def free(self: AstBody*) -> void:
        for i = 0; i < self->nstatements; i++:
            (&self->statements[i]).free()
        free(self->statements)

enum AstStatementKind:
    ExpressionStatement  # Evaluate an expression. Discard the result.

class AstStatement:
    location: Location
    kind: AstStatementKind

    # TODO: union
    expression: AstExpression  # AstStatementKind::ExpressionStatement

    def free(self: AstStatement*) -> void:
        if self->kind == AstStatementKind::ExpressionStatement:
            (&self->expression).free()

enum AstExpressionKind:
    String
    Int
    FunctionCall

class AstExpression:
    location: Location
    kind: AstExpressionKind

    # TODO: union
    string_value: byte*
    int_value: int
    call: AstCall

    def free(self: AstExpression*) -> void:
        if self->kind == AstExpressionKind::FunctionCall:
            (&self->call).free()
        if self->kind == AstExpressionKind::String:
            free(self->string_value)

class AstCall:
    called_name: byte[100]  # e.g. name of function, name of class to instantiate
    nargs: int
    args: AstExpression*

    def free(self: AstCall*) -> void:
        for i = 0; i < self->nargs; i++:
            (&self->args[i]).free()
        free(self->args)
