import "stdlib/io.jou"

typedef MyInt = int

def main() -> int:
    b: byte = 'a'
    i: int = 123

    # It should recognize byte and uint8 as the same, casts between them cause warnings
    # Output: 97
    # Output: 97
    # Output: 97
    printf("%d\n", b as byte)  # Warning: unnecessary cast from byte to byte
    printf("%d\n", b as uint8)  # Warning: unnecessary cast from byte to byte
    printf("%d\n", b as int)

    # Same with pointers
    # Output: 97
    # Output: 97
    printf("%d\n", *(&b as byte*))  # Warning: unnecessary cast from byte* to byte*
    printf("%d\n", *(&b as uint8*))  # Warning: unnecessary cast from byte* to byte*

    # It should recognize int and int32 as the same
    # Output: 123
    # Output: 123
    # Output: 123
    printf("%d\n", i as int)  # Warning: unnecessary cast from int to int
    printf("%d\n", i as int32)  # Warning: unnecessary cast from int to int
    printf("%u\n", i as uint32)

    # Same with pointers
    # Output: 123
    # Output: 123
    printf("%d\n", *(&i as int*))  # Warning: unnecessary cast from int* to int*
    printf("%d\n", *(&i as int32*))  # Warning: unnecessary cast from int* to int*

    # With a typedef, there are no warnings, because typedefs are often used in
    # platform-specific code.
    # Output: 1234
    # Output: 1234
    # Output: 1234
    # Output: 1234
    m: MyInt = 1234
    printf("%d\n", m as int)
    printf("%d\n", m as int32)
    printf("%d\n", *(&m as int*))
    printf("%d\n", *(&m as int32*))

    return 0
