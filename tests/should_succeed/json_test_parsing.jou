import "stdlib/assert.jou"
import "stdlib/io.jou"
import "stdlib/mem.jou"
import "stdlib/json.jou"
import "stdlib/str.jou"


def test_array_validate() -> None:
    assert is_valid_json("[]")
    assert is_valid_json("[\"string has bracket\", \"[\"]")
    assert is_valid_json("[\"string has bracket\", \"]\"]")
    assert is_valid_json("[1, 2, 3]")
    assert is_valid_json("  [ \t\r\n ]  ")

    assert not is_valid_json("[")
    assert not is_valid_json("]")
    assert not is_valid_json("][")
    assert not is_valid_json("[][]")
    assert not is_valid_json("[[]")
    assert not is_valid_json("[[]]]")
    assert not is_valid_json("[a]")
    assert not is_valid_json("[Ã¶]")
    assert not is_valid_json("[']")

    # Depth 64, allowed but just barely
    assert is_valid_json("[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[1, 2, 3]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]")

    # Depth 65
    assert not is_valid_json("[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[1, 2, 3]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]")


def test_object_validate() -> None:
    assert is_valid_json("{\"foo\": \"bar\"}")
    assert is_valid_json("{\"a\":1,\"b\":2}")
    assert is_valid_json("{\"a\":{}}")
    assert is_valid_json("{}")
    assert is_valid_json("{\"nested\":{\"whatever\":{}}}")
    assert is_valid_json("  {  \"white\"  :  \"space\"  ,  \"empty\"  :  { \t\r\n }  }  ")
    assert is_valid_json(" { } ")
    assert is_valid_json("{\"string has brace\": \"{\"}")
    assert is_valid_json("{\"string has brace\": \"}\"}")

    assert not is_valid_json("{")
    assert not is_valid_json("}")
    assert not is_valid_json("}{")
    assert not is_valid_json("{}{}")
    assert not is_valid_json("{\"a\":{}")
    assert not is_valid_json("{}}")
    assert not is_valid_json("{\"foo\":}")
    assert not is_valid_json("{ : \"bar\"}")
    assert not is_valid_json("{,}")
    assert not is_valid_json("{\"trailing\": \"comma\",}")
    assert not is_valid_json("{\"trailing\": \"comma\", \"multiple\": \"items\",}")
    assert not is_valid_json("{1}")
    assert not is_valid_json("{1,2}")
    assert not is_valid_json("{1: 2}")
    assert not is_valid_json("{true: 2}")
    assert not is_valid_json("{null: 2}")
    assert not is_valid_json("{whatever: 2}")
    assert not is_valid_json("{\"lol\": 1, 69: 2}")
    assert not is_valid_json("{{}}")
    assert not is_valid_json("{}junk")

    # Depth 64, allowed but just barely
    assert is_valid_json("\
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
123 \
}}}}}}}} }}}}}}}} }}}}}}}} }}}}}}}} }}}}}}}} }}}}}}}} }}}}}}}} }}}}}}}}")

    # Depth 65
    assert not is_valid_json("\
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
{\"a\": 123} \
}}}}}}}} }}}}}}}} }}}}}}}} }}}}}}}} }}}}}}}} }}}}}}}} }}}}}}}} }}}}}}}}")


def test_array_iter() -> None:
    nothing_to_iterate = [NULL, "", "[", "]", "[]", "{}", "{\"a\":1}", "123", ",123", "true"]
    for i = 0; i < array_count(nothing_to_iterate); i++:
        assert json_array_first(nothing_to_iterate[i]) == NULL
        assert json_array_next(nothing_to_iterate[i]) == NULL

    assert json_array_first("123, 456") == NULL
    assert json_array_next("123, 456") != NULL

    assert json_array_first("[1]") != NULL
    assert json_array_next("[1]") == NULL

    # Output: 1, 2, 3]
    # Output: 2, 3]
    # Output: 3]
    for j = json_array_first("[1, 2, 3]"); j != NULL; j = json_array_next(j):
        puts(j)

    # Output: 1 , 2 , 3 ] junk at end allowed
    # Output: 2 , 3 ] junk at end allowed
    # Output: 3 ] junk at end allowed
    for j = json_array_first(" \t\r\n [ 1 , 2 , 3 ] junk at end allowed"); j != NULL; j = json_array_next(j):
        puts(j)

    # Output: {"a": 1}, ["b", 2], 3.14]
    # Output: ["b", 2], 3.14]
    # Output: 3.14]
    for j = json_array_first("[{\"a\": 1}, [\"b\", 2], 3.14]"); j != NULL; j = json_array_next(j):
        puts(j)


def test_object_iter() -> None:
    nothing_to_iterate = [NULL, "", "[", "]", "{", "}", "[]", "{}", "[1,2,3]", "123:", "123,", "true"]
    for i = 0; i < array_count(nothing_to_iterate); i++:
        assert json_object_first(nothing_to_iterate[i]) == NULL
        assert json_object_next(nothing_to_iterate[i]) == NULL

    key: byte[100]

    # Output: a --> 1,"b":2}
    # Output: b --> 2}
    for item = json_object_first("{\"a\":1,\"b\":2}"); item != NULL; item = json_object_next(item):
        string_from_json(item, key, sizeof(key))
        printf("%s --> %s\n", key, json_object_value(item))

    # Output: one --> 1
    # Output: two --> 2
    for item = json_object_first("{ \"one\" : 1 , \"t\\u0077o\" : 2 } junk at end"); item != NULL; item = json_object_next(item):
        string_from_json(item, key, sizeof(key))
        printf("%s --> %d\n", key, atoi(json_object_value(item)))


def test_get() -> None:
    json = "{\"not this\": 1, \"level1\": {\"not this either\": 2, \"level2\": {\"le\\u0076el3\": 3, \"yet another thing we don't want\": 4}}}"
    assert is_valid_json(json)

    # Make sure it's not finding anything it's not supposed to find
    assert json_get(json, "level") == NULL
    assert json_get(json, "level1") != NULL
    assert json_get(json, "level11") == NULL

    p = json_get(json_get(json_get(json, "level1"), "level2"), "level3")
    assert p != NULL
    printf("%c\n", *p)  # Output: 3

    # If anything is not found, NULL should bubble through
    assert json_get(json_get(json_get(json, "lol"), "level2"), "level3") == NULL
    assert json_get(json_get(json_get(json, "level1"), "lol"), "level3") == NULL
    assert json_get(json_get(json_get(json, "level1"), "level2"), "lol") == NULL


def test_strings() -> None:
    buf: byte[100]

    simple_valid_strings = [
        "\"\"",                 # Output:
        "\"hello\"",            # Output: hello
        "  \"hello\" \t\r\n ",  # Output: hello
        "\"hello 123!!!! Blah Blah: 'bleh'.\"",     # Output: hello 123!!!! Blah Blah: 'bleh'.
        "\"hello \\\"world\\\" test\"",             # Output: hello "world" test
        "\"forward slash \\/ / can be escaped\"",   # Output: forward slash / / can be escaped
        "\"backslash \\\\ must be escaped\"",       # Output: backslash \ must be escaped
        "\"More symbols: +-*/`'@?!\\\"\"",          # Output: More symbols: +-*/`'@?!"
    ]
    for i = 0; i < array_count(simple_valid_strings); i++:
        assert is_valid_json(simple_valid_strings[i])
        ret = string_from_json(simple_valid_strings[i], buf, sizeof(buf))
        assert ret < sizeof(buf)
        assert ret == strlen(buf)
        puts(buf)

    # These are not printed in case printing unicodes doesn't work on e.g. windows
    fancy_valid_strings = [
        ["\"escapes \\t\\r\\n\\f\\b\"", "escapes \t\r\n\x0c\x08"],
        ["\"the DEL character \x7f aka \\u007f is allowed as is!\"", "the DEL character \x7f aka \x7f is allowed as is!"],
        ["\"non-ASCII like Ã¶â‚¬Â£ðŸ’¸ is valid as is\"", "non-ASCII like Ã¶â‚¬Â£ðŸ’¸ is valid as is"],
        ["\"can be escaped too: \\u00f6\\u20ac\\u00a3\\ud83d\\udcb8\"", "can be escaped too: Ã¶â‚¬Â£ðŸ’¸"],
        ["\"\\u004a\\u00f6u\"", "JÃ¶u"],
    ]
    for i = 0; i < array_count(fancy_valid_strings); i++:
        json = fancy_valid_strings[i][0]
        expected_value = fancy_valid_strings[i][1]
        assert is_valid_json(json)
        ret = string_from_json(json, buf, sizeof(buf))
        assert ret < sizeof(buf)
        assert ret == strlen(buf)
        assert strcmp(buf, expected_value) == 0

    invalid_strings = [
        "'hello'",
        "\"hello",
        "\"multiline \n string\"",
        "\"lack of escaping \r\"",
        "\"lack of escaping \t\"",
        "\"backslash \\ not escaped\"",
        "\"two-byte hex \\x4a is not allowed\"",
        "\"ASCII control character \x1b\"",
        "\"ASCII control character \x1f\"",
        "\"invalid u escape \\ujouu\"",
        "\"truncated u escape \\uaa\"",
        "\"missing second half of u-escaped surrogate pair \\ud83d",
        "\"missing second half of u-escaped surrogate pair \\ud83d\"",
        "\"missing second half of u-escaped surrogate pair \\ud83dlol\"",
        # TODO: Currently the JSON parser accepts UTF-16 surrogate pairs that
        #       represent a codepoint that could be written without surrogate
        #       pairs. This is like overlong UTF-8 and should probably be
        #       rejected. But this isn't security critical like invalid UTF-8,
        #       because there are multiple ways to write the same JSON anyway.
        "\"this \xc3 is invalid UTF-8 (truncated)\"",
        "\"this \xf0\x82\x82\xac is invalid UTF-8 (overlong)\"",
    ]
    for i = 0; i < array_count(invalid_strings); i++:
        assert not is_valid_json(invalid_strings[i])
        memset(buf, 123, sizeof(buf))
        assert string_from_json(invalid_strings[i], buf, sizeof(buf)) == -1
        assert buf[0] == '\0'  # if buf contained garbage, you won't accidentally use it

    # Valid JSON but not string
    assert string_from_json("[1,2,3]", buf, sizeof(buf)) == -1
    assert string_from_json("{}", buf, sizeof(buf)) == -1
    assert string_from_json("true", buf, sizeof(buf)) == -1

    # Test truncating
    memset(buf, 123, sizeof(buf))
    assert string_from_json("\"hello\"", buf, 6) == 5
    puts(buf)  # Output: hello
    assert buf[6] == 123  # not overwritten

    assert string_from_json("\"hello\"", buf, 5) == 5
    puts(buf)  # Output: hell
    assert string_from_json("\"hello\"", buf, 2) == 5
    puts(buf)  # Output: h
    assert string_from_json("\"hello\"", buf, 1) == 5
    assert buf[0] == '\0'  # empty string now

    buf[0] = 123 as byte
    assert string_from_json("\"hello\"", buf, 0) == 5
    assert buf[0] == 123 as byte  # not overwritten
    assert string_from_json("\"hello\"", buf, -1) == 5
    assert buf[0] == 123 as byte  # not overwritten


def test_bools_and_null() -> None:
    assert is_valid_json("true")
    assert is_valid_json("false")
    assert is_valid_json("null")
    assert not is_valid_json("True")
    assert not is_valid_json("TRUE")
    assert not is_valid_json("fals")
    assert not is_valid_json("nullava")

    assert json_is_true("true")
    assert json_is_false("false")
    assert json_is_null("null")

    assert json_is_true("true,\"other\",\"stuff\"]")
    assert json_is_false("false,\"other\",\"stuff\"]")
    assert json_is_null("null,\"other\",\"stuff\"]")

    assert json_is_true(" \t\r\n true,\"other\",\"stuff\"]")
    assert json_is_false(" \t\r\n false,\"other\",\"stuff\"]")
    assert json_is_null(" \t\r\n null,\"other\",\"stuff\"]")

    assert not json_is_true(NULL)
    assert not json_is_false(NULL)
    assert not json_is_null(NULL)

    assert not json_is_true("0")
    assert not json_is_false("0")
    assert not json_is_null("0")

    assert not json_is_true("1")
    assert not json_is_false("1")
    assert not json_is_null("1")

    assert not json_is_true("tru")
    assert not json_is_false("fals")
    assert not json_is_null("nul")

    assert not json_is_true("false")
    assert not json_is_true("null")
    assert not json_is_false("true")
    assert not json_is_false("null")
    assert not json_is_null("true")
    assert not json_is_null("false")


def is_nan(d: double) -> bool:
    return d != d


def test_numbers() -> None:
    valid_numbers = [
        "3.14",             # Output: 3.14
        "2.5",              # Output: 2.5
        "0",                # Output: 0
        "-0",               # Output: -0
        "-0.0e+0",          # Output: -0
        "123123123123123123123123123123",  # Output: 1.23123e+29
        "1e5",              # Output: 100000
        "-1E+5",            # Output: -100000
        "-1.23E+4",         # Output: -12300
        "1.23E-4",          # Output: 0.000123
        "-1.23e-4",         # Output: -0.000123
        "1.23e+4",          # Output: 12300
        "  123 \t\r\n ",    # Output: 123
    ]

    for i = 0; i < array_count(valid_numbers); i++:
        assert is_valid_json(valid_numbers[i])
        if LINUX:
            # The setlocale() below exposes bugs in json.jou, but also changes
            # what %g prints here... annoying
            s: byte[100]
            sprintf(s, "%g", double_from_json(valid_numbers[i]))
            if strstr(s, ",") != NULL:
                *strstr(s, ",") = '.'
            # Windows likes to say e+029 instead of e+29
            if WINDOWS and strstr(s, "e+029") != NULL:
                p = strstr(s, "e+029")
                memmove(&p[2], &p[3], strlen(&p[3]) + 1)
            puts(s)
        else:
            printf("%g\n", double_from_json(valid_numbers[i]))

    # Technically Infinity and NaN are not valid JSON, but many libraries
    # support them to some extent so we support them too.
    assert is_valid_json("Infinity")
    assert is_valid_json("-Infinity")
    assert is_valid_json("NaN")

    inf = double_from_json("Infinity")
    assert inf == inf * 0.1
    assert double_from_json("-Infinity") == -inf
    assert is_nan(double_from_json("NaN"))

    invalid_numbers = [
        NULL,
        "+2.5",
        "+0",
        "+5",
        "+1.23E+4",
        "+1.23E-4",
        "+1.23e+4",
        "+1.23e-4",
        "1ee2",
        "--1",
        "infinity",
        "Inf",
        "-infinity",
        "-Inf",
        "nan",
        "Na",
        "NaNa",
    ]

    for i = 0; i < array_count(invalid_numbers); i++:
        assert not is_valid_json(invalid_numbers[i])
        if not is_nan(double_from_json(invalid_numbers[i])):
            puts(invalid_numbers[i])
        assert is_nan(double_from_json(invalid_numbers[i]))

    # Sometimes double_from_json() may parse a part of an otherwise invalid number.
    assert not is_valid_json("00")
    assert double_from_json("00") == 0
    assert not is_valid_json("01")
    assert double_from_json("01") == 1
    assert not is_valid_json("09")
    assert double_from_json("09") == 9
    assert not is_valid_json("1.23J4")
    assert double_from_json("1.23J4") == 1.23
    assert not is_valid_json("1e2.3")
    assert double_from_json("1e2.3") == 1e2
    assert not is_valid_json("1.2.3")
    assert double_from_json("1.2.3") == 1.2
    assert not is_valid_json("5k")
    assert double_from_json("5k") == 5
    assert not is_valid_json("Infinityyyy")
    assert double_from_json("Infinityyyy") == 1.0 / 0.0
    assert not is_valid_json("-Infinityyyy")
    assert double_from_json("-Infinityyyy") == -1.0 / 0.0


def test_json_from_github_api() -> None:
    file_content: byte[10000]

    f = fopen("tests/data/jou_github_release.json", "rb")
    assert f != NULL
    n = fread(file_content, 1, sizeof(file_content), f)
    fclose(f)

    assert n < sizeof(file_content)
    file_content[n] = '\0'

    assert is_valid_json(file_content)
    assert not is_valid_json(&file_content[1])

    for asset = json_array_first(json_get(file_content, "assets")); asset != NULL; asset = json_array_next(asset):
        uploader_name, asset_name: byte[100]
        string_from_json(json_get(json_get(asset, "uploader"), "login"), uploader_name, sizeof(uploader_name))
        string_from_json(json_get(asset, "name"), asset_name, sizeof(asset_name))

        # Output: github-actions[bot] uploaded jou_windows_64bit_2026-02-09-0500.zip
        printf("%s uploaded %s\n", uploader_name, asset_name)


def main() -> int:
    test_array_validate()
    test_object_validate()
    test_array_iter()
    test_object_iter()
    test_get()
    test_bools_and_null()
    test_strings()
    test_numbers()
    test_json_from_github_api()

    puts("ok")  # Output: ok
    return 0
