import "stdlib/assert.jou"
import "stdlib/io.jou"
import "stdlib/mem.jou"
import "stdlib/json.jou"
import "stdlib/str.jou"


def test_array_validate() -> None:
    assert json_is_valid("[]")
    assert json_is_valid("[\"string has bracket\", \"[\"]")
    assert json_is_valid("[\"string has bracket\", \"]\"]")
    assert json_is_valid("[1, 2, 3]")
    assert json_is_valid("  [ \t\r\n ]  ")

    assert not json_is_valid("[")
    assert not json_is_valid("]")
    assert not json_is_valid("][")
    assert not json_is_valid("[][]")
    assert not json_is_valid("[[]")
    assert not json_is_valid("[[]]]")
    assert not json_is_valid("[a]")
    assert not json_is_valid("[Ã¶]")
    assert not json_is_valid("[']")

    # Depth 64, allowed but just barely
    assert json_is_valid("[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[1, 2, 3]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]")

    # Depth 65
    assert not json_is_valid("[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[1, 2, 3]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]")


def test_object_validate() -> None:
    assert json_is_valid("{\"foo\": \"bar\"}")
    assert json_is_valid("{\"a\":1,\"b\":2}")
    assert json_is_valid("{\"a\":{}}")
    assert json_is_valid("{}")
    assert json_is_valid("{\"nested\":{\"whatever\":{}}}")
    assert json_is_valid("  {  \"white\"  :  \"space\"  ,  \"empty\"  :  { \t\r\n }  }  ")
    assert json_is_valid(" { } ")
    assert json_is_valid("{\"string has brace\": \"{\"}")
    assert json_is_valid("{\"string has brace\": \"}\"}")

    assert not json_is_valid("{")
    assert not json_is_valid("}")
    assert not json_is_valid("}{")
    assert not json_is_valid("{}{}")
    assert not json_is_valid("{\"a\":{}")
    assert not json_is_valid("{}}")
    assert not json_is_valid("{\"foo\":}")
    assert not json_is_valid("{ : \"bar\"}")
    assert not json_is_valid("{,}")
    assert not json_is_valid("{\"trailing\": \"comma\",}")
    assert not json_is_valid("{\"trailing\": \"comma\", \"multiple\": \"items\",}")
    assert not json_is_valid("{1}")
    assert not json_is_valid("{1,2}")
    assert not json_is_valid("{1: 2}")
    assert not json_is_valid("{true: 2}")
    assert not json_is_valid("{null: 2}")
    assert not json_is_valid("{whatever: 2}")
    assert not json_is_valid("{\"lol\": 1, 69: 2}")
    assert not json_is_valid("{{}}")
    assert not json_is_valid("{}junk")

    # Depth 64, allowed but just barely
    assert json_is_valid("\
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
123 \
}}}}}}}} }}}}}}}} }}}}}}}} }}}}}}}} }}}}}}}} }}}}}}}} }}}}}}}} }}}}}}}}")

    # Depth 65
    assert not json_is_valid("\
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\":{\"a\": \
{\"a\": 123} \
}}}}}}}} }}}}}}}} }}}}}}}} }}}}}}}} }}}}}}}} }}}}}}}} }}}}}}}} }}}}}}}}")


def test_array_iter() -> None:
    nothing_to_iterate = [NULL, "", "[", "]", "[]", "{}", "{\"a\":1}", "123", ",123", "true"]
    for i = 0; i < array_count(nothing_to_iterate); i++:
        assert json_array_first(nothing_to_iterate[i]) == NULL
        assert json_array_next(nothing_to_iterate[i]) == NULL

    assert json_array_first("123, 456") == NULL
    assert json_array_next("123, 456") != NULL

    assert json_array_first("[1]") != NULL
    assert json_array_next("[1]") == NULL

    # Output: 1, 2, 3]
    # Output: 2, 3]
    # Output: 3]
    for j = json_array_first("[1, 2, 3]"); j != NULL; j = json_array_next(j):
        puts(j)

    # Output: 1 , 2 , 3 ] junk at end allowed
    # Output: 2 , 3 ] junk at end allowed
    # Output: 3 ] junk at end allowed
    for j = json_array_first(" \t\r\n [ 1 , 2 , 3 ] junk at end allowed"); j != NULL; j = json_array_next(j):
        puts(j)

    # Output: {"a": 1}, ["b", 2], 3.14]
    # Output: ["b", 2], 3.14]
    # Output: 3.14]
    for j = json_array_first("[{\"a\": 1}, [\"b\", 2], 3.14]"); j != NULL; j = json_array_next(j):
        puts(j)


def test_object_iter() -> None:
    nothing_to_iterate = [NULL, "", "[", "]", "{", "}", "[]", "{}", "[1,2,3]", "123:", "123,", "true"]
    for i = 0; i < array_count(nothing_to_iterate); i++:
        assert json_object_first(nothing_to_iterate[i]) == NULL
        assert json_object_next(nothing_to_iterate[i]) == NULL

    # Output: a --> 1,"b":2}
    # Output: b --> 2}
    for item = json_object_first("{\"a\":1,\"b\":2}"); item != NULL; item = json_object_next(item):
        key = json_to_string(item)
        printf("%s --> %s\n", key, json_object_value(item))
        free(key)

    # Output: one --> 1
    # Output: two --> 2
    for item = json_object_first("{ \"one\" : 1 , \"t\\u0077o\" : 2 } junk at end"); item != NULL; item = json_object_next(item):
        key = json_to_string(item)
        printf("%s --> %d\n", key, atoi(json_object_value(item)))
        free(key)


def test_get() -> None:
    json = "{\"not this\": 1, \"level1\": {\"not this either\": 2, \"level2\": {\"le\\u0076el3\": 3, \"yet another thing we don't want\": 4}}}"
    assert json_is_valid(json)

    # Make sure it's not finding anything it's not supposed to find
    assert json_get(json, "level") == NULL
    assert json_get(json, "level1") != NULL
    assert json_get(json, "level11") == NULL

    p = json_get(json_get(json_get(json, "level1"), "level2"), "level3")
    assert p != NULL
    printf("%c\n", *p)  # Output: 3

    # If anything is not found, NULL should bubble through
    assert json_get(json_get(json_get(json, "lol"), "level2"), "level3") == NULL
    assert json_get(json_get(json_get(json, "level1"), "lol"), "level3") == NULL
    assert json_get(json_get(json_get(json, "level1"), "level2"), "lol") == NULL


def test_strings() -> None:
    simple_valid_strings = [
        "\"\"",                 # Output:
        "\"hello\"",            # Output: hello
        "  \"hello\" \t\r\n ",  # Output: hello
        "\"hello 123!!!! Blah Blah: 'bleh'.\"",     # Output: hello 123!!!! Blah Blah: 'bleh'.
        "\"hello \\\"world\\\" test\"",             # Output: hello "world" test
        "\"forward slash \\/ / can be escaped\"",   # Output: forward slash / / can be escaped
        "\"backslash \\\\ must be escaped\"",       # Output: backslash \ must be escaped
        "\"More symbols: +-*/`'@?!\\\"\"",          # Output: More symbols: +-*/`'@?!"
    ]
    for i = 0; i < array_count(simple_valid_strings); i++:
        assert json_is_valid(simple_valid_strings[i])
        s = json_to_string(simple_valid_strings[i])
        assert s != NULL
        puts(s)
        assert json_equals_string(simple_valid_strings[i], s)
        free(s)

    # These are not printed in case printing unicodes doesn't work on e.g. windows
    fancy_valid_strings = [
        ["\"escapes \\t\\r\\n\\f\\b\"", "escapes \t\r\n\x0c\x08"],
        ["\"the DEL character \x7f aka \\u007f is allowed as is!\"", "the DEL character \x7f aka \x7f is allowed as is!"],
        ["\"non-ASCII like Ã¶â‚¬Â£ðŸ’¸ is valid as is\"", "non-ASCII like Ã¶â‚¬Â£ðŸ’¸ is valid as is"],
        ["\"can be escaped too: \\u00f6\\u20ac\\u00a3\\ud83d\\udcb8\"", "can be escaped too: Ã¶â‚¬Â£ðŸ’¸"],
        ["\"\\u004a\\u00f6u\"", "JÃ¶u"],
    ]
    for i = 0; i < array_count(fancy_valid_strings); i++:
        json = fancy_valid_strings[i][0]
        expected_value = fancy_valid_strings[i][1]
        assert json_is_valid(json)
        assert json_equals_string(json, expected_value)
        s = json_to_string(json)
        assert s != NULL
        assert strcmp(s, expected_value) == 0
        free(s)

    invalid_strings = [
        "'hello'",
        "\"hello",
        "\"multiline \n string\"",
        "\"lack of escaping \r\"",
        "\"lack of escaping \t\"",
        "\"backslash \\ not escaped\"",
        "\"two-byte hex \\x4a is not allowed\"",
        "\"ASCII control character \x1b\"",
        "\"ASCII control character \x1f\"",
        "\"invalid u escape \\ujouu\"",
        "\"truncated u escape \\uaa\"",
        "\"missing second half of u-escaped surrogate pair \\ud83d",
        "\"missing second half of u-escaped surrogate pair \\ud83d\"",
        "\"missing second half of u-escaped surrogate pair \\ud83dlol\"",
        # TODO: Currently the JSON parser accepts UTF-16 surrogate pairs that
        #       represent a codepoint that could be written without surrogate
        #       pairs. This is like overlong UTF-8 and should probably be
        #       rejected. But this isn't security critical like invalid UTF-8,
        #       because there are multiple ways to write the same JSON anyway.
        "\"this \xc3 is invalid UTF-8 (truncated)\"",
        "\"this \xf0\x82\x82\xac is invalid UTF-8 (overlong)\"",
    ]
    for i = 0; i < array_count(invalid_strings); i++:
        assert not json_is_valid(invalid_strings[i])
        assert json_to_string(invalid_strings[i]) == NULL

    # Valid JSON but not string
    assert json_to_string("[1,2,3]") == NULL
    assert json_to_string("{}") == NULL
    assert json_to_string("true") == NULL

    # Make sure that json_equals_string() doesn't accept anything it's not supposed to accept
    assert json_equals_string("\"foo\"", "foo")
    assert not json_equals_string("\"foo\"", "fo")
    assert not json_equals_string("\"foo\"", "Foo")
    assert not json_equals_string("\"foo\"", "goo")
    assert not json_equals_string("\"foo\"", "fooo")
    assert not json_equals_string("\"foo\"", NULL)
    assert not json_equals_string(NULL, "foo")
    assert not json_equals_string("foo", "\"foo\"")


def test_bools_and_null() -> None:
    assert json_is_valid("true")
    assert json_is_valid("false")
    assert json_is_valid("null")
    assert not json_is_valid("True")
    assert not json_is_valid("TRUE")
    assert not json_is_valid("fals")
    assert not json_is_valid("nullava")

    assert json_is_true("true")
    assert json_is_false("false")
    assert json_is_null("null")

    assert json_is_true("true,\"other\",\"stuff\"]")
    assert json_is_false("false,\"other\",\"stuff\"]")
    assert json_is_null("null,\"other\",\"stuff\"]")

    assert json_is_true(" \t\r\n true,\"other\",\"stuff\"]")
    assert json_is_false(" \t\r\n false,\"other\",\"stuff\"]")
    assert json_is_null(" \t\r\n null,\"other\",\"stuff\"]")

    assert not json_is_true(NULL)
    assert not json_is_false(NULL)
    assert not json_is_null(NULL)

    assert not json_is_true("0")
    assert not json_is_false("0")
    assert not json_is_null("0")

    assert not json_is_true("1")
    assert not json_is_false("1")
    assert not json_is_null("1")

    assert not json_is_true("tru")
    assert not json_is_false("fals")
    assert not json_is_null("nul")

    assert not json_is_true("false")
    assert not json_is_true("null")
    assert not json_is_false("true")
    assert not json_is_false("null")
    assert not json_is_null("true")
    assert not json_is_null("false")


def is_nan(d: double) -> bool:
    return d != d


def test_numbers() -> None:
    valid_numbers = [
        "3.14",             # Output: 3.14
        "2.5",              # Output: 2.5
        "0",                # Output: 0
        "-0",               # Output: -0
        "-0.0e+0",          # Output: -0
        "123123123123123123123123123123",  # Output: 1.23123e+29
        "1e5",              # Output: 100000
        "-1E+5",            # Output: -100000
        "-1.23E+4",         # Output: -12300
        "1.23E-4",          # Output: 0.000123
        "-1.23e-4",         # Output: -0.000123
        "1.23e+4",          # Output: 12300
        "  123 \t\r\n ",    # Output: 123
    ]

    for i = 0; i < array_count(valid_numbers); i++:
        assert json_is_valid(valid_numbers[i])
        if WINDOWS:
            # Windows likes to say e+029 instead of e+29
            s: byte[100]
            sprintf(s, "%g", json_to_double(valid_numbers[i]))
            if ends_with(s, "e+029"):
                strcpy(strrchr(s, 'e'), "e+29")
            puts(s)
        else:
            printf("%g\n", json_to_double(valid_numbers[i]))

    # Technically Infinity and NaN are not valid JSON, but many libraries
    # support them to some extent so we support them too.
    assert json_is_valid("Infinity")
    assert json_is_valid("-Infinity")
    assert json_is_valid("NaN")

    inf = json_to_double("Infinity")
    assert inf == inf * 0.1
    assert json_to_double("-Infinity") == -inf
    assert is_nan(json_to_double("NaN"))

    invalid_numbers = [
        NULL,
        "+2.5",
        "+0",
        "+5",
        "+1.23E+4",
        "+1.23E-4",
        "+1.23e+4",
        "+1.23e-4",
        "1ee2",
        "--1",
        "infinity",
        "Inf",
        "-infinity",
        "-Inf",
        "nan",
        "Na",
        "NaNa",
    ]

    for i = 0; i < array_count(invalid_numbers); i++:
        assert not json_is_valid(invalid_numbers[i])
        if not is_nan(json_to_double(invalid_numbers[i])):
            puts(invalid_numbers[i])
        assert is_nan(json_to_double(invalid_numbers[i]))

    # Sometimes json_to_double() may parse a part of an otherwise invalid number.
    assert not json_is_valid("00")
    assert json_to_double("00") == 0
    assert not json_is_valid("01")
    assert json_to_double("01") == 1
    assert not json_is_valid("09")
    assert json_to_double("09") == 9
    assert not json_is_valid("1.23J4")
    assert json_to_double("1.23J4") == 1.23
    assert not json_is_valid("1e2.3")
    assert json_to_double("1e2.3") == 1e2
    assert not json_is_valid("1.2.3")
    assert json_to_double("1.2.3") == 1.2
    assert not json_is_valid("5k")
    assert json_to_double("5k") == 5
    assert not json_is_valid("Infinityyyy")
    assert json_to_double("Infinityyyy") == 1.0 / 0.0
    assert not json_is_valid("-Infinityyyy")
    assert json_to_double("-Infinityyyy") == -1.0 / 0.0


def test_json_from_github_api() -> None:
    file_content: byte[10000]

    f = fopen("tests/data/jou_github_release.json", "rb")
    if f == NULL:
        # Running test file from its directory, not project root
        f = fopen("../data/jou_github_release.json", "rb")
    assert f != NULL
    n = fread(file_content, 1, sizeof(file_content), f)
    fclose(f)

    assert n < sizeof(file_content)
    file_content[n] = '\0'

    assert json_is_valid(file_content)
    assert not json_is_valid(&file_content[1])

    for asset = json_array_first(json_get(file_content, "assets")); asset != NULL; asset = json_array_next(asset):
        uploader_name = json_to_string(json_get(json_get(asset, "uploader"), "login"))
        asset_name = json_to_string(json_get(asset, "name"))

        # Output: github-actions[bot] uploaded jou_windows_64bit_2026-02-09-0500.zip
        printf("%s uploaded %s\n", uploader_name, asset_name)

        free(uploader_name)
        free(asset_name)


def main() -> int:
    test_array_validate()
    test_object_validate()
    test_array_iter()
    test_object_iter()
    test_get()
    test_bools_and_null()
    test_strings()
    test_numbers()
    test_json_from_github_api()

    puts("ok")  # Output: ok
    return 0
