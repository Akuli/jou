# A list of keywords is specified in many places. This test ensures that they
# stay in sync with each other.

import "stdlib/assert.jou"
import "stdlib/sort.jou"
import "stdlib/list.jou"
import "stdlib/process.jou"
import "stdlib/mem.jou"
import "stdlib/str.jou"
import "stdlib/io.jou"
import "stdlib/ascii.jou"


# TODO: add some kind of chdir to standard library
if WINDOWS:
    declare _chdir(dirname: byte*) -> int
    def chdir(dir: byte*) -> int:
        return _chdir(dir)
else:
    declare chdir(path: byte*) -> int


def go_to_project_root() -> None:
    for i = 0; i < 3; i++:
        f = fopen("compiler/main.jou", "r")
        if f != NULL:
            fclose(f)
            return
        chdir("..")
    printf("can't go to project root :(\n")
    exit(1)


def case_insensitive_comparator(p1: byte**, p2: byte**) -> int:
    copy1 = strdup(*p1)
    copy2 = strdup(*p2)

    for i = 0; i < 2; i++:
        s = copy1 if i == 0 else copy2

        # By default, int8 doesn't sort before int16 because '8' > '1'
        if strcmp(s, "int8") == 0 or strcmp(s, "uint8") == 0:
            s[strlen(s)-1] = '1'  # int8 becomes int1

        # Make everything lowercase
        for p = s; *p != '\0'; p++:
            if 'A' <= *p and *p <= 'Z':
                *p ^= ('A' ^ 'a')  # toggle case

    r = strcmp(copy1, copy2)
    free(copy1)
    free(copy2)
    return r


def get_keywords_from_compiler_source() -> List[byte*]:
    f = fopen("compiler/tokenizer.jou", "rb")
    assert f != NULL
    line: byte[1024] = ""

    # Find the place in compiler source code where the keywords are defined
    while not starts_with(line, "def is_keyword"):
        assert fgets(line, sizeof(line) as int, f) != NULL

    # Extract the list of keywords in a dumb way
    result = List[byte*]{}
    while True:
        assert fgets(line, sizeof(line) as int, f) != NULL

        comment = strstr(line, "#")
        if comment != NULL:
            *comment = '\0'

        len = strlen(line)
        while len > 0 and is_ascii_whitespace(line[len]):
            line[--len] = '\0'
        if len == 0:
            # Skip blank lines and comment-only lines
            continue

        if line[0] != ' ':
            # End of function
            break

        # Find all strings
        start = NULL
        for p = &line[0]; *p != '\0'; p++:
            if *p == '"':
                if start == NULL:
                    # String starts here
                    start = &p[1]
                else:
                    # String ends here
                    *p = '\0'
                    result.append(strdup(start))
                    *p = '"'
                    start = NULL

    fclose(f)
    Sorter[byte*]{}.sort(result.ptr, result.len, case_insensitive_comparator)
    return result


def get_keywords_from_documentation() -> List[byte*]:
    f = fopen("doc/keywords.md", "rb")
    assert f != NULL
    line: byte[1024] = ""

    result = List[byte*]{}
    while fgets(line, sizeof(line) as int, f) != NULL:
        if not starts_with(line, "## `"):
            continue

        # Find all things between backticks
        start = NULL
        for p = &line[0]; *p != '\0'; p++:
            if *p == '`':
                if start == NULL:
                    # `foo` starts here
                    start = &p[1]
                else:
                    # `foo` ends here
                    *p = '\0'
                    result.append(strdup(start))
                    *p = '`'
                    start = NULL

    fclose(f)
    return result


# Frees all memory used by the list. Assumes each string is allocated separately.
def list_to_string(list: List[byte*]) -> byte*:
    result = List[byte]{}
    for i = 0; i < list.len; i++:
        if i > 0:
            result.append(' ')
        result.extend_from_ptr(list.ptr[i], strlen(list.ptr[i]))
        free(list.ptr[i])
    free(list.ptr)
    result.append('\0')
    return result.ptr


def main() -> int:
    go_to_project_root()

    keywords_compiler = list_to_string(get_keywords_from_compiler_source())
    keywords_doc = list_to_string(get_keywords_from_documentation())

    if strcmp(keywords_compiler, keywords_doc) != 0:
        printf("Keywords are defined differently in different places!\n")
        printf("  Compiler:      %s\n", keywords_compiler)
        printf("  Documentation: %s\n", keywords_doc)
        return 1

    printf("ok\n")  # Output: ok
    free(keywords_compiler)
    free(keywords_doc)
    return 0
