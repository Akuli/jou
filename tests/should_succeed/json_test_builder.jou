import "stdlib/io.jou"
import "stdlib/json.jou"
import "stdlib/math.jou"
import "stdlib/mem.jou"
import "stdlib/str.jou"


def test_objects() -> None:
    # Output: {"one":1,"two":2,"empty":{},"singleton":{"three":3},"nested":{"nested":{"nested":{"four":4}},"five":5}}
    # Output: {
    # Output:   "one": 1,
    # Output:   "two": 2,
    # Output:   "empty": {},
    # Output:   "singleton": {
    # Output:     "three": 3
    # Output:   },
    # Output:   "nested": {
    # Output:     "nested": {
    # Output:       "nested": {
    # Output:         "four": 4
    # Output:       }
    # Output:     },
    # Output:     "five": 5
    # Output:   }
    # Output: }
    for pp = 0; pp <= 2; pp += 2:
        jb = JSONBuilder{pretty_print = pp}
        jb.begin_object()
        jb.key("one")
        jb.number(1)
        jb.key("two")
        jb.number(2)
        jb.key("empty")
        jb.begin_object()
        jb.end_object()
        jb.key("singleton")
        jb.begin_object()
        jb.key("three")
        jb.number(3)
        jb.end_object()
        jb.key("nested")
        jb.begin_object()
        jb.key("nested")
        jb.begin_object()
        jb.key("nested")
        jb.begin_object()
        jb.key("four")
        jb.number(4)
        jb.end_object()
        jb.end_object()
        jb.key("five")
        jb.number(5)
        jb.end_object()
        jb.end_object()

        json = jb.finish()
        puts(json)
        free(json)


def test_arrays() -> None:
    # Output: [1,2,[],[3],[[[4]],5]]
    # Output: [
    # Output:   1,
    # Output:   2,
    # Output:   [],
    # Output:   [
    # Output:     3
    # Output:   ],
    # Output:   [
    # Output:     [
    # Output:       [
    # Output:         4
    # Output:       ]
    # Output:     ],
    # Output:     5
    # Output:   ]
    # Output: ]
    for pp = 0; pp <= 2; pp += 2:
        jb = JSONBuilder{pretty_print = pp}
        jb.begin_array()
        jb.number(1)
        jb.number(2)
        jb.begin_array()
        jb.end_array()
        jb.begin_array()
        jb.number(3)
        jb.end_array()
        jb.begin_array()
        jb.begin_array()
        jb.begin_array()
        jb.number(4)
        jb.end_array()
        jb.end_array()
        jb.number(5)
        jb.end_array()
        jb.end_array()
        json = jb.finish()
        puts(json)
        free(json)


def test_bools_and_null() -> None:
    jb = JSONBuilder{}
    jb.begin_object()
    jb.key("yes")
    jb.boolean(True)
    jb.key("no")
    jb.boolean(False)
    jb.key("idk")
    jb.null()
    jb.end_object()

    json = jb.finish()
    puts(json)  # Output: {"yes":true,"no":false,"idk":null}
    free(json)


def test_strings() -> None:
    # Escaping rules in Jou and JSON are similar, but not exactly the same.
    # For example, JSON uses \uHHHH (H denotes a hex digit) while Jou uses \xHH.
    strings = [
        "jou",          # Output: "jou"
        NULL,           # Output: null
        "'hello'",      # Output: "'hello'"
        "\"hello\"",    # Output: "\"hello\""
        "hello\tworld\ntest\rthingy\x0cthing",          # Output: "hello\tworld\ntest\rthingy\u000cthing"
        "C:\\Users\\myname\\whatever",                  # Output: "C:\\Users\\myname\\whatever"
        "\x1b[31mred ANSI color\x1b[0m",                # Output: "\u001b[31mred ANSI color\u001b[0m"
        "these\xe2\x80\xa8cause\xe2\x80\xa9problems",   # Output: "these\u2028cause\u2029problems"
    ]

    for i = 0; i < array_count(strings); i++:
        jb = JSONBuilder{}
        jb.string(strings[i])
        json = jb.finish()
        puts(json)
        free(json)

    # This is tested separately, because printing this could cause unicode
    # problems on windows.
    #
    # TODO: does this need to be separated?
    jb = JSONBuilder{}
    jb.string("non-ASCII like â‚¬Â£ðŸ’¸ is valid as is")
    json = jb.finish()
    printf("%d\n", strcmp(json, "\"non-ASCII like â‚¬Â£ðŸ’¸ is valid as is\""))  # Output: 0
    free(json)

    # String that contains zero bytes
    hello0world = ['h', 'e', 'l', 'l', 'o', '\0', 'w', 'o', 'r', 'l', 'd']
    corner_case: byte[7] = ['w', 'a', 't', '\0', '\xe2', '\x80', '\xa9']
    jb = JSONBuilder{}
    jb.begin_array()
    jb.string_with_len(hello0world, 11)
    jb.string_with_len("test", 5)
    jb.string_with_len(corner_case, 7)
    jb.end_array()
    json = jb.finish()
    puts(json)  # Output: ["hello\u0000world","test\u0000","wat\u0000\u2029"]
    free(json)

    # Invalid UTF-8 is passed through as is. The check for U+2028/U+2029
    # shouldn't read beyond the end of the string even in this case.
    #
    # Using malloc() so any problems can hopefully be found with valgrind.
    s: byte* = malloc(2)
    s[0] = '\xe2'
    s[1] = '\x80'
    jb = JSONBuilder{}
    jb.string_with_len(s, 2)
    free(s)
    json = jb.finish()
    printf("%d\n", strcmp(json, "\"\xe2\x80\""))  # Output: 0
    free(json)


def test_numbers() -> None:
    jb = JSONBuilder{pretty_print = 2}
    jb.begin_array()
    jb.number(0)
    jb.number(1)
    jb.number(-2)
    # 3.14 requires 16 digits of precision to be printed.
    # With 17 digits it produces 3.1400000000000001
    jb.number(3.14)
    jb.number(-3.14)
    # These values require 17 digits of precision to be printed.
    # With 16 digits this gives just 1.
    jb.number(1.0000000000000002)
    jb.number(1.0000000000000004)
    jb.number(-1.0000000000000002)
    jb.number(-1.0000000000000004)
    # Test the e notation. This should be exact because this is a power of 2.
    jb.number(pow(2, -20))
    # Technically Infinity and NaN are not valid JSON, but many libraries
    # support them to some extent so we support them too.
    jb.number(1.0 / 0.0)    # Infinity
    jb.number(-1.0 / 0.0)   # -Infinity
    jb.number(0.0 / 0.0)    # NaN
    jb.end_array()

    json = jb.finish()

    # Windows likes to say e-007 instead of e-07 at the end of float
    if WINDOWS and strstr(json, "e-007") != NULL:
        p = strstr(json, "e-007")
        memmove(&p[2], &p[3], strlen(&p[3]) + 1)

    # Output: [
    # Output:   0,
    # Output:   1,
    # Output:   -2,
    # Output:   3.14,
    # Output:   -3.14,
    # Output:   1.0000000000000002,
    # Output:   1.0000000000000004,
    # Output:   -1.0000000000000002,
    # Output:   -1.0000000000000004,
    # Output:   9.5367431640625e-07,
    # Output:   Infinity,
    # Output:   -Infinity,
    # Output:   NaN
    # Output: ]
    puts(json)
    free(json)

    # Test that any int can be converted to JSON and back. This is not obvious,
    # because the .number() method takes a double, not int.
    #
    # Commented out because this is VERY slow!
    #jb = JSONBuilder{}
    #for i = INT32_MIN; ; i++:
    #    if i % 1000000 == 0:
    #        printf("%d\n", i)
    #        fflush(get_stdout())
    #    jb.output.len = 0
    #    jb.number(i)
    #    s = jb.finish()
    #    if atoi(s) != i:
    #        printf("PROBLEM!!! %d --> %s\n", i, s)  # shouldn't get printed at all
    #        fflush(get_stdout())
    #
    #    if i == INT32_MAX:
    #        break


def test_complex_example() -> None:
    # Output: [
    # Output:   1,
    # Output:   2,
    # Output:   [
    # Output:     3
    # Output:   ],
    # Output:   [
    # Output:     4,
    # Output:     5
    # Output:   ],
    # Output:   {
    # Output:     "foo": 123,
    # Output:     "empty": {},
    # Output:     "just_one": {
    # Output:       "lol": 123
    # Output:     },
    # Output:     "funny \"key\" string": 123,
    # Output:     "yes": true,
    # Output:     "no": false,
    # Output:     "first null": null,
    # Output:     "alternative null": null,
    # Output:     "big numba": Infinity
    # Output:   }
    # Output: ]

    jb = JSONBuilder{pretty_print = 2}

    jb.begin_array()
    jb.number(1)
    jb.number(2)
    jb.begin_array()
    jb.number(3)
    jb.end_array()
    jb.begin_array()
    jb.number(4)
    jb.number(5)
    jb.end_array()
    jb.begin_object()
    jb.key("foo")
    jb.number(123)
    jb.key("empty")
    jb.begin_object()
    jb.end_object()
    jb.key("just_one")
    jb.begin_object()
    jb.key("lol")
    jb.number(123)
    jb.end_object()
    jb.key("funny \"key\" string")
    jb.number(123)
    jb.key("yes")
    jb.boolean(True)
    jb.key("no")
    jb.boolean(False)
    jb.key("first null")
    jb.null()
    jb.key("alternative null")
    jb.string(NULL)
    jb.key("big numba")
    jb.number(1.0 / 0.0)
    jb.end_object()
    jb.end_array()

    json = jb.finish()
    puts(json)
    free(json)


def main() -> int:
    test_objects()
    test_arrays()
    test_bools_and_null()
    test_strings()
    test_numbers()
    test_complex_example()
    return 0
