import "stdlib/assert.jou"
import "stdlib/ascii.jou"
import "stdlib/list.jou"
import "stdlib/str.jou"
import "stdlib/io.jou"


const FLAG_COMMA: uint8 = 0b01
const FLAG_OBJECT: uint8 = 0b10


class JSONBuilder:
    output: List[byte]
    stack: uint8[32]  # contains bitwise ORs of stack flags
    depth: int
    waiting_for_value_after_a_key: bool

    def add_comma_if_needed(self) -> None:
        if self.depth == 0:
            return

        if self.waiting_for_value_after_a_key:
            self.waiting_for_value_after_a_key = False
            return

        assert 0 < self.depth and self.depth <= array_count(self.stack)

        flags = &self.stack[self.depth - 1]
        if *flags & FLAG_COMMA != 0:
            self.output.append(',')
        *flags |= FLAG_COMMA

    def array(self) -> None:
        self.add_comma_if_needed()
        assert self.depth < array_count(self.stack)
        self.stack[self.depth++] = 0
        self.output.append('[')

    def object(self) -> None:
        self.add_comma_if_needed()
        assert self.depth < array_count(self.stack)
        self.stack[self.depth++] = FLAG_OBJECT
        self.output.append('{')

    def key(self, key: byte*) -> None:
        # This can only be used inside an object
        assert self.depth > 0
        assert self.stack[self.depth - 1] & FLAG_OBJECT != 0

        # You cannot add multiple keys without putting values in between
        assert not self.waiting_for_value_after_a_key

        self.string(key)
        self.output.append(':')
        self.waiting_for_value_after_a_key = True

    def end(self) -> None:
        assert not self.waiting_for_value_after_a_key
        assert self.depth > 0
        flags = self.stack[--self.depth]
        if flags & FLAG_OBJECT != 0:
            self.output.append('}')
        else:
            self.output.append(']')

    def integer(self, n: int) -> None:
        self.add_comma_if_needed()
        buf: byte[16]
        sprintf(buf, "%d", n)
        self.output.extend_from_ptr(buf, strlen(buf))

    def string(self, s: byte*) -> None:
        self.add_comma_if_needed()
        self.output.append('"')
        for ; *s != '\0'; s++:
            match *s:
                case '\n':
                    self.output.append('\\')
                    self.output.append('n')
                case '\t':
                    self.output.append('\\')
                    self.output.append('t')
                case '"' | '\\':
                    self.output.append('\\')
                    self.output.append(*s)
                case _:
                    if is_ascii_printable(*s):
                        self.output.append(*s)
                    elif *s < 128:
                        # unprintable ASCII character, do these carefully
                        buf: byte[16]
                        sprintf(buf, "\\u00%02x", *s)
                        self.output.extend_from_ptr(buf, strlen(buf))
                    else:
                        # part of a non-ASCII character in UTF-8, output it as is
                        self.output.append(*s)
        self.output.append('"')

    def finish(self) -> byte*:
        assert self.depth == 0
        self.output.append('\0')
        result = self.output.ptr
        self.output = List[byte]{}
        return result


def main() -> int:
    jb = JSONBuilder{}

    jb.array()
    jb.integer(1)
    jb.integer(2)
    jb.array()
    jb.integer(3)
    jb.end()
    jb.array()
    jb.integer(4)
    jb.integer(5)
    jb.end()
    jb.array()
    jb.end()
    jb.array()
    jb.array()
    jb.integer(6)
    jb.end()
    jb.integer(7)
    jb.array()
    jb.string("'h€llö\tworld'\n\"test\"\nC:\\Users\\myname\\whatever\n\x1b[31mred\x1b[0m")
    jb.end()
    jb.end()
    jb.object()
    jb.key("foo")
    jb.integer(123)
    jb.key("empty")
    jb.object()
    jb.end()
    jb.key("just_one")
    jb.object()
    jb.key("lol")
    jb.integer(123)
    jb.end()
    jb.end()
    jb.end()

    result = jb.finish()
    puts(result)  # Output: [1,2,[3],[4,5],[],[[6],7,[8]]]

    return 0
