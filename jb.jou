import "stdlib/assert.jou"
import "stdlib/ascii.jou"
import "stdlib/list.jou"
import "stdlib/str.jou"
import "stdlib/io.jou"


const FLAG_EMPTY: uint8 = 0b01
const FLAG_OBJECT: uint8 = 0b10


class JSONBuilder:
    pretty_print_indent: int  # 0 means as concise as possible (not pretty-print)
    output: List[byte]  # You must free(json_builder.output.ptr) or call finish()

    # Internals that you don't need to care about as a user
    stack: uint8[32]  # contains bitwise ORs of the flags
    depth: int        # number of items on stack
    waiting_for_value_after_a_key: bool

    def before_a_value(self) -> None:
        if self.depth == 0:
            # This assert fails if you try to create multiple top-level values.
            # If you want to create multiple values, you must use array or object.
            assert self.output.len == 0
            return

        if self.waiting_for_value_after_a_key:
            self.waiting_for_value_after_a_key = False
            return

        assert 0 < self.depth and self.depth <= array_count(self.stack)
        flags = &self.stack[self.depth - 1]

        if *flags & FLAG_EMPTY == 0:
            self.output.append(',')
        *flags &= ~FLAG_EMPTY

        if self.pretty_print_indent != 0:
            self.output.append('\n')
            n = self.pretty_print_indent * self.depth
            while n --> 0:
                self.output.append(' ')

    def array(self) -> None:
        self.before_a_value()
        assert self.depth < array_count(self.stack)
        self.stack[self.depth++] = FLAG_EMPTY
        self.output.append('[')

    def object(self) -> None:
        self.before_a_value()
        assert self.depth < array_count(self.stack)
        self.stack[self.depth++] = FLAG_EMPTY | FLAG_OBJECT
        self.output.append('{')

    def key(self, key: byte*) -> None:
        assert key != NULL

        # This can only be used inside an object
        assert self.depth > 0
        assert self.stack[self.depth - 1] & FLAG_OBJECT != 0

        # You cannot add multiple keys without putting values in between
        assert not self.waiting_for_value_after_a_key

        self.string(key)
        self.output.append(':')
        if self.pretty_print_indent != 0:
            self.output.append(' ')
        self.waiting_for_value_after_a_key = True

    def end(self) -> None:
        assert not self.waiting_for_value_after_a_key
        assert self.depth > 0
        flags = self.stack[--self.depth]

        if self.pretty_print_indent != 0 and flags & FLAG_EMPTY == 0:
            self.output.append('\n')
            n = self.pretty_print_indent * self.depth
            while n --> 0:
                self.output.append(' ')

        if flags & FLAG_OBJECT != 0:
            self.output.append('}')
        else:
            self.output.append(']')

    def boolean(self, b: bool) -> None:
        self.before_a_value()
        if b:
            self.output.extend_from_ptr("true", 4)
        else:
            self.output.extend_from_ptr("false", 5)

    def string(self, s: byte*) -> None:
        if s == NULL:
            self.null()
            return

        self.before_a_value()
        self.output.append('"')

        while *s != '\0':
            match *s:
                case '\n':
                    self.output.append('\\')
                    self.output.append('n')
                    s++
                case '\t':
                    self.output.append('\\')
                    self.output.append('t')
                    s++
                case '"' | '\\':
                    self.output.append('\\')
                    self.output.append(*s++)
                case _:
                    if is_ascii_printable(*s):
                        self.output.append(*s++)
                    elif *s < 128:
                        # unprintable ASCII character, do these carefully
                        buf: byte[16]
                        sprintf(buf, "\\u00%02x", *s++)
                        self.output.extend_from_ptr(buf, strlen(buf))
                    elif starts_with(s, "\xe2\x80\xa8"):
                        # Unicode character U+2028, putting this to JSON as is may cause problems
                        self.output.append('\\')
                        self.output.append('u')
                        self.output.append('2')
                        self.output.append('0')
                        self.output.append('2')
                        self.output.append('8')
                        s = &s[3]
                    elif starts_with(s, "\xe2\x80\xa9"):
                        # Unicode character U+2029, putting this to JSON as is may cause problems
                        self.output.append('\\')
                        self.output.append('u')
                        self.output.append('2')
                        self.output.append('0')
                        self.output.append('2')
                        self.output.append('9')
                        s = &s[3]
                    else:
                        # part of a non-ASCII character in UTF-8, output it as is
                        self.output.append(*s++)
        self.output.append('"')

    def null(self) -> None:
        self.before_a_value()
        self.output.extend_from_ptr("null", 4)

    def number(self, n: double) -> None:
        self.before_a_value()

        # TODO: Jou doesn't have isnan/isinf yet
        #if isnan(x): --> emit "NaN"
        #if isinf(x): --> emit "Infinity" or "-Infinity"

        # AI says that 17 significant digits is always enough.
        buf: byte[64]
        snprintf(buf, sizeof(buf), "%.17g", n)

        # Handle NaN and infinities. They are technically not valid JSON, but
        # they are often used. For example, Python's JSON module produces them
        # by default.
        #
        # TODO: This is a bit hacky because Jou doesn't have isnan/isinf functions yet.
        match buf with strcmp:
            case "nan" | "Nan" | "NaN" | "NAN":
                buf = "NaN"
            case "inf" | "Inf" | "INF" | "infinity" | "Infinity" | "INFINITY":
                buf = "Infinity"
            case "-inf" | "-Inf" | "-INF" | "-infinity" | "-Infinity" | "-INFINITY":
                buf = "-Infinity"

        self.output.extend_from_ptr(buf, strlen(buf))

    # Return value must be free()'d
    def finish(self) -> byte*:
        assert self.depth == 0  # If this fails, you forgot to call end()
        self.output.append('\0')
        return self.output.ptr


def main() -> int:
    jb = JSONBuilder{pretty_print_indent = 4}

    jb.array()
    jb.number(1)
    jb.number(2)
    jb.array()
    jb.number(3)
    jb.number(3.14159265358979)
    jb.end()
    jb.array()
    jb.number(4)
    jb.number(5)
    jb.end()
    jb.array()
    jb.end()
    jb.array()
    jb.array()
    jb.number(6)
    jb.end()
    jb.number(7)
    jb.array()
    jb.string("'h€llö\tworld'\n\"test\"\nC:\\Users\\myname\\whatever\n\x1b[31mred\x1b[0m\nthese\xe2\x80\xa8cause\xe2\x80\xa9problems")
    jb.end()
    jb.end()
    jb.object()
    jb.key("foo")
    jb.number(123)
    jb.key("empty")
    jb.object()
    jb.end()
    jb.key("just_one")
    jb.object()
    jb.key("lol")
    jb.number(123)
    jb.end()
    jb.key("funny \"key\" string")
    jb.number(123)
    jb.key("yes")
    jb.boolean(True)
    jb.key("no")
    jb.boolean(False)
    jb.key("first null")
    jb.null()
    jb.key("alternative null")
    jb.string(NULL)
    jb.key("invalid numba")
    jb.number(0.0 / 0.0)
    jb.key("very big numba")
    jb.number(1.0 / 0.0)
    jb.end()
    jb.end()

    result = jb.finish()
    puts(result)

    return 0
