# TOML spec: https://toml.io/en/v1.1.0

import "stdlib/ascii.jou"
import "stdlib/assert.jou"
import "stdlib/io.jou"
import "stdlib/json.jou"
import "stdlib/limits.jou"
import "stdlib/list.jou"
import "stdlib/mem.jou"
import "stdlib/process.jou"
import "stdlib/str.jou"


def joutest_error(msg: byte*) -> noreturn:
    fprintf(get_stderr(), "joutest error: %s\n", msg)
    exit(1)


class TOMLKeyVal:
    key: byte*
    value: TOMLValue

class TOMLTable:
    # TODO: hash table? or is that not needed?
    items: List[TOMLKeyVal]

    def find(self, key: byte*) -> TOMLValue*:
        for p = self.items.ptr; p < self.items.end(); p++:
            if strcmp(key, p.key) == 0:
                return &p.value
        return NULL

    def free(self) -> None:
        for i = 0; i < self.items.len; i++:
            kv = self.items.ptr[i]
            free(kv.key)
            kv.value.free()  # recursive call
        free(self.items.ptr)


enum TOMLValueKind:
    Unset  # must be first, so initializes to this
    Table
    String
    Boolean
    Integer

class TOMLValue:
    kind: TOMLValueKind
    union:
        table: TOMLTable
        string: byte*
        boolean: bool
        integer: int64

    def free(self) -> None:
        match self.kind:
            case TOMLValueKind.String:
                free(self.string)
            case TOMLValueKind.Table:
                self.table.free()
            case TOMLValueKind.Boolean | TOMLValueKind.Integer | TOMLValueKind.Unset:
                pass

def digit_value(b: byte) -> int:
    if '0' <= b and b <= '9':
        return b - '0'
    if 'A' <= b and b <= 'F':
        return b - 'A'
    if 'a' <= b and b <= 'f':
        return b - 'a'
    return -1


class TOMLParser:
    path: byte*
    file_content_start: byte*
    ptr: byte*
    target: TOMLValue*

    def fail(self, message: byte*) -> noreturn:
        # Work out line number
        assert self.ptr >= self.file_content_start
        lineno = 1
        for p = self.ptr; p < self.file_content_start; p++:
            if *p == '\n':
                lineno++

        message_with_location: byte[500]
        snprintf(
            message_with_location,
            sizeof(message_with_location),
            "invalid TOML syntax in file \"%s\", line %d: %s\n",
            self.path,
            lineno,
            message,
        )
        joutest_error(message_with_location)

    # Names of many methods are according to this:
    # https://github.com/toml-lang/toml/blob/bcbbd1c1f03473ffe97b8bf26a0fc945efe2b4a1/toml.abnf

    def toml(self) -> None:
        self.expression()
        while *self.ptr == '\n':
            self.ptr++
            self.expression()
        if *self.ptr != '\0':
            self.fail("junk at end of line")

    def expression(self) -> None:
        self.ws()
        match *self.ptr:
            case '[':
                self.table()
                self.ws()
                if *self.ptr == '#':
                    self.comment()
            case '\n' | '\0':
                pass
            case '#':
                self.comment()
            case _:
                self.keyval()
                self.ws()
                if *self.ptr == '#':
                    self.comment()

    def ws(self) -> None:
        while *self.ptr == ' ' or *self.ptr == '\t':
            self.ptr++

#    def newline(self) -> None:
#        if *self.ptr == '\r':
#            self.ptr++
#        if *self.ptr != '\n':
#            self.fail()
#        self.ptr++

    def comment(self) -> None:
        assert *self.ptr == '#'
        while *self.ptr != '\0' and *self.ptr != '\n':
            b = *self.ptr
            if not (b >= 128 or b == '\t' or (32 <= b and b <= 126)):
                self.fail("invalid character in comment")
            self.ptr++

    def keyval(self) -> None:
        old_target = self.target
        self.key()
        self.ws()
        if *self.ptr != '=':
            self.fail("there should be '=' after a key")
        self.ptr++
        self.ws()
        self.val()
        self.target = old_target

    # Not exactly right according to the spec, because this ends with a call to
    # .ws() but a key shouldn't include trailing whitespace. We'll see if that
    # matters, maybe not...
    def key(self) -> None:
        self.simple_key()
        self.ws()
        while *self.ptr == '.':
            self.ptr++
            self.ws()
            self.simple_key()
            self.ws()

    def simple_key(self) -> None:
        key: byte*
        match *self.ptr:
            case '"':
                key = self.basic_string()
            case '\'':
                key = self.literal_string()
            case _:
                n = 0
                while (
                    is_ascii_letter(self.ptr[n])
                    or is_ascii_digit(self.ptr[n])
                    or self.ptr[n] == '-'
                    or self.ptr[n] == '_'
                ):
                    n++
                if n == 0:
                    self.fail("failed to parse the key in 'key = value' syntax")
                key = NULL
                asprintf(&key, "%.*s", n, self.ptr)
                assert key != NULL
                self.ptr = &self.ptr[n]

        assert self.target.kind == TOMLValueKind.Table

        # Does this key already exists? If it exists, let's go there
        found = self.target.table.find(key)
        if found != NULL:
            free(key)
            self.target = found
            return

        # Key not found --> create new table
        self.target.table.items.append(TOMLKeyVal{
            key = key,
            value = TOMLValue{kind = TOMLValueKind.Table},
        })
        self.target = &self.target.table.items.end()[-1].value

    def val(self) -> None:
        # TODO: why is this needed?
        self.target.free()
        *self.target = TOMLValue{}

        match *self.ptr:
            case '"':
                if starts_with(self.ptr, "\"\"\""):
                    s = self.ml_basic_string()
                else:
                    s = self.basic_string()
                assert s != NULL
                *self.target = TOMLValue{kind = TOMLValueKind.String, string = s}
            case '\'':
                if starts_with(self.ptr, "'''"):
                    s = self.ml_literal_string()
                else:
                    s = self.literal_string()
                assert s != NULL
                *self.target = TOMLValue{kind = TOMLValueKind.String, string = s}
            case 't':
                if not starts_with(self.ptr, "true"):
                    self.fail("failed to parse value")
                *self.target = TOMLValue{kind = TOMLValueKind.Boolean, boolean = True}
                self.ptr = &self.ptr[4]
            case '+' | '-' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9':
                n = self.integer()
                *self.target = TOMLValue{kind = TOMLValueKind.Integer, integer = n}
            case _:
                puts(self.ptr)
                # TODO: support other types of values
                assert False

    def unsigned_integer_in_base(self, base: int) -> uint64:
        first_digit_value = digit_value(*self.ptr)
        if first_digit_value != -1 and first_digit_value < base:
            result: uint64 = first_digit_value as uint64
            self.ptr++
            while True:
                if *self.ptr == '_':
                    self.ptr++
                    continue
                v = digit_value(*self.ptr)
                if v == -1:
                    return result
                if v >= base:
                    break  # show error message
                # Don't allow 01, 001 etc
                if base == 10 and first_digit_value == 0:
                    self.fail("integer starts with an unnecessary zero")
                new_result = result*(base as uint64) + (v as uint64)
                if new_result/base != result:
                    # it overflowed
                    return UINT64_MAX
                result = new_result
                self.ptr++

        match base:
            case 2:
                self.fail("invalid binary number")
            case 8:
                self.fail("invalid octal number")
            case 10:
                self.fail("invalid number")
            case 16:
                self.fail("invalid hexadecimal number")
            case _:
                assert False

    def integer(self) -> int64:
        sign = 1
        if starts_with(self.ptr, "0b"):
            base = 2
        elif starts_with(self.ptr, "0o"):
            base = 8
        elif starts_with(self.ptr, "0x"):
            base = 16
        else:
            base = 10
            # Only base 10 numbers can be negative in TOML!
            if *self.ptr == '-':
                sign = -1
            if *self.ptr == '+' or *self.ptr == '-':
                self.ptr++

        if base != 10:
            self.ptr = &self.ptr[2]

        u = self.unsigned_integer_in_base(base)

        # Special casing to make sure the most negative int64 value works.
        # Its absolute value doesn't fit in int64.
        # TODO: this needed?
        if sign == -1 and u == (INT64_MAX as uint64) + 1:
            return INT64_MIN

        if u > INT64_MAX:
            self.fail("integer doesn't fit in a Jou int64")
        return sign*(u as int64)

    def basic_string(self) -> byte*:
        assert *self.ptr == '"'
        self.ptr++

        result = List[byte]{}
        while *self.ptr != '"' and *self.ptr != '\0':
            result.append(self.basic_char())
        self.ptr++

        result.append('\0')
        return result.ptr

    def basic_char(self) -> byte:
        if *self.ptr == '\\':
            return self.escaped()
        else:
            return self.basic_unescaped()

    def basic_unescaped(self) -> byte:
        if (
            *self.ptr == '\t'
            or *self.ptr == ' '
            or *self.ptr == '!'
            or (*self.ptr >= 0x23 and *self.ptr <= 0x5b)
            or (*self.ptr >= 0x5d and *self.ptr <= 0x7e)
            or *self.ptr >= 128  # TODO: reject invalid UTF-8
        ):
            return *self.ptr++
        self.fail("bad character inside string")

    def escaped(self) -> byte:
        assert *self.ptr == '\\'
        self.ptr++
        c = *self.ptr++
        match c:
            case '"':
                return '"'
            case '\\':
                return '\\'
            case 'b':
                return 0x08  # Jou doesn't have \b
            case 'e':
                return 0x1b  # Jou doesn't have \e
            case 'f':
                return 0x0c  # Jou doesn't have \f
            case 'n':
                return '\n'
            case 'r':
                return '\r'
            case 't':
                return '\t'
            case 'x':
                assert False  # TODO: \xHH hex escape
            case 'u':
                assert False  # TODO: \uHHHH hex escape
            case 'U':
                assert False  # TODO: \UHHHHHHHH hex escape
            case _:
                self.fail("bad backslash escape in string")

    def ml_basic_string(self) -> byte*:
        assert False  # TODO

    def literal_string(self) -> byte*:
        assert *self.ptr == '\''
        self.ptr++
        result = List[byte]{}
        while *self.ptr != '\'':
            result.append(self.literal_char())
        self.ptr++
        result.append('\0')
        return result.ptr

    def literal_char(self) -> byte:
        if (
            *self.ptr == '\t'
            or (0x20 <= *self.ptr and *self.ptr <= 0x26)
            or (0x28 <= *self.ptr and *self.ptr <= 0x7e)
            or *self.ptr >= 128  # TODO: reject invalid UTF-8
        ):
            return *self.ptr++
        self.fail("bad character inside string")

    def ml_literal_string(self) -> byte*:
        assert False  # TODO

    def table(self) -> None:
        assert False  # TODO


def print_toml_value(value: TOMLValue, depth: int) -> None:
    match value.kind:
        case TOMLValueKind.Unset:
            puts("UNSET")
        case TOMLValueKind.Table:
            printf("table:\n")
            for i = 0; i < value.table.items.len; i++:
                kv = value.table.items.ptr[i]
                printf("%*s", 2*(depth + 1), "")
                printf("%s = ", kv.key)
                print_toml_value(kv.value, depth + 1)
        case TOMLValueKind.String:
            printf("string: %s\n", value.string)
        case TOMLValueKind.Boolean:
            puts("boolean: true" if value.boolean else "boolean: false")
        case TOMLValueKind.Integer:
            printf("integer: %lld\n", value.integer)


def read_file_to_string(path: byte*) -> byte*:
    msg: byte[500]

    file = fopen(path, "rb")
    if file == NULL:
        snprintf(msg, sizeof(msg), "reading file \"%s\" failed", path)
        joutest_error(msg)

    bytes_list = List[byte]{}

    buf: byte[4096]
    while True:
        num_read = fread(buf, 1, sizeof buf, file)
        if num_read == 0:
            if ferror(file) != 0:
                snprintf(msg, sizeof(msg), "reading file \"%s\" failed", path)
                joutest_error(msg)
            break
        bytes_list.extend_from_ptr(buf, num_read)

    fclose(file)

    lineno = 1
    for p = bytes_list.ptr; p < bytes_list.end(); p++:
        match *p:
            case '\n':
                lineno++
            case '\0':
                snprintf(msg, sizeof(msg), "file \"%s\" contains a zero byte on line %d\n", path, lineno)
                joutest_error(msg)

    bytes_list.append('\0')
    return bytes_list.ptr


def parse_toml(path: byte*) -> TOMLTable:
    file_content = read_file_to_string(path)

    # TODO: ensure it's valid UTF-8

    result_value = TOMLValue{kind = TOMLValueKind.Table}
    parser = TOMLParser{ptr = file_content, target = &result_value}
    parser.toml()
    free(file_content)

    assert result_value.kind == TOMLValueKind.Table
    return result_value.table


def toml_to_json(value: TOMLValue, jb: JSONBuilder*) -> None:
    match value.kind:
        case TOMLValueKind.Unset:
            jb.string("THIS SHOULD NEVER HAPPEN!!!!")
        case TOMLValueKind.Table:
            jb.begin_object()
            for kv = value.table.items.ptr; kv < value.table.items.end(); kv++:
                jb.key(kv.key)
                toml_to_json(kv.value, jb)
            jb.end_object()
        case TOMLValueKind.String:
            jb.begin_object()
            jb.key("type").string("string")
            jb.key("value").string(value.string)
            jb.end_object()
        case TOMLValueKind.Boolean:
            jb.string("TODO boolean")
        case TOMLValueKind.Integer:
            jb.string("TODO integer")


# For testing with the official TOML test suite and experimenting.
# Reads TOML from stdin and prints JSON compatible with the TOML test suite.
def main() -> int:
    toml = parse_toml("/dev/stdin")

    jb = JSONBuilder{pretty_print = 4}
    toml_to_json(TOMLValue{kind = TOMLValueKind.Table, table = toml}, &jb)
    toml.free()

    json = jb.finish()
    puts(json)
    free(json)
    return 0
