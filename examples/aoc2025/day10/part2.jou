import "stdlib/ascii.jou"
import "stdlib/assert.jou"
import "stdlib/limits.jou"
import "stdlib/mem.jou"
import "stdlib/io.jou"
import "stdlib/str.jou"
import "stdlib/sort.jou"

const MAX_BITS: int = 16


def parse_vector(p: byte*) -> int[MAX_BITS]:
    assert *p == '('
    p++

    result: int[MAX_BITS]
    memset(result, 0, sizeof(result))
    while True:
        i = atoi(p)
        assert 0 <= i and i < array_count(result)
        result[i] = 1
        while is_ascii_digit(*p):
            p++
        if *p++ != ',':
            return result


def parse_goal(line: byte*) -> int[MAX_BITS]:
    p = strstr(line, "{")
    assert p != NULL
    p++

    result: int[MAX_BITS]
    memset(result, 0, sizeof(result))
    i = 0
    while True:
        assert i < MAX_BITS
        result[i++] = atoi(p)
        while is_ascii_digit(*p):
            p++
        if *p++ != ',':
            return result


def compare_vectors(v1: int[MAX_BITS]*, v2: int[MAX_BITS]*) -> int:
    sum1 = 0
    for i = 0; i < array_count(*v1); i++:
        sum1 += (*v1)[i]

    sum2 = 0
    for i = 0; i < array_count(*v2); i++:
        sum2 += (*v2)[i]

    return -(sum1 - sum2)  # backwards sort, biggest sum first


# Finds smallest n so that a sum of n vectors (with repetitions) is the goal.
# The same vector may be used multiple times in the sum.
# Return value -1 means that no such sum exists.
#
# Assumes that all vectors only contain 0 or 1, and there's at least one 1
# somewhere in every vector.
def find_smallest_count_to_get_sum(vectors: int[MAX_BITS]*, nvectors: int, each_vector_len: int, goal: int[MAX_BITS], depth: int, vectors_used: int, best_count: int*) -> None:
    if vectors_used >= *best_count:
        # Not worth exploring
        return

    if depth < 5:
        for i = 0; i < depth; i++:
            printf("  ")
        printf("used %d, %d vectors, best %d, goal:", vectors_used, nvectors, *best_count)
        for i = 0; i < array_count(goal); i++:
            printf(" %d", goal[i])
        printf("\n")
        fflush(get_stdout())

    assert nvectors >= 0
    if nvectors == 0:
        # Base case: Only all zeros is reachable
        if vectors_used < *best_count:
            for i = 0; i < array_count(goal); i++:
                if goal[i] != 0:
                    return
            *best_count = vectors_used
            printf(" === NEW BEST === %d\n", vectors_used)
            fflush(get_stdout())
    else:
        # Recursive case: Go through all possible coefficients for the first vector.
        for i = 0; i < array_count(goal); i++:
            if goal[i] < 0:
                # not gonna work, let's not even try
                return

        coeff_max = -1
        for i = 0; i < array_count(vectors[0]); i++:
            if vectors[0][i] != 0:
                assert vectors[0][i] == 1
                if coeff_max == -1 or goal[i] < coeff_max:
                    coeff_max = goal[i]
        assert coeff_max != -1

        for coeff = 0; coeff <= coeff_max; coeff++:
            new_goal: int[MAX_BITS] = goal
            for i = 0; i < array_count(new_goal); i++:
                new_goal[i] -= coeff*vectors[0][i]
            find_smallest_count_to_get_sum(&vectors[1], nvectors - 1, each_vector_len, new_goal, depth + 1, vectors_used + coeff, best_count)


def main() -> int:
    f = fopen("sampleinput.txt", "r")
    assert f != NULL

    line: byte[1024]
    result: int64 = 0

    while fgets(line, sizeof(line) as int, f) != NULL:
        puts(line)
        fflush(get_stdout())
        vectors: int[MAX_BITS][20]
        nvectors = 0
        for p = strstr(line, "("); p != NULL; p = strstr(&p[1], "("):
            assert nvectors < array_count(vectors)
            vectors[nvectors++] = parse_vector(p)

        # Optimization: first try big vectors (as in, containing much 1 and not much 0)
        Sorter[int[MAX_BITS]]{}.sort(vectors, nvectors, compare_vectors)
#        for i = 0; i < nvectors; i++:
#            for k = 0; k < MAX_BITS; k++:
#                printf("%d", vectors[i][k])
#            printf("\n")
#        return 6

        goal = parse_goal(line)

        each_vector_len = MAX_BITS
        while each_vector_len > 0:
            needs_to_be_that_long = False
            for i = 0; i < nvectors; i++:
                if vectors[i][each_vector_len - 1] != 0:
                    needs_to_be_that_long = True
            if needs_to_be_that_long:
                break
            each_vector_len--

        r = INT32_MAX
        find_smallest_count_to_get_sum(vectors, nvectors, each_vector_len, goal, 0, 0, &r)
        result += r

    printf("%lld\n", result)  # Output: 33

    fclose(f)
    return 0
