import "stdlib/io.jou"
import "stdlib/ascii.jou"
import "stdlib/math.jou"
import "stdlib/str.jou"
import "stdlib/mem.jou"


def dx_string(dx: int, dest: byte*) -> None:
    if dx >= 0:
        memset(dest, '>', dx)
    else:
        memset(dest, '<', abs(dx))
    dest[abs(dx)] = '\0'


def dy_string(dy: int, dest: byte*) -> None:
    if dy >= 0:
        memset(dest, 'v', dy)
    else:
        memset(dest, '^', abs(dy))
    dest[abs(dy)] = '\0'


def change_place_on_numpad(prev: byte, cur: byte, result1: byte*, result2: byte*) -> int:
    places: int[2][128]
    memset(places, 0, sizeof(places))

    places['7'] = [0, 0]
    places['8'] = [1, 0]
    places['9'] = [2, 0]

    places['4'] = [0, 1]
    places['5'] = [1, 1]
    places['6'] = [2, 1]

    places['1'] = [0, 2]
    places['2'] = [1, 2]
    places['3'] = [2, 2]

    # nothing on the left of zero
    places['0'] = [1, 3]
    places['A'] = [2, 3]

    old_pos = places[prev]
    new_pos = places[cur]
    dx = new_pos[0] - old_pos[0]
    dy = new_pos[1] - old_pos[1]

    if dx == 0:
        dy_string(result1)
        strcat(result1, "A")
        return 1

    if dy == 0:
        dx_string(result1)
        strcat(result1, "A")
        return 1

    # Result 1: first x, then y
    dx_string(result1)
    dy_string(&result1[strlen(result1)])
    strcat(result1, "A")

    # Result 2: first y, then x
    dy_string(result1)
    dx_string(&result1[strlen(result1)])
    strcat(result1, "A")

    return 2


def get_numpad_moves(code: byte*) -> byte[50][20]:
    assert strlen(code) == 4
    assert is_ascii_digit(code[0])
    assert is_ascii_digit(code[1])
    assert is_ascii_digit(code[2])
    assert code[3] == 'A'

    results: byte[50][20]
    nresults: int
    memset(results, 0, sizeof(results))

    for i = 0; i < 4; i++:
        if i == 0:
            prev = 'A'
        else:
            prev = code[i-1]

        string1: byte[10]
        string2: byte[10]
        count = change_place_on_numpad(prev, code[i], string1, string2)

        if count == 1:
            for k = 0; k < nresults; k++:
                strcat(results[k], string1)
        elif count == 2:
            # Duplicate the results, handle them both ways
            memcpy(&results[nresults], results, nresults * sizeof(results[0]))
            for k = 0; k < nresults; k++:
                strcat(results[k], string1)
                strcat(results[nresults + k], string2)
            nresults *= 2
        else:
            assert False

    return results


def main() -> int:
    moves = get_numpad_moves("029A")
    for i = 0; moves[i][0] != '\0'; i++:
        puts(moves[i])
    return 0
