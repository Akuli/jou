import "stdlib/io.jou"
import "stdlib/ascii.jou"
import "stdlib/math.jou"
import "stdlib/str.jou"
import "stdlib/mem.jou"


# arrow_keypad_table['^']['A'] = [">", NULL]
#
# This means that if we previously pressed ^ and we now press A, we must move right.
global arrow_keypad_table: byte*[128][128]

# Locations of each character in numeric keypad
# For example, numpad_table['7'] = [0, 0] because it's in top left corner.
global numpad_table: int[2][128]


def init_tables() -> None:
    memset(arrow_keypad_table, 0, sizeof(arrow_keypad_table))
    memset(numpad_table, 0, sizeof(numpad_table))

    #   ^ A
    # < v >
    arrow_keypad_table['^']['^'] = "A"
    arrow_keypad_table['^']['A'] = ">A"
    arrow_keypad_table['^']['<'] = "v<A"
    arrow_keypad_table['^']['v'] = "vA"
    arrow_keypad_table['^']['>'] = "(v>|>v)A"

    arrow_keypad_table['A']['^'] = "<A"
    arrow_keypad_table['A']['A'] = "A"
    arrow_keypad_table['A']['<'] = "v<<A"
    arrow_keypad_table['A']['v'] = "(v<|<v)A"
    arrow_keypad_table['A']['>'] = "vA"

    arrow_keypad_table['<']['^'] = ">^A"
    arrow_keypad_table['<']['A'] = ">>^A"
    arrow_keypad_table['<']['<'] = "A"
    arrow_keypad_table['<']['v'] = ">A"
    arrow_keypad_table['<']['>'] = ">>A"

    arrow_keypad_table['v']['^'] = "^A"
    arrow_keypad_table['v']['A'] = "(>^|^>)A"
    arrow_keypad_table['v']['<'] = "<A"
    arrow_keypad_table['v']['v'] = "A"
    arrow_keypad_table['v']['>'] = ">A"

    arrow_keypad_table['>']['^'] = "(<^|^<)A"
    arrow_keypad_table['>']['A'] = "^A"
    arrow_keypad_table['>']['<'] = "<<A"
    arrow_keypad_table['>']['v'] = "<A"
    arrow_keypad_table['>']['>'] = "A"

    # 7 8 9
    # 4 5 6
    # 1 2 3
    #   0 A
    numpad_table['7'] = [0, 0]
    numpad_table['8'] = [1, 0]
    numpad_table['9'] = [2, 0]

    numpad_table['4'] = [0, 1]
    numpad_table['5'] = [1, 1]
    numpad_table['6'] = [2, 1]

    numpad_table['1'] = [0, 2]
    numpad_table['2'] = [1, 2]
    numpad_table['3'] = [2, 2]

    # nothing on the left of zero
    numpad_table['0'] = [1, 3]
    numpad_table['A'] = [2, 3]


def add_dx_string(dx: int, dest: byte*) -> None:
    offset = strlen(dest)
    if dx >= 0:
        memset(&dest[offset], '>', dx)
    else:
        memset(&dest[offset], '<', abs(dx))
    dest[offset + abs(dx)] = '\0'


def add_dy_string(dy: int, dest: byte*) -> None:
    offset = strlen(dest)
    if dy >= 0:
        memset(&dest[offset], 'v', dy)
    else:
        memset(&dest[offset], '^', abs(dy))
    dest[offset + abs(dy)] = '\0'


# Max length estimate: can't be longer than "(xxyyy|yyyxx)A" because numpad is 3x4 size
def get_numpad_regex_for_single_move(prev: byte, cur: byte) -> byte[25]:
    old_pos = numpad_table[prev]
    new_pos = numpad_table[cur]
    dx = new_pos[0] - old_pos[0]
    dy = new_pos[1] - old_pos[1]

    result: byte[25] = ""

    if dx == 0:
        add_dy_string(dy, result)
    elif dy == 0:
        add_dx_string(dx, result)
    elif old_pos[0] == 0 and new_pos[1] == 3:
        # Can't do vertical first, would go to forbidden part
        add_dx_string(dx, result)
        add_dy_string(dy, result)
    elif old_pos[1] == 3 and new_pos[0] == 0:
        # Can't do horizontal first, would go to forbidden part
        add_dy_string(dy, result)
        add_dx_string(dx, result)
    else:
        # We can move first horizontal then vertical, or first vertical then horizontal.
        # Result looks like e.g. "(>>vv|vv>>)A"
        strcat(result, "(")
        add_dx_string(dx, result)
        add_dy_string(dy, result)
        strcat(result, "|")
        add_dy_string(dy, result)
        add_dx_string(dx, result)
        strcat(result, ")")

    strcat(result, "A")
    return result


# Max length estimate: consists of 4 pieces that each fit to 25 bytes
def get_numpad_regex(code: byte*) -> byte[100]:
    assert strlen(code) == 4
    assert is_ascii_digit(code[0])
    assert is_ascii_digit(code[1])
    assert is_ascii_digit(code[2])
    assert code[3] == 'A'

    result: byte[100] = ""

    for i = 0; i < 4; i++:
        if i == 0:
            prev = 'A'
        else:
            prev = code[i-1]
        part = get_numpad_regex_for_single_move(prev, code[i])
        strcat(result, part)

    return result


def find_opening_paren(start: byte*, p: byte*) -> byte*:
    assert p >= start
    assert *p == ')'
    depth = 1
    while depth != 0:
        p--
        assert p >= start
        if *p == ')':
            depth++
        if *p == '(':
            depth--
    assert *p == '('
    return p


def find_closing_paren(p: byte*) -> byte*:
    assert *p == '('
    depth = 1
    while depth != 0:
        p++
        assert *p != '\0'
        if *p == '(':
            depth++
        if *p == ')':
            depth--
    assert *p == ')'
    return p


# Branches look like (choice1|choice2|choice3), where each choice may contain more branching.
# This function calculates how long a choice is, given its start.
def choice_len(p: byte*) -> int:
    n = 0
    depth = 0
    for n = 0; p[n] != '\0'; n++:
        if depth == 0 and (p[n] == '|' or p[n] == ')'):
            # Found it :)
            break
        if p[n] == '(':
            depth++
        if p[n] == ')':
            depth--

    return n


# For looping through all choices.
def next_choice(prev_start: byte*) -> byte*:
    assert prev_start != NULL
    end = &prev_start[choice_len(prev_start)]
    if *end == ')':
        # Last choice was processed, we're done
        return NULL
    assert *end == '|'
    return &end[1]


class StringBuilder:
    ptr: byte*
    len: long
    alloc: long

    def grow(self, desired_size: long) -> None:
        if self->alloc == 0:
            self->alloc = 1
        while self->alloc < desired_size:
            self->alloc *= 2

        self->ptr = realloc(self->ptr, sizeof(self->ptr[0]) * self->alloc)
        assert self->ptr != NULL

    def append_str_n(self, s: byte*, n: long) -> None:
        assert n >= 0
        self->grow(self->len + n)
        memcpy(&self->ptr[self->len], s, n)
        self->len += n

    def append_str(self, s: byte*) -> None:
        self->append_str_n(s, strlen(s))

    def terminate(self) -> None:
        self->grow(self->len + 1)
        self->ptr[self->len] = '\0'


# If two branchings are after each other, combines them like so:
# (a|b)(c|d) --> (ac|ad|bc|bd)
def combine_adjacent_branches(orig_regex: byte*) -> byte*:
    close1 = strstr(orig_regex, ")(")
    if close1 == NULL:
        return NULL  # nothing to do

    open1 = find_opening_paren(orig_regex, close1)
    open2 = &close1[1]
    close2 = find_closing_paren(open2)

    sb = StringBuilder{}

    # Add the prefix that is not changed
    sb.append_str_n(orig_regex, (open1 as long) - (orig_regex as long))

    # Combine both branches into one.
    sb.append_str("(")
    for choice1 = &open1[1]; choice1 != NULL; choice1 = next_choice(choice1):
        len1 = choice_len(choice1)
        for choice2 = &open2[1]; choice2 != NULL; choice2 = next_choice(choice2):
            len2 = choice_len(choice2)
            sb.append_str_n(choice1, len1)
            sb.append_str_n(choice2, len2)
            sb.append_str("|")

    assert sb.ptr[sb.len - 1] == '|'
    sb.ptr[sb.len - 1] = ')'

    # Add common suffix
    sb.append_str(&close2[1])

    sb.terminate()
    return sb.ptr


# Examples: ('^' indicates p parameter)
#
#   (a(b|c)d|e) --> abd|acd|e
#         ^
#
#   (a|b(c|d)e) --> a|bce|bde
#           ^
def merge_with_outer_group(orig_regex: byte*, p: byte*) -> byte*:
    assert *p == ')'  # end of inner group
    ig_close = p

    while True:
        p++
        p = &p[choice_len(p)]
        if *p == ')':
            og_close = p
            break
        assert *p == '|'
    og_close = p

    ig_open = find_opening_paren(orig_regex, ig_close)
    og_open = find_opening_paren(orig_regex, og_close)

    sb = StringBuilder{}

    sb.append_str_n(orig_regex, (og_open as long) - (orig_regex as long))
    sb.append_str("(")

    for ochoice = &og_open[1]; ochoice != NULL; ochoice = next_choice(ochoice):
        ochoice_len = choice_len(ochoice)
        if ochoice <= ig_open and ig_open <= &ochoice[ochoice_len]:
            # Output multiple choices, one for each inner choice.
            for ichoice = &ig_open[1]; ichoice != NULL; ichoice = next_choice(ichoice):
                ichoice_len = choice_len(ichoice)
                sb.append_str_n(ochoice, (ig_open as long) - (ochoice as long))
                sb.append_str_n(ichoice, ichoice_len)
                sb.append_str_n(&ig_close[1], (&ochoice[ochoice_len] as long) - (&ig_close[1] as long))
                sb.append_str("|")
        else:
            # Output this choice as is.
            sb.append_str_n(ochoice, ochoice_len)
            sb.append_str("|")

    assert sb.ptr[sb.len - 1] == '|'
    sb.ptr[sb.len - 1] = ')'

    sb.append_str(&og_close[1])

    sb.terminate()
    return sb.ptr


# Ensures that there is never a special character '(', '|' or ')' after the
# end-of-branching character ')'. This simplifies adding another arrow keypad,
# because we know what the next character will be when branching is done.
def preprocess_regex(regex: byte*) -> byte*:
    regex = strdup(regex)
    assert regex != NULL

    while True:
        # Handle )(
        regex2 = combine_adjacent_branches(regex)
        if regex2 != NULL:
            free(regex)
            regex = regex2
            continue

        # Handle )| and ))
        p = strstr(regex, ")|")
        if p == NULL:
            p = strstr(regex, "))")
        if p != NULL:
            regex2 = merge_with_outer_group(regex, p)
            assert regex2 != NULL
            free(regex)
            regex = regex2
            continue

        break

    return regex


def shortest_instance_len(regex: byte*) -> long:
    if strchr(regex, '(') == NULL:
        # no more branching
        return strlen(regex)

    if regex[0] != '(':
        # branches later in the regex, let's recurse for that
        i = 0
        while regex[i] != '(':
            i++
        return i + shortest_instance_len(&regex[i])

    # starts with branching, let's handle first branch
    end = find_closing_paren(regex)
    best = -1L
    for choice = &regex[1]; choice != NULL; choice = next_choice(choice):
        substring = strdup(choice)
        assert substring != NULL
        substring[choice_len(choice)] = '\0'
        n = shortest_instance_len(substring)
        free(substring)
        if best == -1 or n == best:
            best = n

    assert best != -1
    return best + shortest_instance_len(&end[1])


def apply_arrow_keypad_to_regex(orig_regex: byte*) -> byte*:
    result = StringBuilder{}

    prev = 'A'
    prevstack: byte[1000]
    prevstack_len = 0

    for i = 0; orig_regex[i] != '\0'; i++:
        if orig_regex[i] == '(':
            # We will need to come back to this state later when handling other cases
            assert prevstack_len < sizeof(prevstack) / sizeof(prevstack[0])
            prevstack[prevstack_len++] = prev
            result.append_str("(")

        elif orig_regex[i] == '|':
            # Process also the letter just after end of branching, since it depends on prev.
            end = strstr(&orig_regex[i], ")")
            assert end != NULL

            # Special characters should have been pre-processed away.
            assert end[1] != '('
            assert end[1] != '|'
            assert end[1] != ')'

            if end[1] != '\0':
                s = arrow_keypad_table[prev][end[1]]
                assert s != NULL
                result.append_str(s)

            result.append_str("|")

            # Come back to earlier state
            assert prevstack_len > 0
            prev = prevstack[prevstack_len - 1]

        elif orig_regex[i] == ')':
            result.append_str(")")
            prevstack_len--
            if orig_regex[i+1] != '\0':
                # Next character has already been processed, skip it but use it as prev
                i++
                prev = orig_regex[i]
                assert prev != '\0'

        else:
            s = arrow_keypad_table[prev][orig_regex[i]]
            assert s != NULL
            result.append_str(s)
            prev = orig_regex[i]

    result.terminate()
    return result.ptr


def do_the_thing(code: byte*) -> None:
    numpad_array = get_numpad_regex(code)

    regex: byte* = numpad_array
    for i = 0; i < 2; i++:
        regex2 = preprocess_regex(regex)
        if regex != &numpad_array[0]:
            free(regex)
        regex = apply_arrow_keypad_to_regex(regex2)
        free(regex2)

    printf("%s --> %lld (%lld)\n", code, shortest_instance_len(regex), strlen(regex))
    fflush(stdout)

    if regex != &numpad_array[0]:
        free(regex)


def main() -> int:
    init_tables()
    do_the_thing("029A")
    do_the_thing("980A")
    do_the_thing("179A")
    do_the_thing("456A")
    do_the_thing("379A")
    return 0
