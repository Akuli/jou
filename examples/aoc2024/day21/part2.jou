import "stdlib/io.jou"
import "stdlib/ascii.jou"
import "stdlib/math.jou"
import "stdlib/str.jou"
import "stdlib/mem.jou"


# arrow_keypad_table['^']['>'] = [">A", NULL]
#
# This means that if robot arm previously pressed ^ and we want it to press >,
# we must move right and then press A.
global arrow_keypad_table: byte*[2][128][128]

# Locations of each character in numeric keypad
# For example, numpad_table['7'] = [0, 0] because it's in top left corner.
global numpad_table: int[2][128]


def init_tables() -> None:
    memset(arrow_keypad_table, 0, sizeof(arrow_keypad_table))
    memset(numpad_table, 0, sizeof(numpad_table))

    #   ^ A
    # < v >
    arrow_keypad_table['^']['^'] = ["A", NULL as byte*]
    arrow_keypad_table['^']['A'] = [">A", NULL as byte*]
    arrow_keypad_table['^']['<'] = ["v<A", NULL as byte*]
    arrow_keypad_table['^']['v'] = ["vA", NULL as byte*]
    arrow_keypad_table['^']['>'] = ["v>A", ">vA"]

    arrow_keypad_table['A']['^'] = ["<A", NULL as byte*]
    arrow_keypad_table['A']['A'] = ["A", NULL as byte*]
    arrow_keypad_table['A']['<'] = ["v<<A", NULL as byte*]
    arrow_keypad_table['A']['v'] = ["v<A", "<vA"]
    arrow_keypad_table['A']['>'] = ["vA", NULL as byte*]

    arrow_keypad_table['<']['^'] = [">^A", NULL as byte*]
    arrow_keypad_table['<']['A'] = [">>^A", NULL as byte*]
    arrow_keypad_table['<']['<'] = ["A", NULL as byte*]
    arrow_keypad_table['<']['v'] = [">A", NULL as byte*]
    arrow_keypad_table['<']['>'] = [">>A", NULL as byte*]

    arrow_keypad_table['v']['^'] = ["^A", NULL as byte*]
    arrow_keypad_table['v']['A'] = [">^A", "^>A"]
    arrow_keypad_table['v']['<'] = ["<A", NULL as byte*]
    arrow_keypad_table['v']['v'] = ["A", NULL as byte*]
    arrow_keypad_table['v']['>'] = [">A", NULL as byte*]

    arrow_keypad_table['>']['^'] = ["<^A", "^<A"]
    arrow_keypad_table['>']['A'] = ["^A", NULL as byte*]
    arrow_keypad_table['>']['<'] = ["<<A", NULL as byte*]
    arrow_keypad_table['>']['v'] = ["<A", NULL as byte*]
    arrow_keypad_table['>']['>'] = ["A", NULL as byte*]

    # 7 8 9
    # 4 5 6
    # 1 2 3
    #   0 A
    numpad_table['7'] = [0, 0]
    numpad_table['8'] = [1, 0]
    numpad_table['9'] = [2, 0]

    numpad_table['4'] = [0, 1]
    numpad_table['5'] = [1, 1]
    numpad_table['6'] = [2, 1]

    numpad_table['1'] = [0, 2]
    numpad_table['2'] = [1, 2]
    numpad_table['3'] = [2, 2]

    # nothing on the left of zero
    numpad_table['0'] = [1, 3]
    numpad_table['A'] = [2, 3]


def add_dx_string(dx: int, dest: byte*) -> None:
    offset = strlen(dest)
    if dx >= 0:
        memset(&dest[offset], '>', dx)
    else:
        memset(&dest[offset], '<', abs(dx))
    dest[offset + abs(dx)] = '\0'


def add_dy_string(dy: int, dest: byte*) -> None:
    offset = strlen(dest)
    if dy >= 0:
        memset(&dest[offset], 'v', dy)
    else:
        memset(&dest[offset], '^', abs(dy))
    dest[offset + abs(dy)] = '\0'


# Each sequence of moves fits in 20 characters:
#   - numpad is 3x4, so each move is at most 5 characters (2 horizontal, 3 vertical)
#   - there are 4 moves
#
# There are at most 16 sequences of moves:
#   - start with no moves (1 empty sequence)
#   - for each move, we have in the worst case 2 different ways to do it, doubles 4 times
#
# I used bigger size in case there's mistake :D
def get_numpad_move_sequences(code: byte*) -> byte[50][50]:
    assert strlen(code) == 4
    assert is_ascii_digit(code[0])
    assert is_ascii_digit(code[1])
    assert is_ascii_digit(code[2])
    assert code[3] == 'A'

    results: byte[50][50]
    memset(results, 0, sizeof(results))
    nresults = 1

    for p = code; *p != '\0'; p++:
        if p == code:
            prev = 'A'
        else:
            prev = p[-1]

        old_pos = numpad_table[prev]
        new_pos = numpad_table[*p]
        dx = new_pos[0] - old_pos[0]
        dy = new_pos[1] - old_pos[1]

        if dx == 0:
            for i = 0; i < nresults; i++:
                add_dy_string(dy, results[i])
        elif dy == 0:
            for i = 0; i < nresults; i++:
                add_dx_string(dx, results[i])
        elif old_pos[0] == 0 and new_pos[1] == 3:
            # Can't do vertical first, would go to forbidden part
            for i = 0; i < nresults; i++:
                add_dx_string(dx, results[i])
                add_dy_string(dy, results[i])
        elif old_pos[1] == 3 and new_pos[0] == 0:
            # Can't do horizontal first, would go to forbidden part
            for i = 0; i < nresults; i++:
                add_dy_string(dy, results[i])
                add_dx_string(dx, results[i])
        else:
            # We can move first horizontal then vertical, or first vertical then horizontal.
            # Duplicate results and do both.
            assert 2 * nresults < sizeof(results) / sizeof(results[0])
            memcpy(&results[nresults], results, sizeof(results[0]) * nresults)
            for i = 0; i < nresults; i++:
                add_dx_string(dx, results[i])
                add_dy_string(dy, results[i])
            for i = nresults; i < 2*nresults; i++:
                add_dy_string(dy, results[i])
                add_dx_string(dx, results[i])
            nresults *= 2

        for i = 0; i < nresults; i++:
            strcat(results[i], "A")

    return results


# Cost of user pressing a key on keypad 0
def keypad0_cost(keypad0_prev_key: byte, keypad0_key: byte) -> long:
    return 1


# Cost of robot pressing a key on keypad 1
def keypad1_cost(keypad1_prev_key: byte, keypad1_key: byte) -> long:
    moves = arrow_keypad_table[keypad1_prev_key][keypad1_key]

    best_cost = -1L
    for i = 0; i < 2 and moves[i] != NULL; i++:
        cost = 0L
        prev = 'A'  # robot is still aimed at activate button after the previous key press
        for p = moves[i]; *p != '\0'; p++:
            cost += keypad0_cost(prev, *p)
            prev = *p

        if best_cost == -1 or cost < best_cost:
            best_cost = cost

    return best_cost


# Cost of robot pressing a key on keypad 2
def keypad2_cost(keypad2_prev_key: byte, keypad2_key: byte) -> long:
    moves = arrow_keypad_table[keypad2_prev_key][keypad2_key]

    best_cost = -1L
    for i = 0; i < 2 and moves[i] != NULL; i++:
        cost = 0L
        prev = 'A'  # robot is still aimed at activate button after the previous key press
        for p = moves[i]; *p != '\0'; p++:
            cost += keypad1_cost(prev, *p)
            prev = *p

        if best_cost == -1 or cost < best_cost:
            best_cost = cost

    return best_cost


def count_presses_for_numpad_moves(moves: byte*) -> long:
    cost = 0L
    prev = 'A'  # robot is still aimed at activate button after the previous key press
    for p = moves; *p != '\0'; p++:
        cost += keypad2_cost(prev, *p)
        prev = *p
    return cost


def do_the_thing(code: byte*) -> None:
    printf("Code: %s\n", code)
    fflush(stdout)

    moves = get_numpad_move_sequences(code)

    for i = 0; moves[i][0] != '\0'; i++:
        printf("Trying %s...\n", moves[i])
        n = count_presses_for_numpad_moves(moves[i])
        printf("  %s --> %lld\n", moves[i], n)
        fflush(stdout)
    puts("")


def main() -> int:
    init_tables()
#    printf("%d\n", keypad2_cost('<', '>'))
    do_the_thing("029A")
    do_the_thing("980A")
    do_the_thing("179A")
    do_the_thing("456A")
    do_the_thing("379A")
    return 0
