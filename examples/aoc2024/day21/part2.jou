import "stdlib/io.jou"
import "stdlib/ascii.jou"
import "stdlib/math.jou"
import "stdlib/mem.jou"
import "stdlib/str.jou"


# TODO: these belong to somewhere in stdlib
declare rand() -> int
declare srand(seed: int) -> None


def manhattan_distance(a: int[2], b: int[2]) -> int:
    return abs(a[0]-b[0]) + abs(a[1]-b[1])


class KeyPad:
    rows: byte[3][4]
    aimed_at_x: int
    aimed_at_y: int

    def get(self, x: int, y: int) -> byte:
        if x < 0 or x >= 3 or y < 0 or y >= 4:
            return ' '
        return self->rows[y][x]

    def find_key(self, button_label: byte) -> int[2]:
        for x = 0; x < 3; x++:
            for y = 0; y < 4; y++:
                if self->rows[y][x] == button_label:
                    return [x, y]
        assert False


# Recursive function. Before we recurse, parameters are:
#   first keypad = the numeric keypad attached to door (the only numeric)
#   last keypad = the keypad that a human is typing into
#
# Return value = how many times total the keys on last keypad were pressed.
def press_key(keypads: KeyPad*, nkeypads: int, key_to_press: byte) -> long:
    printf("Press '%c'\n", key_to_press)
    fflush(stdout)

    if nkeypads == 1:
        # Human is typing here, let's simply count the key presses.
        # We don't care what they are, just how many.
        printf(" --> trivial\n")
        fflush(stdout)
        getchar()
        return 1

    pos = keypads[0].find_key(key_to_press)
    old_x = keypads[1].aimed_at_x
    old_y = keypads[1].aimed_at_y
    new_x = pos[0]
    new_y = pos[1]
    dx = new_x - old_x
    dy = new_y - old_y

    if dx < 0:
        dx_key = '<'
        dx_step = -1
    else:
        dx_key = '>'
        dx_step = 1

    if dy < 0:
        dy_key = '^'
        dy_step = -1
    else:
        dy_key = 'v'
        dy_step = 1

    h_first_blocked = (keypads[0].get(new_x, old_y) == ' ')
    v_first_blocked = (keypads[0].get(old_x, new_y) == ' ')
    assert not (h_first_blocked and v_first_blocked)

    if dx == 0 or dy == 0:
        # order doesn't matter
        assert not h_first_blocked
        assert not v_first_blocked
        horizontal_first = True
    elif h_first_blocked:
        horizontal_first = False
    elif v_first_blocked:
        horizontal_first = True
    else:
        # Order usually doesn't matter, but in some cases it does.
        # Let's choose 50% randomly because I can't think of a good way
        # to figure out what's best.
        horizontal_first = (rand() % 100 >= 50)

    result = 0L

    if horizontal_first:
        n = abs(dx)
        while n --> 0:
            result += press_key(&keypads[1], nkeypads - 1, dx_key)
            keypads[1].aimed_at_x += dx_step

        n = abs(dy)
        while n --> 0:
            result += press_key(&keypads[1], nkeypads - 1, dy_key)
            keypads[1].aimed_at_y += dy_step
    else:
        n = abs(dy)
        while n --> 0:
            result += press_key(&keypads[1], nkeypads - 1, dy_key)
            keypads[1].aimed_at_y += dy_step

        n = abs(dx)
        while n --> 0:
            result += press_key(&keypads[1], nkeypads - 1, dx_key)
            keypads[1].aimed_at_x += dx_step

    assert keypads[1].aimed_at_x == new_x
    assert keypads[1].aimed_at_y == new_y
    assert keypads[0].get(new_x, new_y) == key_to_press

    result += press_key(&keypads[1], nkeypads - 1, 'A')
    return result


def main() -> int:
    srand(123)

    numeric_keypad = KeyPad{
        rows = [
            ['7', '8', '9'],
            ['4', '5', '6'],
            ['1', '2', '3'],
            [' ', '0', 'A'],
        ],
    }

    arrow_keypad = KeyPad{
        rows = [
            [' ', '^', 'A'],
            ['<', 'v', '>'],
            [' ', ' ', ' '],
            [' ', ' ', ' '],
        ],
    }

    initial_keypads = [
        numeric_keypad,
        arrow_keypad,
        arrow_keypad,
    ]

    # Aim each keypad to the previous (closer to door) keypad's A button
    for i = 1; i < sizeof(initial_keypads)/sizeof(initial_keypads[0]); i++:
        aim_at = initial_keypads[i-1].find_key('A')
        initial_keypads[i].aimed_at_x = aim_at[0]
        initial_keypads[i].aimed_at_y = aim_at[1]

    f = fopen("sampleinput.txt", "r")
    assert f != NULL

    result = 0L

    line: byte[20]
    while fgets(line, sizeof(line) as int, f) != NULL:
        trim_ascii_whitespace(line)
        puts(line)
        fflush(stdout)

        best = -1L
        limit = 1000L
        for k = 0L; k < limit; k++:
            keypads = initial_keypads

            counter = 0L
            for i = 0; line[i] != '\0'; i++:
                counter += press_key(keypads, sizeof(keypads)/sizeof(keypads[0]) as int, line[i])

            if best == -1 or counter < best:
                printf("  (k=%lld) new best: %lld\n", k, counter)
                fflush(stdout)
                best = counter

                # We found something better, do similar search again to hopefully
                # discover more if there is
                if limit < 2*i:
                    limit = 2*i

        result += best * atoi(line)

    printf("%lld\n", result)  # Output: 126384

    fclose(f)
    return 0
