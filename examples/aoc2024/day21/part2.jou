import "stdlib/io.jou"
import "stdlib/ascii.jou"
import "stdlib/math.jou"
import "stdlib/mem.jou"
import "stdlib/str.jou"


# Compressed strings have bytes and their repetition counts.
# For example, "AAAABB" compresses to:
#
#   [
#       Compressed{b: 'A', repeat: 4},
#       Compressed{b: 'B', repeat: 2},
#       Compressed{b: '\0', repeat: 1},
#   ]
class Compressed:
    b: byte
    repeat: long


def is_fully_compressed(s: Compressed*) -> bool:
    for i = 0; s[i].b != '\0' and s[i+1].b != '\0'; i++:
        if s[i].repeat == 0:
            # unnecessary item
            return False
        if s[i].b == s[i+1].b:
            # same thing repeated, the whole point was to merge repeats :)
            return False
    return True


# Merges adjacent compressed bytes.
def improve_compression(s: Compressed*) -> None:
    dest = s
    for src = s; src->b != '\0'; src++:
        if src->repeat != 0:
            if dest != s and src->b == dest[-1].b:
                dest[-1].repeat += src->repeat
            else:
                *dest++ = *src

    # add terminator
    dest->b = '\0'
    dest->repeat = 1


def compress(string: byte*) -> Compressed*:
    size = strlen(string) + 1
    result: Compressed* = malloc(size * sizeof(result[0]))
    assert result != NULL

    for i = 0; i < size; i++:
        result[i] = Compressed{b = string[i], repeat = 1}

    improve_compression(result)
    return result


def compressed_strlen(c: Compressed*) -> long:
    result = 0L
    for i = 0; c[i].b != '\0'; i++:
        result += c[i].repeat
    return result


#def compressed_puts(c: Compressed*) -> None:
#    for i = 0; c[i].b != '\0'; i++:
#        n = c[i].repeat
#        while n --> 0:
#            putchar(c[i].b)
#    putchar('\n')
#    fflush(stdout)


# TODO: these belong to somewhere in stdlib
declare rand() -> int
declare srand(seed: int) -> None


def manhattan_distance(a: int[2], b: int[2]) -> int:
    return abs(a[0]-b[0]) + abs(a[1]-b[1])


class KeyPad:
    rows: byte[3][4]

    def get(self, x: int, y: int) -> byte:
        if x < 0 or x >= 3 or y < 0 or y >= 4:
            return ' '
        return self->rows[y][x]

    def find_button(self, button_label: byte) -> int[2]:
        for x = 0; x < 3; x++:
            for y = 0; y < 4; y++:
                if self->rows[y][x] == button_label:
                    return [x, y]
        assert False

    # Sometimes (not very often), the order of horizontal and vertical moves
    # matters. I don't know a good way to pick them properly, so let's try
    # random guessing.
    #
    # Return value must be free()d.
    def get_random_presses(self, what_to_write: Compressed*) -> Compressed*:
        assert is_fully_compressed(what_to_write)

        n = 0
        while what_to_write[n].b != '\0':
            n++
        max_compressed_length = 3*n

        result: Compressed* = malloc((max_compressed_length + 1) * sizeof(result[0]))
        assert result != NULL

        destptr = result

        for p = &what_to_write[0]; p->b != '\0'; p++:
            if p == &what_to_write[0]:
                prev = 'A'
            else:
                prev = p[-1].b

            pos1 = self->find_button(prev)
            pos2 = self->find_button(p->b)

            dx = pos2[0] - pos1[0]
            dy = pos2[1] - pos1[1]

            if dx < 0:
                dx_byte = '<'
            else:
                dx_byte = '>'

            if dy < 0:
                dy_byte = '^'
            else:
                dy_byte = 'v'

            h_first_blocked = (self->get(pos1[0] + dx, pos1[1]) == ' ')
            v_first_blocked = (self->get(pos1[0], pos1[1] + dy) == ' ')
            assert not (h_first_blocked and v_first_blocked)

            if dx == 0 or dy == 0:
                # order doesn't matter
                assert not h_first_blocked
                assert not v_first_blocked
                horizontal_first = True
            elif h_first_blocked:
                horizontal_first = False
            elif v_first_blocked:
                horizontal_first = True
            else:
                # Order usually doesn't matter, but in some cases it does.
                # Let's choose 50% randomly because I can't think of a good way
                # to figure out what's best.
                horizontal_first = (rand() % 100 >= 50)

            if horizontal_first:
                *destptr++ = Compressed{b = dx_byte, repeat = abs(dx)}
                *destptr++ = Compressed{b = dy_byte, repeat = abs(dy)}
            else:
                *destptr++ = Compressed{b = dy_byte, repeat = abs(dy)}
                *destptr++ = Compressed{b = dx_byte, repeat = abs(dx)}

            *destptr++ = Compressed{b = 'A', repeat = p->repeat}

        assert destptr == &result[max_compressed_length]
        *destptr = Compressed{b = '\0', repeat = 1}
        improve_compression(result)
        return result


def main() -> int:
    srand(123)

    numeric_keypad = KeyPad{rows = [
        ['7', '8', '9'],
        ['4', '5', '6'],
        ['1', '2', '3'],
        [' ', '0', 'A'],
    ]}

    arrow_keypad = KeyPad{rows = [
        [' ', '^', 'A'],
        ['<', 'v', '>'],
        [' ', ' ', ' '],
        [' ', ' ', ' '],
    ]}

    f = fopen("sampleinput.txt", "r")
    assert f != NULL

    result = 0L

    line: byte[20]
    while fgets(line, sizeof(line) as int, f) != NULL:
        trim_ascii_whitespace(line)
        puts(line)
        fflush(stdout)
        line_c = compress(line)

        shortest_len = -1L
        limit = 10000L
        for i = 0L; i < limit; i++:
            presses = numeric_keypad.get_random_presses(line_c)

            repeat = 2
            while repeat --> 0:
                printf("  repeat = %d\n", repeat)
                fflush(stdout)
                presses2 = arrow_keypad.get_random_presses(presses)
                free(presses)
                presses = presses2

            new_len = compressed_strlen(presses)
            free(presses)

            if shortest_len == -1 or new_len < shortest_len:
                printf("  (i=%lld) new shortest len: %lld\n", i, new_len)
                fflush(stdout)
                shortest_len = new_len

                # We found something better, do similar search again to hopefully
                # discover more if there is
                if limit < 2*i:
                    limit = 2*i

        free(line_c)
        result += shortest_len * atoi(line)

    printf("%lld\n", result)  # Output: 126384

    fclose(f)
    return 0
