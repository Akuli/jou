# Instructions:
# 1. Run `jou perlin_noise.jou`.
# 2. Look at `FILENAME.ppm`.

import "stdlib/io.jou"
import "stdlib/mem.jou"
import "stdlib/math.jou"
import "stdlib/rand.jou"

# How many cells in each direction (SIZE^2 total)
const SIZE: int = 10

# How many pixels fit into a cell in each direction (CELL_PIXELS^2 total)
const CELL_PIXELS: int = 50

# dimensions of output image
const HEIGHT = 800
const WIDTH = 800


# Generates a random 2D vector of length 1 for each corner of a cell.
# We have SIZE^2 cells, (SIZE+1)^2 corners and hence (SIZE+1)^2 unit vectors.
def generate_unit_vectors() -> float[2]*:
    num_corners = (SIZE + 1) * (SIZE + 1)
    result: float[2]* = malloc(sizeof(result[0]) * num_corners)
    for i = 0; i < num_corners; i++:
        angle = rand()
        result[i] = [cosf(angle), sinf(angle)]
    return result


def locate_corners(x: int, y: int) -> int[2][4]:
    return [
        [x, y],
        [x+1, y],
        [x, y+1],
        [x+1, y+1],
    ]


def vectors_from_corners_to_point(
    corners: int[2][4], pixel_x: float, pixel_y: float
) -> float[2][4]:
    result: float[2][4]
    for i = 0; i < 4; i++:
        result[i] = [pixel_x - corners[i][0], pixel_y - corners[i][1]]
    return result


def compute_dot_products(unit_vectors: float[2][4], ctp_vectors: float[2][4]) -> float[4]:
    result: float[4]
    for i = 0; i < 4; i++:
        u = unit_vectors[i]
        v = ctp_vectors[i]
        result[i] = u[0]*v[0] + u[1]*v[1]
    return result


def easing_func(x: float) -> float:
    return 6*(x*x*x*x*x) - 15*(x*x*x*x) + 10*(x*x*x)


def interpolate(
    dot_products: float[4], pixel_x: float, pixel_y: float, cell_x: int, cell_y: int
) -> float:
    x = easing_func(pixel_x - cell_x)
    y = easing_func(pixel_y - cell_y)

    m1 = dot_products[0] + x * (dot_products[1] - dot_products[0])
    m2 = dot_products[2] + x * (dot_products[3] - dot_products[2])
    m3 = m1 + y * (m2 - m1)

    return m3


def choose_unit_vectors(corners: int[2][4], unit_vectors: float[2]*) -> float[2][4]:
    result: float[2][4]
    for i = 0; i < 4; i++:
        x = corners[i][0]
        y = corners[i][1]
        result[i] = unit_vectors[x*(SIZE + 1) + y]
    return result


# type of file is .ppm, so filename can be something like "FILENAME.ppm"
def save_perlin_image(noise: float[HEIGHT][WIDTH], width: int, height: int, filename: const char*) -> void:
    FILE* file = fopen(filename, "wb");
    fprintf(file, "P6\n%d %d\n255\n", width, height);

    minValue: float = -sqrt(2.0) / 2.0;
    maxValue: float = sqrt(2.0) / 2.0;
    range: float = maxValue - minValue;
    
    for y = 0; y < height; y++:
        for x = 0; x < width; x++:
            float normalized = (noise[y][x] - minValue) / range;

            gray: unsigned char = normalized * 255.0 as unsigned char;

            fputc(gray, file);
            fputc(gray, file);
            fputc(gray, file);

    fclose(file);


def main() -> int:
    image_size = SIZE * CELL_PIXELS  # width and height of image (it is square shaped)

    image: byte[3]* = malloc(sizeof(image[0]) * image_size * image_size)
    unit_vectors = generate_unit_vectors()

    noise: float[HEIGHT][WIDTH] = malloc(HEIGHT * WIDTH * sizeof(float))

    for cell_x = 0; cell_x < SIZE; cell_x++:
        for cell_y = 0; cell_y < SIZE; cell_y++:
            corners = locate_corners(cell_x, cell_y)
            chosen_unit_vectors = choose_unit_vectors(corners, unit_vectors)

            for i = 0; i < CELL_PIXELS; i++:
                for j = 0; j < CELL_PIXELS; j++:
                    x = cell_x + i / (CELL_PIXELS as float)
                    y = cell_y + j / (CELL_PIXELS as float)

                    ctp_vectors = vectors_from_corners_to_point(corners, x, y)
                    dot_products = compute_dot_products(chosen_unit_vectors, ctp_vectors)

                    noise_value = interpolate(dot_products, x, y, cell_x, cell_y)

                    # Noise value is between +-sqrt(2)/2. For a proof, see:
                    # https://digitalfreepen.com/2017/06/20/range-perlin-noise.html
                    pixel_value = roundf((noise_value + sqrtf(2)/2)/sqrtf(2) * 255) as byte

                    noise[y*CELL_PIXELS as int][x*CELL_PIXELS as int] = pixel_value

    free(unit_vectors)

    # your own filename here, file goes to current directory
    save_perlin_image(noise, WIDTH, HEIGHT, "FILENAME.ppm")

    free(noise)

    return 0