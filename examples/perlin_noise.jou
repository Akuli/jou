# Instructions:
# 1. Run `jou perlin_noise.jou`.
# 2. Look at `FILENAME.ppm`.

import "stdlib/io.jou"
import "stdlib/mem.jou"
import "stdlib/math.jou"
import "stdlib/rand.jou"

# How many cells in each direction (SIZE^2 total)
const SIZE: int = 20

# How many pixels fit into a cell in each direction (CELL_PIXELS^2 total)
const CELL_PIXELS: int = 40

# NOTE: SIZE * CELL_PIXELS = HEIGHT/WIDTH in order to fill the entire image

# dimensions of output image
# if you change these, you must also change the list sizes
# in save_perlin_image()
const HEIGHT: int = 800
const WIDTH: int = 800

# Generates a random 2D vector of length 1 for each corner of a cell.
# We have SIZE^2 cells, (SIZE+1)^2 corners and hence (SIZE+1)^2 unit vectors.
def generate_unit_vectors() -> float[2]*:
    num_corners = (SIZE + 1) * (SIZE + 1)
    result: float[2]* = malloc(sizeof(result[0]) * num_corners)
    for i = 0; i < num_corners; i++:
        angle = rand()
        result[i] = [cosf(angle), sinf(angle)]
    return result


def locate_corners(x: int, y: int) -> int[2][4]:
    return [
        [x, y],
        [x+1, y],
        [x, y+1],
        [x+1, y+1],
    ]


def vectors_from_corners_to_point(
    corners: int[2][4], pixel_x: float, pixel_y: float
) -> float[2][4]:
    result: float[2][4]
    for i = 0; i < 4; i++:
        result[i] = [pixel_x - corners[i][0], pixel_y - corners[i][1]]
    return result


def compute_dot_products(unit_vectors: float[2][4], ctp_vectors: float[2][4]) -> float[4]:
    result: float[4]
    for i = 0; i < 4; i++:
        u = unit_vectors[i]
        v = ctp_vectors[i]
        result[i] = u[0]*v[0] + u[1]*v[1]
    return result


def easing_func(x: float) -> float:
    return 6*(x*x*x*x*x) - 15*(x*x*x*x) + 10*(x*x*x)


def interpolate(
    dot_products: float[4], pixel_x: float, pixel_y: float, cell_x: int, cell_y: int
) -> float:
    x = easing_func(pixel_x - cell_x)
    y = easing_func(pixel_y - cell_y)

    m1 = dot_products[0] + x * (dot_products[1] - dot_products[0])
    m2 = dot_products[2] + x * (dot_products[3] - dot_products[2])
    m3 = m1 + y * (m2 - m1)

    return m3


def choose_unit_vectors(corners: int[2][4], unit_vectors: float[2]*) -> float[2][4]:
    result: float[2][4]
    for i = 0; i < 4; i++:
        x = corners[i][0]
        y = corners[i][1]
        result[i] = unit_vectors[x*(SIZE + 1) + y]
    return result


# type of file is .ppm, so filename can be something like "FILENAME.ppm"
# change x and y in float[x][y] to match HEIGHT and WIDTH constants if those are changed
def save_perlin_image(noise: double*, width: int, height: int, filename: byte*) -> None:
    file = fopen(filename, "wb")
    fprintf(file, "P6\n%d %d\n255\n", width, height)

    minValue: double = -sqrt(2.0) / 2.0
    maxValue: double = sqrt(2.0) / 2.0
    range: double = maxValue - minValue
    
    for i = 0; i < height * width; i++:
        normalized: double = (noise[i] - minValue) / range

        gray: byte = normalized * 255.0 as byte

        fputc(gray, file)
        fputc(gray, file)
        fputc(gray, file)

    fclose(file)


def main() -> int:
    unit_vectors = generate_unit_vectors()

    noise: double* = malloc(HEIGHT * WIDTH * sizeof(noise))

    for cell_x = 0; cell_x < SIZE; cell_x++:
        for cell_y = 0; cell_y < SIZE; cell_y++:
            corners = locate_corners(cell_x, cell_y)
            chosen_unit_vectors = choose_unit_vectors(corners, unit_vectors)

            for i = 0; i < CELL_PIXELS; i++:
                for j = 0; j < CELL_PIXELS; j++:
                    x = cell_x + i / (CELL_PIXELS as float)
                    y = cell_y + j / (CELL_PIXELS as float)

                    ctp_vectors = vectors_from_corners_to_point(corners, x, y)
                    dot_products = compute_dot_products(chosen_unit_vectors, ctp_vectors)

                    noise_value = interpolate(dot_products, x, y, cell_x, cell_y)

                    # Noise value is between +-sqrt(2)/2. For a proof, see:
                    # https://digitalfreepen.com/2017/06/20/range-perlin-noise.html
                    # pixel_value = roundf((noise_value + sqrtf(2)/2)/sqrtf(2) * 255)
                    # uncomment the above line and change the noise array assignment
                    # to pixel_value to get a contour style map!

                    pixel_x = cell_x * CELL_PIXELS + i
                    pixel_y = cell_y * CELL_PIXELS + j
                    noise[pixel_y * WIDTH + pixel_x] = noise_value

    free(unit_vectors)

    # your own filename here, file goes to current directory
    save_perlin_image(noise, WIDTH, HEIGHT, "FILENAME.ppm")

    free(noise)

    return 0