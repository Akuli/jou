# Instructions:
# 1. Run `jou perlin_noise.jou`.
# 2. Look at `perlin_noise.ppm`.
# the output is somewhat blurry at the moment.

import "stdlib/io.jou"
import "stdlib/mem.jou"
import "stdlib/math.jou"
import "stdlib/random.jou"

# How many cells in each direction (SIZE^2 total)
const SIZE: int = 10

# How many pixels fit into a cell in each direction (CELL_PIXELS^2 total)
const CELL_PIXELS: int = 50


# Generates a random 2D vector of length 1 for each corner of a cell.
# We have SIZE^2 cells, (SIZE+1)^2 corners and hence (SIZE+1)^2 unit vectors.
def generate_unit_vectors() -> float[2]*:
    num_corners = (SIZE + 1) * (SIZE + 1)
    result: float[2]* = malloc(sizeof(result[0]) * num_corners)
    for i = 0; i < num_corners; i++:
        angle = rand()
        result[i] = [cosf(angle), sinf(angle)]
    return result


def locate_corners(x: int, y: int) -> int[2][4]:
    return [
        [x, y],
        [x+1, y],
        [x, y+1],
        [x+1, y+1],
    ]


def vectors_from_corners_to_point(
    corners: int[2][4], pixel_x: float, pixel_y: float
) -> float[2][4]:
    result: float[2][4]
    for i = 0; i < 4; i++:
        result[i] = [pixel_x - corners[i][0], pixel_y - corners[i][1]]
    return result


def compute_dot_products(unit_vectors: float[2][4], ctp_vectors: float[2][4]) -> float[4]:
    result: float[4]
    for i = 0; i < 4; i++:
        u = unit_vectors[i]
        v = ctp_vectors[i]
        result[i] = u[0]*v[0] + u[1]*v[1]
    return result


def easing_func(x: float) -> float:
    return 6*(x*x*x*x*x) - 15*(x*x*x*x) + 10*(x*x*x)


def interpolate(
    dot_products: float[4], pixel_x: float, pixel_y: float, cell_x: int, cell_y: int
) -> float:
    x = easing_func(pixel_x - cell_x)
    y = easing_func(pixel_y - cell_y)

    m1 = dot_products[0] + x * (dot_products[1] - dot_products[0])
    m2 = dot_products[2] + x * (dot_products[3] - dot_products[2])
    m3 = m1 + y * (m2 - m1)

    return m3


def choose_unit_vectors(corners: int[2][4], unit_vectors: float[2]*) -> float[2][4]:
    result: float[2][4]
    for i = 0; i < 4; i++:
        x = corners[i][0]
        y = corners[i][1]
        result[i] = unit_vectors[x*(SIZE + 1) + y]
    return result


def main() -> int:
    image_size = SIZE * CELL_PIXELS  # width and height of image (it is square shaped)

    image: byte* = malloc(sizeof(image[0]) * image_size * image_size)
    unit_vectors = generate_unit_vectors()

    for cell_x = 0; cell_x < SIZE; cell_x++:
        for cell_y = 0; cell_y < SIZE; cell_y++:
            corners = locate_corners(cell_x, cell_y)
            chosen_unit_vectors = choose_unit_vectors(corners, unit_vectors)

            for i = 0; i < CELL_PIXELS; i++:
                for j = 0; j < CELL_PIXELS; j++:
                    x = cell_x + i / (CELL_PIXELS as float)
                    y = cell_y + j / (CELL_PIXELS as float)

                    ctp_vectors = vectors_from_corners_to_point(corners, x, y)
                    dot_products = compute_dot_products(chosen_unit_vectors, ctp_vectors)

                    noise_value = interpolate(dot_products, x, y, cell_x, cell_y)

                    # Noise value is between +-sqrt(2)/2. For a proof, see:
                    # https://digitalfreepen.com/2017/06/20/range-perlin-noise.html
                    v = roundf((noise_value + sqrtf(2)/2)/sqrtf(2) * 255) as byte

                    im_x = cell_x*CELL_PIXELS + i
                    im_y = cell_y*CELL_PIXELS + j
                    image[im_y*image_size + im_x] = v


    free(unit_vectors)

    file = fopen("perlin_noise.ppm", "w")
    fprintf(file, "P5\n%d %d\n255\n", SIZE * CELL_PIXELS, SIZE * CELL_PIXELS)
    fwrite(image, 1, image_size * image_size, file)
    fclose(file)
    printf("Wrote perlin_noise.ppm\n")  # Output: Wrote perlin_noise.ppm

    free(image)
    return 0
