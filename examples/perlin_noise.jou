# Instructions:
# 1. Download stb_image_write.h from https://raw.githubusercontent.com/nothings/stb/refs/heads/master/stb_image_write.h
# 2. Compile stb_image_write.h to `.o` file. For example, if you have gcc, do this:
#
#   $ gcc -x c -DSTB_IMAGE_WRITE_IMPLEMENTATION stb_image_write.h -c -o stb_image_write.o
#
# Make sure that you end up with `examples/stb_image_write.o`.
#
# 3. Run `jou perlin_noise.jou`.
# 4. Look at `out.png`.

import "stdlib/io.jou"
import "stdlib/mem.jou"
import "stdlib/list.jou"
import "stdlib/math.jou"

link "./stb_image_write.o"
declare stbi_write_png(filename: byte*, w: int, h: int, comp: int, data: void*, stride_in_bytes: int) -> int

# How many cells in each direction (SIZE^2 total)
const SIZE: int = 10

# How many pixels fit into a cell in each direction (CELL_PIXELS^2 total)
const CELL_PIXELS: int = 50


global next: uint32
const RAND_MAX: int = 32767

def rand() -> int:
    next = (next * 1103515245 + 12345) as uint32
    return ((next/65536) as uint32) % 32768


def rand_0to1() -> float:
    return rand() / (RAND_MAX as float)


def make_grid() -> List[int[2]]:
    result = List[int[2]]{}
    for x = 0; x < SIZE + 1; x++:
        for y = 0; y < SIZE + 1; y++:
            result.append([x, y])
    return result


def get_unit_vectors(grid: List[int[2]]) -> List[float[2]]:
    result = List[float[2]]{}
    for i = 0; i < grid.len; i++:
        angle = rand_0to1() * 2 * acosf(-1)
        vector = [cosf(angle), sinf(angle)]
        result.append(vector)
    return result


def locate_corners(x: int, y: int) -> int[2][4]:
    return [
        [x, y],
        [x+1, y],
        [x, y+1],
        [x+1, y+1],
    ]


def vectors_from_corners_to_point(
    corners: int[2][4], pixel_x: float, pixel_y: float
) -> float[2][4]:
    result: float[2][4]
    for i = 0; i < 4; i++:
        result[i] = [pixel_x - corners[i][0], pixel_y - corners[i][1]]
    return result


def compute_dot_products(unit_vectors: float[2][4], ctp_vectors: float[2][4]) -> float[4]:
    result: float[4]
    for i = 0; i < 4; i++:
        u = unit_vectors[i]
        v = ctp_vectors[i]
        result[i] = u[0]*v[0] + u[1]*v[1]
    return result


def easing_func(x: float) -> float:
    return 6*(x*x*x*x*x) - 15*(x*x*x*x) + 10*(x*x*x)


def interpolate(
    dot_products: float[4], pixel_x: float, pixel_y: float, cell_x: int, cell_y: int
) -> float:
    x = easing_func(pixel_x - cell_x)
    y = easing_func(pixel_y - cell_y)

    m1 = dot_products[0] + x * (dot_products[1] - dot_products[0])
    m2 = dot_products[2] + x * (dot_products[3] - dot_products[2])
    m3 = m1 + y * (m2 - m1)

    return m3


def choose_unit_vectors(corners: int[2][4], unit_vectors: List[float[2]]) -> float[2][4]:
    result: float[2][4]
    for i = 0; i < 4; i++:
        x = corners[i][0]
        y = corners[i][1]
        result[i] = unit_vectors.ptr[x*(SIZE + 1) + y]
    return result


def main() -> int:
    image: byte[3]* = malloc(sizeof(image[0]) * SIZE * SIZE * CELL_PIXELS * CELL_PIXELS)

    grid = make_grid()
    unit_vectors = get_unit_vectors(grid)

    for ig = 0; ig < grid.len; ig++:
        cell_x = grid.ptr[ig][0]
        cell_y = grid.ptr[ig][1]
        if cell_x == SIZE or cell_y == SIZE:
            continue

        corners = locate_corners(cell_x, cell_y)
        chosen_unit_vectors = choose_unit_vectors(corners, unit_vectors)

        for i = 0; i < CELL_PIXELS; i++:
            for j = 0; j < CELL_PIXELS; j++:
                x = cell_x + i / (CELL_PIXELS as float)
                y = cell_y + j / (CELL_PIXELS as float)

                ctp_vectors = vectors_from_corners_to_point(corners, x, y)
                dot_products = compute_dot_products(chosen_unit_vectors, ctp_vectors)

                noise_value = interpolate(dot_products, x, y, cell_x, cell_y)
                v = ((noise_value + sqrtf(2) / 2)/sqrtf(2) * 255) as byte

                im_x = (x * CELL_PIXELS + 0.5) as int
                im_y = (y * CELL_PIXELS + 0.5) as int

                image[im_y*SIZE*CELL_PIXELS + im_x] = [v,v,v]

    free(grid.ptr)
    free(unit_vectors.ptr)

    ret = stbi_write_png("out.png", SIZE*CELL_PIXELS, SIZE*CELL_PIXELS, 3, image, SIZE*CELL_PIXELS*3)
    if ret == 0:
        printf("Error writing image to file :(\n")
    else:
        # Output: Wrote out.png
        printf("Wrote out.png\n", ret)

    free(image)
    return 0
