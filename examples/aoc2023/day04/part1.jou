import "stdlib/io.jou"
import "stdlib/mem.jou"
import "stdlib/str.jou"
import "stdlib/ascii.jou"


# Finds all non-whitespace parts of a string.
# For example:  " foo bar  baz \n" --> ["foo", "bar", "baz", NULL]
#
# Modifies s in-place to put '\0' bytes where words end.
# Returns an array of byte*, using NULL to mark last word.
#
# Return value (and perhaps s) must be free()d, but individual strings don't.
def split_by_ascii_whitespace(s: byte*) -> byte**:
    # Count how many non-whitespace sections we have.
    count = 0
    flag = False
    for p = s; *p != '\0'; p++:
        if not flag and not is_ascii_whitespace(*p):
            count++
            flag = True
        elif flag and is_ascii_whitespace(*p):
            flag = False

    result: byte** = malloc(sizeof(result[0]) * (count + 1))
    result_ptr = result

    while True:
        while is_ascii_whitespace(*s):
            s++
        if *s == '\0':
            break
        *result_ptr++ = s

        while not is_ascii_whitespace(*s):
            s++

        if *s == '\0':
            break  # do not go past end of string

        # mark end of word and move on
        *s++ = '\0'

    assert result_ptr == &result[count]
    *result_ptr = NULL
    return result


def main() -> int:
    f = fopen("sampleinput.txt", "r")
    assert f != NULL

    total_score = 0

    line: byte[1000]
    while fgets(line, sizeof(line) as int, f) != NULL:
        words = split_by_ascii_whitespace(line)
        assert words[0] != NULL and strcmp(words[0], "Card") == 0
        assert words[1] != NULL  # id number

        winning: int[100]
        nwinning = 0
        score = 0

        no_separator_yet = True
        for i = 2; words[i] != NULL; i++:
            if strcmp(words[i], "|") == 0:
                no_separator_yet = False
            else:
                n = atoi(words[i])
                if no_separator_yet:
                    assert nwinning < sizeof(winning)/sizeof(winning[0])
                    winning[nwinning++] = n
                else:
                    # check if this is a winning number
                    for k = 0; k < nwinning; k++:
                        if winning[k] == n:
                            score++
                            break

        if score != 0:
            k = 1
            for i = 1; i < score; i++:
                k *= 2
            total_score += k

    fclose(f)

    printf("%d\n", total_score)
    return 0
