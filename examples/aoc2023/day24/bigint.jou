import "stdlib/mem.jou"


class BigInt:
    data: byte[24]  # little endian, data[23] includes sign bit


def bigint(value: long) -> BigInt:
    # assumes little-endian CPU
    data: byte[24]
    if value < 0:
        memset(&data, 0xff, sizeof(data))
    else:
        memset(&data, 0, sizeof(data))
    memcpy(&data, &value, sizeof(value))
    return BigInt{data = data}


def bigint_to_long(x: BigInt) -> long:
    # assume that value fits into 64-bit long
    # also assume little-endian
    result: long
    memcpy(&result, &x.data, sizeof(result))
    return result


# TODO: methods are kinda annoying because you'd need temporary values.
# e.g. foo.bar().baz() doesn't work, tries to do take address of bar() return value


# x+y
def bigadd(x: BigInt, y: BigInt) -> BigInt:
    result = bigint(0)
    carry_bit = 0

    for i = 0; i < sizeof(x.data); i++:
        result_byte = (x.data[i] as int) + (y.data[i] as int) + carry_bit
        if result_byte >= 256:
            carry_bit = 1
        else:
            carry_bit = 0
        result.data[i] = result_byte as byte

    return result


# -x
def bigneg(x: BigInt) -> BigInt:
    # Flipping all bits (~x) is almost same as negating the value.
    # For example, -7 is f9ffffff... and ~7 is f8ffffff...
    for i = 0; i < sizeof(x.data); i++:
        x.data[i] = (0xff as byte) - x.data[i]
    return bigadd(x, bigint(1))


# x-y
def bigsub(x: BigInt, y: BigInt) -> BigInt:
    return bigadd(x, bigneg(y))


# Return values:
#   x < y  -->  -1
#   x == y -->  0
#   x > y  -->  1
def bigcmp(x: BigInt, y: BigInt) -> int:
    x_sign_bit = x.data[sizeof(x.data) - 1] / 128
    y_sign_bit = y.data[sizeof(y.data) - 1] / 128

    if x_sign_bit != y_sign_bit:
        return y_sign_bit - x_sign_bit

    for i = sizeof(x.data) - 1; i >= 0; i--:
        if (x.data[i] as int) < (y.data[i] as int):
            return -1
        if (x.data[i] as int) > (y.data[i] as int):
            return 1

    return 0


# x == y
def bigeq(x: BigInt, y: BigInt) -> bool:
    return bigcmp(x, y) == 0


# Return values:
#   positive --> 1
#   zero     --> 0
#   negative --> -1
def bigsign(x: BigInt) -> int:
    return bigcmp(x, bigint(0))


# |x|
def bigabs(x: BigInt) -> BigInt:
    if bigsign(x) < 0:
        return bigneg(x)
    else:
        return x


# x*y
def bigmul(x: BigInt, y: BigInt) -> BigInt:
    result_sign = bigsign(x) * bigsign(y)
    x = bigabs(x)
    y = bigabs(y)

    result = bigint(0)
    for i = 0; i < sizeof(x.data); i++:
        for k = 0; i+k < sizeof(result.data); k++:
            temp = (x.data[i] as int)*(y.data[k] as int)

            gonna_add = bigint(0)
            gonna_add.data[i+k] = temp as byte
            if i+k+1 < sizeof(gonna_add.data):
                gonna_add.data[i+k+1] = (temp / 256) as byte
            result = bigadd(result, gonna_add)

    if bigsign(result) == result_sign:
        return result
    else:
        return bigneg(result)
