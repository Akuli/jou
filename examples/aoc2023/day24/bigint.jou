import "stdlib/mem.jou"
import "stdlib/io.jou"


class BigInt:
    data: byte[24]  # little endian, data[23] includes sign bit


def bigint(value: long) -> BigInt:
    # assumes little-endian CPU
    data: byte[24]
    if value < 0:
        memset(&data, 0xff, sizeof(data))
    else:
        memset(&data, 0, sizeof(data))
    memcpy(&data, &value, sizeof(value))
    return BigInt{data = data}


def bigint_to_long(x: BigInt) -> long:
    # assume that value fits into 64-bit long
    # also assume little-endian
    result: long
    memcpy(&result, &x.data, sizeof(result))
    return result


# TODO: methods are kinda annoying because you'd need temporary values.
# e.g. foo.bar().baz() doesn't work, tries to do take address of bar() return value


# x+y
def bigadd(x: BigInt, y: BigInt) -> BigInt:
    x_print = x
    y_print = y
    result = bigint(0)
    carry_bit = 0

    for i = 0; i < sizeof(x.data); i++:
        result_byte = (x.data[i] as int) + (y.data[i] as int) + carry_bit
        if result_byte >= 256:
            carry_bit = 1
        else:
            carry_bit = 0
        result.data[i] = result_byte as byte

#    printf("%lld + %lld == %lld\n", bigint_to_long(x_print), bigint_to_long(y_print), bigint_to_long(result))
    return result


# -x
def bigneg(x: BigInt) -> BigInt:
    # Flipping all bits (~x) is almost same as negating the value.
    # For example, -7 is f9ffffff... and ~7 is f8ffffff...
    x_print = x
    for i = 0; i < sizeof(x.data); i++:
        x.data[i] = (0xff as byte) - x.data[i]
    x = bigadd(x, bigint(1))
#    printf("-(%lld) == %lld\n", bigint_to_long(x_print), bigint_to_long(x))
    return x


# x-y
def bigsub(x: BigInt, y: BigInt) -> BigInt:
    return bigadd(x, bigneg(y))


# Return values:
#   x < y  -->  -1
#   x == y -->  0
#   x > y  -->  1
def bigcmp(x: BigInt, y: BigInt) -> int:
    x_sign_bit = x.data[sizeof(x.data) - 1] / 128
    y_sign_bit = y.data[sizeof(y.data) - 1] / 128

    if x_sign_bit != y_sign_bit:
#        if y_sign_bit - x_sign_bit == 1:
#            printf("%lld > %lld\n", bigint_to_long(x), bigint_to_long(y))
#        else:
#            printf("%lld < %lld\n", bigint_to_long(x), bigint_to_long(y))
        return y_sign_bit - x_sign_bit

    for i = sizeof(x.data) - 1; i >= 0; i--:
        if (x.data[i] as int) < (y.data[i] as int):
#            printf("%lld < %lld\n", bigint_to_long(x), bigint_to_long(y))
            return -1
        if (x.data[i] as int) > (y.data[i] as int):
            # neither is negative, x is bigger
#            printf("%lld > %lld\n", bigint_to_long(x), bigint_to_long(y))
            return 1

    # equal
#    printf("%lld == %lld\n", bigint_to_long(x), bigint_to_long(y))
    return 0


# x == y
def bigeq(x: BigInt, y: BigInt) -> bool:
    return bigcmp(x, y) == 0


# Return values:
#   positive --> 1
#   zero     --> 0
#   negative --> -1
def bigsign(x: BigInt) -> int:
    return bigcmp(x, bigint(0))


# |x|
def bigabs(x: BigInt) -> BigInt:
    if bigsign(x) < 0:
        result = bigneg(x)
    else:
        result = x
#    printf("abs(%lld) == %lld\n", bigint_to_long(x), bigint_to_long(result))
    return result


# x*y
def bigmul(x: BigInt, y: BigInt) -> BigInt:
    x_print = x
    y_print = y
    result_is_negative = (bigcmp(x, bigint(0)) * bigcmp(y, bigint(0)) < 0)
    x = bigabs(x)
    y = bigabs(y)

    result = bigint(0)
    for i = 0; i < sizeof(x.data); i++:
        for k = 0; i+k < sizeof(result.data); k++:
            temp = (x.data[i] as int)*(y.data[k] as int)

            gonna_add = bigint(0)
            gonna_add.data[i+k] = temp as byte
            if i+k+1 < sizeof(result.data):
                second_byte = (temp / 256) as byte
                gonna_add.data[i+k+1] = (temp / 256) as byte
            result = bigadd(result, gonna_add)

    if (result_is_negative and bigsign(result) > 0) or ((not result_is_negative) and bigsign(result) < 0):
        result = bigneg(result)

#    printf("%lld * %lld == %lld\n", bigint_to_long(x_print), bigint_to_long(y_print), bigint_to_long(result))
    return result
