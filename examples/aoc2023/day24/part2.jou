import "stdlib/math.jou"
import "stdlib/mem.jou"
import "stdlib/io.jou"
import "./bigint.jou"


class Substitution:
    # var_coeff*var = sum(other_coeffs[i] * other variable) + constant
    #
    # other_coeffs[var] should be zero
    var_coeff: BigInt
    var: int
    other_coeffs: BigInt*
    constant: BigInt

    def print(self, nvariables: int) -> None:
        printf("%lld x%d --> ", bigint_to_long(self->var_coeff), self->var)
        for v = 0; v < nvariables; v++:
            if not bigeq(self->other_coeffs[v], bigint(0)):
                printf("%lld x%d + ", bigint_to_long(self->other_coeffs[v]), v)
        printf("%lld\n", bigint_to_long(self->constant))


declare memcmp(a: void*, b: void*, size: long) -> int


class Equation:
    # sum(coeffs[i] * x_i) = rhs
    nvariables: int
    coeffs: BigInt*
    rhs: BigInt

    def equals(self, other: Equation*) -> bool:
        if self->nvariables != other->nvariables:
            return False

        match = bigeq(self->rhs, other->rhs)
        for v = 0; v < self->nvariables and match; v++:
            if not bigeq(self->coeffs[v], other->coeffs[v]):
                match = False
        if match:
            return True

        match = bigeq(self->rhs, bigneg(other->rhs))
        for v = 0; v < self->nvariables and match; v++:
            if not bigeq(self->coeffs[v], bigneg(other->coeffs[v])):
                match = False
        if match:
            return True

        return False

    def print(self) -> None:
        for v = 0; v < self->nvariables; v++:
            if v > 0:
                printf(" + ")
            printf("%lld x%d", self->coeffs[v], v)
        printf(" = %lld\n", self->rhs)

    def reduce(self) -> None:
        g = bigabs(self->rhs)
        for v = 0; v < self->nvariables; v++:
            if not bigeq(self->coeffs[v], bigint(0)):
                if bigeq(g, bigint(0)):
                    g = bigabs(self->coeffs[v])
                else:
                    g = biggcd(g, bigabs(self->coeffs[v]))
                    if bigeq(g, bigint(1)):
                        return

        if bigeq(g, bigint(0)) or bigeq(g, bigint(1)):
            return

        printf("[%lld]", bigint_to_long(g))
        fflush(stdout)
        self->rhs = bigdiv(self->rhs, g)
        for v = 0; v < self->nvariables; v++:
            self->coeffs[v] = bigdiv(self->coeffs[v], g)


# For each variable, we find an equation that uses the variable.
# We then solve the variable and substitute into other equations.
# To avoid fractions, we multiply other equations as needed.
# When all variables are removed in this way, we look at what we did to find solution.
#
# For example, consider this system (solution is x=12 y=34)
#
#   4x + 2y = 116
#   10x - y = 86
#   -100x + 10y = -860
#
# Starting with variable x:
#   - pick 4x + 2y = 116, because it has smallest x coefficient (less messy later)
#   - delete it from list of equations
#   - rewrite as 4x = 116 - 2y
#   - substitute it into the remaining equations:
#
#       10x - y = 86
#       5(4x) - 2y = 172
#       5(116-2y) - 2y = 172
#       580 - 10y - 2y = 172
#       -12y = -408
#
#     and similarly from the other remaining equation:
#
#       -100x + 10y = -860
#       -25(4x) + 10y = -860
#       -25(116-2y) + 10y = -860
#       -2900 + 50y + 10y = -860
#       60y = 2040
#
# Now list of equations is:
#
#   -12y = -408
#   60y = 2040
#
# Then variable y:
#   - pick -12y = -408
#   - delete it from list of equations
#   - no rewriting to do, already desired form
#   - substitute into the remaining equation:
#
#       60y = 2040
#       -5(-12y) = 2040
#       2040 = 2040
#       0 = 0
#
# At this point all equations should say "0 = 0".
#
# Now we backtrack to find the solutions. The equations substituted were:
#
#   4x = 116 - 2y
#   -12y = -408
#
# From second equation, we get:
#
#   y = -408 / -12 = 34
#
# From first equation, we get:
#
#   x = (116 - 2y)/4 = (116 - 2*34)/4 = 12
#
# You notice that numbers got pretty large. We also avoid that by reducing
# the equations, i.e. dividing by gcd of all their nonzero numbers.

class EquationSolver:
    eqs: Equation*
    neqs: int
    substitution_history: Substitution*
    substitution_history_len: int

    def print(self) -> None:
        printf("%d substitutions done, equations are:\n", self->substitution_history_len)
        for eq = &self->eqs[0]; eq < &self->eqs[self->neqs]; eq++:
            printf("  ")
            eq->print()
        printf("\n")

    def find_equation_with_smallest_nonzero_coeff_for_var(self, var: int) -> Equation*:
        result: Equation* = NULL
        for eq = &self->eqs[0]; eq < &self->eqs[self->neqs]; eq++:
            if not bigeq(eq->coeffs[var], bigint(0)) and (
                result == NULL
                or bigcmp(bigabs(result->coeffs[var]), bigabs(eq->coeffs[var])) > 0
            ):
                result = eq
        return result

    # Do the substitution to all equations.
    # Equations are multiplied by c on both sides to make this work.
    # Getting this part right was hard.
    def substitute(self, sub: Substitution) -> None:
        assert bigeq(sub.other_coeffs[sub.var], bigint(0))

        printf("Substitute")
        fflush(stdout)
        for eq = &self->eqs[0]; eq < &self->eqs[self->neqs]; eq++:
            assert 0 <= sub.var and sub.var < eq->nvariables

            if bigeq(eq->coeffs[sub.var], bigint(0)):
                continue

            # If we're substituting 4x = ..., then ensure the equation contains one of
            # +-4x, +-8x, +-12x, +-16x, ... by replacing coeff of x with lcm(old coeff, 4).
            #
            # Note that lcm(a,b) = a*b/gcd(a,b).
            #multiply_both_sides = bigdiv(sub.var_coeff, biggcd(bigabs(sub.var_coeff), bigabs(eq->coeffs[sub.var])))
            multiply_both_sides = sub.var_coeff
            eq->rhs = bigmul(eq->rhs, multiply_both_sides)
            for v = 0; v < eq->nvariables; v++:
                eq->coeffs[v] = bigmul(eq->coeffs[v], multiply_both_sides)

            coeff_of_x = bigdiv_exact(eq->coeffs[sub.var], sub.var_coeff)

            eq->rhs = bigsub(eq->rhs, bigmul(coeff_of_x, sub.constant))
            for v = 0; v < eq->nvariables; v++:
                eq->coeffs[v] = bigadd(eq->coeffs[v], bigmul(coeff_of_x, sub.other_coeffs[v]))

            eq->coeffs[sub.var] = bigint(0)
            printf(".")
            fflush(stdout)

        self->substitution_history[self->substitution_history_len++] = sub
        self->cleanup()

    def cleanup(self) -> None:
        printf("reduce")
        fflush(stdout)
        for eq = &self->eqs[0]; eq < &self->eqs[self->neqs]; eq++:
            eq->reduce()
            printf(".")
            fflush(stdout)

        printf(" dedup")
        fflush(stdout)
        for i = self->neqs - 1; i >= 0; i--:
            for k = i+1; k < self->neqs; k++:
                if self->eqs[i].equals(&self->eqs[k]):
                    self->eqs[i] = self->eqs[--self->neqs]
                    printf(".")
                    fflush(stdout)
                    break
        printf("\n")
        fflush(stdout)

    def all_equations_are_zero_equals_zero(self) -> bool:
        for eq = &self->eqs[0]; eq < &self->eqs[self->neqs]; eq++:
            if not bigeq(eq->rhs, bigint(0)):
                return False
            for v = 0; v < eq->nvariables; v++:
                if not bigeq(eq->coeffs[v], bigint(0)):
                    return False
        return True


# Equations list should be terminated by an equation with 0 variables.
def solve_linear_system_of_equations(eqs: Equation*, neqs: int) -> BigInt*:
    # count equations and variables
    nvariables = 0
    for i = 0; i < neqs; i++:
        nvariables = max(nvariables, eqs[i].nvariables)

    # Copy all equations to avoid mutating input arguments, lol
    solver = EquationSolver{neqs = neqs}
    solver.eqs = malloc(sizeof(solver.eqs[0]) * neqs)
    for i = 0; i < neqs; i++:
        eq = &solver.eqs[i]
        eq->nvariables = nvariables
        eq->coeffs = calloc(sizeof(eq->coeffs[0]), nvariables)
        memcpy(eq->coeffs, eqs[i].coeffs, sizeof(eqs[i].coeffs[0]) * eqs[i].nvariables)
        eq->rhs = eqs[i].rhs
    solver.substitution_history = malloc(sizeof(solver.substitution_history[0]) * nvariables)

    #solver.print()
    solver.cleanup()

    for var = 0; var < nvariables; var++:
        printf("Solver: variable %d/%d\n", var, nvariables)
        eq = solver.find_equation_with_smallest_nonzero_coeff_for_var(var)
        if eq == NULL:
            # unnecessary variable, set it to zero lol
            # I really only want to solve the first two variables, so this is fine.
            sub = Substitution{var = var, var_coeff = bigint(1), constant = bigint(0)}
            sub.other_coeffs = calloc(nvariables, sizeof(sub.other_coeffs[0]))
            solver.substitute(sub)
            continue

        sub = Substitution{
            var = var,
            var_coeff = eq->coeffs[var],
            other_coeffs = eq->coeffs,
            constant = eq->rhs,
        }
        sub.other_coeffs[var] = bigint(0)

        # delete equation
        *eq = solver.eqs[--solver.neqs]

        # move stuff to other side so we solve the variable
        for v = 0; v < nvariables; v++:
            sub.other_coeffs[v] = bigneg(sub.other_coeffs[v])

        sub.print(nvariables)
        solver.substitute(sub)

    assert solver.all_equations_are_zero_equals_zero()

    for i = 0; i < solver.neqs; i++:
        free(solver.eqs[i].coeffs)
    free(solver.eqs)

    values: BigInt* = calloc(sizeof(values[0]), nvariables)
    for i = solver.substitution_history_len - 1; i >= 0; i--:
        sub = solver.substitution_history[i]
        values[sub.var] = sub.constant
        for v = 0; v < nvariables; v++:
            values[sub.var] = bigadd(values[sub.var], bigmul(sub.other_coeffs[v], values[v]))

        values[sub.var] = bigdiv_exact(values[sub.var], sub.var_coeff)

        free(sub.other_coeffs)

    free(solver.substitution_history)
    return values


def test_equation_solver() -> None:
    # 4x + 2y = 116
    # 10x - y = 86
    # -100x + 10y = -860
    coeffs1 = [bigint(4), bigint(2)]
    coeffs2 = [bigint(10), bigint(-1)]
    coeffs3 = [bigint(-100), bigint(10)]
    eqs = [
        Equation{nvariables = 2, coeffs = coeffs1, rhs = bigint(116)},
        Equation{nvariables = 2, coeffs = coeffs2, rhs = bigint(86)},
        Equation{nvariables = 2, coeffs = coeffs3, rhs = bigint(-860)},
    ]

    result = solve_linear_system_of_equations(eqs, 3)
    printf("x=%lld y=%lld\n", bigint_to_long(result[0]), bigint_to_long(result[1]))  # Output: x=12 y=34
    free(result)


class MovingPoint:
    start: long[3]
    speed: long[3]


# We don't need the whole input, first N lines are enough
def read_input(N: int) -> MovingPoint*:
    f = fopen("input", "r")
    assert f != NULL

    result: MovingPoint* = malloc(N * sizeof(result[0]))
    for i = 0; i < N; i++:
        x: long
        y: long
        z: long
        dx: long
        dy: long
        dz: long
        assert fscanf(f, "%lld, %lld, %lld @ %lld, %lld, %lld\n", &x, &y, &z, &dx, &dy, &dz) == 6
        result[i] = MovingPoint{start = [x,y,z], speed = [dx,dy,dz]}

    fclose(f)
    return result


def get_paired_index(N: int, small: int, big: int) -> int:
    counter = N
    for i = 0; i < N; i++:
        for j = i+1; j < N; j++:
            if i == small and j == big:
                return counter
            counter++
    assert False


# Returned equations describe the moments in time t_1,...,t_N where the moving points align.
# Specifically:
#
#   for each of XY plane, XZ plane, YZ plane:
#       for all moving point indexes i<j<k:
#           p1 = project location of point i at time t_i to the plane
#           p2 = project location of point j at time t_j to the plane
#           p3 = project location of point k at time t_k to the plane
#           the equation says that p1,p2,p3 go along the same line.
#
# To test if 2D points go along the same line, we check if their 2x2 determinant is zero.
# Unfortunately the 2x2 determinant creates products like t_i*t_j into the equations.
# We just replace each of these products with a new dummy variable:
# t_1*t_2 becomes t_(N+1), t_1*t_3 becomes t_(N+2) and so on.
# That gives us enough info to solve this.
#
# The returned list is terminated by an equation with 0 variables.
def create_equations(moving_points: MovingPoint*, N: int, neqs: int*) -> Equation*:
    nvariables = N + N*(N-1)/2  # N normal variables, (n choose 2) paired variables

    eqs: Equation* = calloc(sizeof(eqs[0]), 3*N*N*N + 1)  # more than big enough
    assert eqs != NULL
    *neqs = 0

    planes = [[0,1], [0,2], [1,2]]
    for planeidx = 0; planeidx < 3; planeidx++:
        plane = planes[planeidx]
        for i = 0; i < N; i++:
            for j = i+1; j < N; j++:
                for k = j+1; k < N; k++:
                    eq = &eqs[(*neqs)++]
                    eq->nvariables = nvariables
                    eq->coeffs = calloc(sizeof(eq->coeffs[0]), nvariables)

                    six = bigint(moving_points[i].start[plane[0]])
                    siy = bigint(moving_points[i].start[plane[1]])
                    sjx = bigint(moving_points[j].start[plane[0]])
                    sjy = bigint(moving_points[j].start[plane[1]])
                    skx = bigint(moving_points[k].start[plane[0]])
                    sky = bigint(moving_points[k].start[plane[1]])

                    vix = bigint(moving_points[i].speed[plane[0]])
                    viy = bigint(moving_points[i].speed[plane[1]])
                    vjx = bigint(moving_points[j].speed[plane[0]])
                    vjy = bigint(moving_points[j].speed[plane[1]])
                    vkx = bigint(moving_points[k].speed[plane[0]])
                    vky = bigint(moving_points[k].speed[plane[1]])

                    titj_var = get_paired_index(N, i, j)
                    titk_var = get_paired_index(N, i, k)
                    tjtk_var = get_paired_index(N, j, k)

                    # These can't be written as Jou code, because they contain unknown variables:
                    #   p1 = [six + t_i*vix, siy + t_i*viy]
                    #   p2 = [sjx + t_j*vjx, sjy + t_j*vjy]
                    #   p3 = [skx + t_k*vkx, sky + t_k*vky]
                    #
                    # To ensure straight line, we do:
                    #
                    #   |  x of p1 - x of p2     x of p3 - x of p2  |
                    #   |                                           | = 0
                    #   |  y of p1 - y of p2     y of p3 - y of p2  |
                    #
                    # With sympy (Python library), I expanded this to:
                    #
                    # -six*sjy + six*sky - six*tj*vjy + six*tk*vky + siy*sjx - siy*skx + siy*tj*vjx - siy*tk*vkx - sjx*sky + sjx*ti*viy - sjx*tk*vky + sjy*skx - sjy*ti*vix + sjy*tk*vkx - skx*ti*viy + skx*tj*vjy + sky*ti*vix - sky*tj*vjx - ti*tj*vix*vjy + ti*tj*viy*vjx + ti*tk*vix*vky - ti*tk*viy*vkx - tj*tk*vjx*vky + tj*tk*vjy*vkx
                    eq->coeffs[i] = bigadd4(bigmul(sjx, viy), bigneg(bigmul(sjy, vix)), bigneg(bigmul(skx, viy)), bigmul(sky, vix))
                    eq->coeffs[j] = bigadd4(bigmul(siy, vjx), bigneg(bigmul(six, vjy)), bigmul(skx, vjy), bigneg(bigmul(sky, vjx)))
                    eq->coeffs[k] = bigadd4(bigmul(six, vky), bigneg(bigmul(siy, vkx)), bigneg(bigmul(sjx, vky)), bigmul(sjy, vkx))
                    eq->coeffs[titj_var] = bigsub(bigmul(viy, vjx), bigmul(vix, vjy))
                    eq->coeffs[titk_var] = bigsub(bigmul(vix, vky), bigmul(viy, vkx))
                    eq->coeffs[tjtk_var] = bigsub(bigmul(vjy, vkx), bigmul(vjx, vky))
                    eq->rhs = bigadd6(bigmul(six, sjy), bigneg(bigmul(six, sky)), bigneg(bigmul(siy, sjx)), bigmul(siy, skx), bigmul(sjx, sky), bigneg(bigmul(sjy, skx)))

    return eqs


def lerp(src_min: long, src_max: long, dest_min: long, dest_max: long, value: long) -> long:
    weight1 = value - src_min
    weight2 = src_max - value

    # weighted average: (value1*weight1 + value2*weight2)/(weight1 + weight2)
    top = weight1*dest_max + weight2*dest_min
    bottom = weight1 + weight2
    assert top % bottom == 0
    return top / bottom


def test_lerp() -> None:
    #    0-------1-------2-------3-------4-------5
    #                    ^
    #
    #   100-----120-----140-----160-----180-----200
    #                    ^
    printf("%lld\n", lerp(0, 5, 100, 200, 2))  # Output: 140

    # You can extrapolate outside the input range:
    printf("%lld\n", lerp(0, 5, 100, 200, -1))  # Output: 80


def lerp3D(src_min: long, src_max: long, dest_min: long[3], dest_max: long[3], value: long) -> long[3]:
    return [
        lerp(src_min, src_max, dest_min[0], dest_max[0], value),
        lerp(src_min, src_max, dest_min[1], dest_max[1], value),
        lerp(src_min, src_max, dest_min[2], dest_max[2], value),
    ]


def main() -> int:
    test_equation_solver()
    test_lerp()

    N = 5
    moving_points = read_input(N)

    neqs: int
    eqs = create_equations(moving_points, N, &neqs)

    printf("Created %d equations\n", neqs)  # Output: Created 30 equations

#    for i = 0; i < neqs; i++:
#        eqs[i].print()

    solution = solve_linear_system_of_equations(eqs, neqs)

    # Output: 5 3 4 6 1
    printf(
        "%lld %lld %lld %lld %lld\n",
        bigint_to_long(solution[0]),
        bigint_to_long(solution[1]),
        bigint_to_long(solution[2]),
        bigint_to_long(solution[3]),
        bigint_to_long(solution[4]),
    )

    t1 = bigint_to_long(solution[0])
    t2 = bigint_to_long(solution[1])

    point_at_t1 = [
        moving_points[0].start[0] + t1*moving_points[0].speed[0],
        moving_points[0].start[1] + t1*moving_points[0].speed[1],
        moving_points[0].start[2] + t1*moving_points[0].speed[2],
    ]
    point_at_t2 = [
        moving_points[1].start[0] + t2*moving_points[1].speed[0],
        moving_points[1].start[1] + t2*moving_points[1].speed[1],
        moving_points[1].start[2] + t2*moving_points[1].speed[2],
    ]

    point_initially = lerp3D(t1, t2, point_at_t1, point_at_t2, 0)
    printf("%lld\n", point_initially[0] + point_initially[1] + point_initially[2])  # Output: 47

    free(moving_points)
    for i = 0; i < neqs; i++:
        free(eqs[i].coeffs)
    free(eqs)
    free(solution)

    return 0
