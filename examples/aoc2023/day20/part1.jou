import "stdlib/io.jou"
import "stdlib/str.jou"
import "stdlib/mem.jou"
import "stdlib/ascii.jou"


enum ModuleKind:
    Broadcaster
    FlipFlop
    Conjunction


class Module:
    name: byte[15]
    receives_broadcasts: bool

    # TODO: use Module* instead of void*
    # https://github.com/Akuli/jou/issues/473
    sources: void*[10]
    nsources: int
    destinations: void*[10]
    ndestinations: int

    kind: ModuleKind
    union:
        flip_flop_state: bool
        conjunction_state: bool[10]  # length = nsources


def find_module_if_exists(modules: Module*, nmodules: int, name: byte*) -> Module*:
    for i = 0; i < nmodules; i++:
        if strcmp(modules[i].name, name) == 0:
            return &modules[i]
    return NULL


def find_module(modules: Module*, nmodules: int, name: byte*) -> Module*:
    result = find_module_if_exists(modules, nmodules, name)
    if result == NULL:
        printf("404 '%s'\n", name)
    assert result != NULL
    return result


class GonnaSend:
    from: Module*  # NULL for button
    to: Module*
    value: bool


class TodoList:
    ptr: GonnaSend*
    len: int
    alloc: int

    def send_later(self, from: Module*, to: Module*, value: bool) -> None:
#        printf("  later: %s -%d-> %s\n", from->name, value as int, to->name)

        if self->len == self->alloc:
            if self->alloc == 0:
                self->alloc = 1
            else:
                self->alloc *= 2
            self->ptr = realloc(self->ptr, sizeof(self->ptr[0]) * self->alloc)
            assert self->ptr != NULL

        assert to != NULL
        self->ptr[self->len++] = GonnaSend{from=from, to=to, value=value}

    def pop_left(self) -> GonnaSend:
        # TODO: memmove too slow?
        result = self->ptr[0]
        memmove(&self->ptr[0], &self->ptr[1], --self->len * sizeof(self->ptr[0]))
        return result


def press_button(modules: Module*, nmodules: int, high_counter: int*, low_counter: int*) -> None:
    todo = TodoList{}
    todo.send_later(NULL, find_module(modules, nmodules, "broadcaster"), False)

    while todo.len > 0:
        fflush(stdout)
        item = todo.pop_left()

        if item.value:
            ++*high_counter
        else:
            ++*low_counter

        printf("%s -%d-> %s\n", item.from->name, item.value as int, item.to->name)

        if item.to->kind == ModuleKind::Broadcaster:
            for i = 0; i < item.to->ndestinations; i++:
                todo.send_later(item.to, item.to->destinations[i], item.value)
        elif item.to->kind == ModuleKind::FlipFlop:
            if not item.value:
                item.to->flip_flop_state = not item.to->flip_flop_state
                for i = 0; i < item.to->ndestinations; i++:
                    todo.send_later(item.to, item.to->destinations[i], item.to->flip_flop_state)
        elif item.to->kind == ModuleKind::Conjunction:
            i = 0
            while item.to->sources[i] != item.from:
                i++
                assert i < item.to->nsources
            item.to->conjunction_state[i] = item.value

            all_high = True
            for i = 0; i < item.to->nsources; i++:
                if not item.to->conjunction_state[i]:
                    all_high = False
            for i = 0; i < item.to->ndestinations; i++:
                todo.send_later(item.to, item.to->destinations[i], not all_high)
        else:
            assert False

    free(todo.ptr)


def main() -> int:
    f = fopen("sampleinput2_modified.txt", "r")
    f = fopen("input", "r")
    assert f != NULL

    modules: Module* = NULL
    nmodules = 0

    # Pass 1: Create modules that send
    line: byte[200]
    while fgets(line, sizeof(line) as int, f) != NULL:
        m = Module{}
        if line[0] == '%':
            m.kind = ModuleKind::FlipFlop
        elif line[0] == '&':
            m.kind = ModuleKind::Conjunction
        else:
            assert starts_with(line, "broadcaster")
            m.kind = ModuleKind::Broadcaster

        if m.kind == ModuleKind::Broadcaster:
            m.name = "broadcaster"
        else:
            p = &line[1]
            while *p != '\0' and *p != ' ':
                p++
            *p = '\0'
            assert strlen(&line[1]) < sizeof(m.name)
            strcpy(m.name, &line[1])

        modules = realloc(modules, sizeof(modules[0]) * (nmodules+1))
        assert modules != NULL
        modules[nmodules++] = m

    # Pass 2: Create modules that receive
    rewind(f)
    while fgets(line, sizeof(line) as int, f) != NULL:
        for i = 0; line[i] != '\0'; i++:
            if line[i] == ',':
                line[i] = ' '

        words = split_by_ascii_whitespace(line)
        assert words[0] != NULL and words[1] != NULL
        assert strcmp(words[1], "->") == 0

        for i = 2; words[i] != NULL; i++:
            if find_module_if_exists(modules, nmodules, words[i]) == NULL:
                m = Module{}
                assert strlen(words[i]) < sizeof(m.name)
                strcpy(m.name, words[i])
                m.kind = ModuleKind::FlipFlop

                modules = realloc(modules, sizeof(modules[0]) * (nmodules+1))
                assert modules != NULL
                modules[nmodules++] = m

    # Pass 3: Fill in sources and destinations
    rewind(f)
    while fgets(line, sizeof(line) as int, f) != NULL:
        for i = 0; line[i] != '\0'; i++:
            if line[i] == ',':
                line[i] = ' '

        words = split_by_ascii_whitespace(line)
        assert words[0] != NULL and words[1] != NULL

        name = words[0]
        if name[0] == '%' or name[0] == '&':
            name++
        source = find_module(modules, nmodules, name)

        assert strcmp(words[1], "->") == 0

        for i = 2; words[i] != NULL; i++:
            dest = find_module(modules, nmodules, words[i])
            assert dest->nsources < sizeof(dest->sources)/sizeof(dest->sources[0])
            dest->sources[dest->nsources++] = source
            assert source->ndestinations < sizeof(source->destinations)/sizeof(source->destinations[0])
            source->destinations[source->ndestinations++] = dest

        free(words)

    fclose(f)

    h = 0
    l = 0
    for i = 0; i < 1000; i++:
        press_button(modules, nmodules, &h, &l)
    printf("%d\n", h*l)  # Output: 11687500

    free(modules)

    return 0
