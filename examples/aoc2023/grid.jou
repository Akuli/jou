# This file contains a utility class for AoC solutions.
# It is not in the standard library because it is too AOC-specific IMO.

import "stdlib/str.jou"
import "stdlib/mem.jou"


class Grid:
    width: int
    height: int
    data: byte*

    def is_in_bounds(self, point: int[2]) -> bool:
        x = point[0]
        y = point[1]
        return 0 <= x and x < self->width and 0 <= y and y < self->height

    def get(self, point: int[2]) -> byte:
        assert self->is_in_bounds(point)
        x = point[0]
        y = point[1]
        return self->data[(self->width + 1)*y + x]

    def set(self, point: int[2], value: byte) -> None:
        assert self->is_in_bounds(point)
        x = point[0]
        y = point[1]
        self->data[(self->width + 1)*y + x] = value

    def swap(self, a: int[2], b: int[2]) -> None:
        old_a = self->get(a)
        self->set(a, self->get(b))
        self->set(b, old_a)

    def copy(self) -> Grid:
        return Grid{width = self->width, height = self->height, data = strdup(self->data)}

    def transpose(self) -> None:
        old = self->copy()
        memset(self->data, '\n', strlen(self->data))
        self->width = old.height
        self->height = old.width

        for x = 0; x < self->width; x++:
            for y = 0; y < self->height; y++:
                self->set([x, y], old.get([y, x]))
        free(old.data)

    # returned array is terminated by [-1, -1]
    def find_all(self, b: byte) -> int[2]*:
        result: int[2]* = malloc(sizeof(result[0]) * (self->width * self->height + 1))
        result_len = 0

        for y = 0; y < self->height; y++:
            for x = 0; x < self->width; x++:
                if self->get([x, y]) == b:
                    result[result_len++] = [x, y]

        result = realloc(result, sizeof(result[0]) * (result_len + 1))
        result[result_len] = [-1, -1]
        return result
