import "stdlib/mem.jou"
import "stdlib/str.jou"
import "stdlib/process.jou"
import "stdlib/io.jou"
import "../grid.jou"


def is_intersection(grid: Grid*, point: int[2]) -> bool:
    # Treat start and goal as intersections
    if point[1] == 0 or point[1] == grid->height - 1:
        return True

    if not grid->is_in_bounds(point) or grid->get(point) != '.':
        return False

    directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]
    n = 0
    for i = 0; i < 4; i++:
        new_point = [point[0] + directions[i][0], point[1] + directions[i][1]]
        if grid->is_in_bounds(new_point) and grid->get(new_point) == '.':
            n++
    return n > 2


# Return value: list of [x, y, how_many_steps_away] or [-1,-1,-1] to return less than 4 results
def find_connected_intersections(grid: Grid*, intersection: int[2]) -> int[3][4]:
    assert is_intersection(grid, intersection)

    directions = [[-1, 0], [1, 0], [0, -1], [0, 1]]
    result = [[-1, -1, -1], [-1, -1, -1], [-1, -1, -1], [-1, -1, -1]]

    for i = 0; i < 4; i++:
        x = intersection[0]
        y = intersection[1]
        n = 0

        while True:
            if n == 0:
                dir = directions[i]
                nx = x + dir[0]
                ny = y + dir[1]
                if not grid->is_in_bounds([nx, ny]) or grid->get([nx, ny]) != '.':
                    break
            else:
                # Pick new direction. Do not go back to where we came from.
                # There cannot be multiple possible new directions, because that's an intersection.
                new_dir: int[2]* = NULL
                for k = 0; k < 4; k++:
                    d = &directions[k]
                    if (*d)[0] == -dir[0] and (*d)[1] == -dir[1]:
                        continue

                    nx = x + (*d)[0]
                    ny = y + (*d)[1]
                    if grid->is_in_bounds([nx, ny]) and grid->get([nx, ny]) == '.':
                        assert new_dir == NULL
                        new_dir = d

                if new_dir == NULL:
                    break
                dir = *new_dir

            x += dir[0]
            y += dir[1]
            n++

            if is_intersection(grid, [x, y]):
                result[i] = [x, y, n]
                break

    return result


def main() -> int:
    f = fopen("input", "r")
    assert f != NULL
    grid = read_grid_from_file(f)
    fclose(f)

    for ch = "<>^v"; *ch != '\0'; ch++:
        while grid.count(*ch) > 0:
            grid.set(grid.find_first(*ch), '.')

    assert starts_with(grid.data, "#.#####")

    intersections: int[2]* = NULL
    nintersections = 0

    todo: int[2]* = malloc(sizeof(todo[0]))
    todo_len = 1
    todo[0] = [1, 0]

    graph = fopen("/tmp/aoc23-graph.txt", "w")
    assert graph != NULL

    fprintf(graph, "digraph G {\n")

    while todo_len > 0:
        p = todo[--todo_len]

        already_found = False
        for i = 0; i < nintersections; i++:
            if intersections[i][0] == p[0] and intersections[i][1] == p[1]:
                already_found = True
                break
        if already_found:
            continue

        fprintf(graph, "    node%d [label=\"(%d,%d)\"]\n", nintersections, p[0], p[1])

        intersections = realloc(intersections, sizeof(intersections[0]) * (nintersections + 1))
        intersections[nintersections++] = p

        todo = realloc(todo, sizeof(todo[0]) * (todo_len + 4))
        neighbors = find_connected_intersections(&grid, p)
        for i = 0; i < 4; i++:
            if neighbors[i][0] != -1:
                todo[todo_len++] = [neighbors[i][0], neighbors[i][1]]

    free(todo)

    for i = 0; i < nintersections; i++:
        for k = 0; k < i; k++:
            neighbors = find_connected_intersections(&grid, intersections[i])
            for m = 0; m < 4; m++:
                if neighbors[m][0] == intersections[k][0] and neighbors[m][1] == intersections[k][1]:
                    distance = neighbors[m][2]
                    fprintf(graph, "    node%d -> node%d [label=\"%d\", dir=none]\n", i, k, distance)
                    break

    fprintf(graph, "}\n")

    fclose(graph)
    system("dot -T png /tmp/aoc23-graph.txt -o /tmp/aoc23-graph.png && open /tmp/aoc23-graph.png")

    free(intersections)
    free(grid.data)
    return 0
