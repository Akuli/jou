import "stdlib/io.jou"
import "stdlib/str.jou"
import "stdlib/ascii.jou"
import "stdlib/mem.jou"


class List:
    ptr: long*
    len: int
    alloc: int

    def end(self) -> long*:
        return &self->ptr[self->len]

    def append(self, n: long) -> void:
        if self->alloc == self->len:
            if self->alloc == 0:
                self->alloc = 4
            else:
                self->alloc *= 2

            self->ptr = realloc(self->ptr, self->alloc * sizeof(self->ptr[0]))
            assert self->ptr != NULL

        self->ptr[self->len++] = n

    def extend(self, other: List) -> void:
        for v = other.ptr; v < other.end(); v++:
            self->append(*v)

    def remove_dupes(self) -> void:
        for i = self->len-1; i >= 0; i--:
            # delete i'th number if it occurs after index i
            for k = i+1; k < self->len; k++:
                if self->ptr[i] == self->ptr[k]:
                    self->ptr[i] = self->ptr[--self->len]
                    break


class Map:
    triples: long[3][50]
    ntriples: int

    def add_triple(self, s: byte*) -> void:
        a: long
        b: long
        c: long
        assert sscanf(s, "%lld %lld %lld", &a, &b, &c) == 3

        assert self->ntriples < sizeof(self->triples)/sizeof(self->triples[0])
        self->triples[self->ntriples++] = [a, b, c]

    def get_input_range_starts(self) -> List:
        result = List{}
        for i = 0; i < self->ntriples; i++:
            result.append(self->triples[i][1])
        return result

    def map_number(self, n: long) -> long:
        for i = 0; i < self->ntriples; i++:
            dest_start = self->triples[i][0]
            source_start = self->triples[i][1]
            range_length = self->triples[i][2]
            if source_start <= n and n < source_start+range_length:
                return n - source_start + dest_start
        return n

    # Find all numbers n for which map_number(n) == output.
    def inverse_image(self, output: long) -> List:
        result = List{}

        for i = 0; i < self->ntriples; i++:
            dest_start = self->triples[i][0]
            source_start = self->triples[i][1]
            range_length = self->triples[i][2]

            # Solve equation:   output = n - source_start + dest_start
            n = output + source_start - dest_start
            if self->map_number(n) == output:
                result.append(n)

        if self->map_number(output) == output:
            result.append(output)

        return result


class Range:
    start: long
    end: long

    def contains(self, n: long) -> bool:
        return self->start <= n and n < self->end


class Input:
    seed_ranges: Range[15]
    n_seed_ranges: int

    maps: Map[10]
    nmaps: int

    def add_seeds(self, line: byte*) -> void:
        assert self->n_seed_ranges == 0
        assert starts_with(line, "seeds: ")
        line = &line[6]

        words = split_by_ascii_whitespace(line)
        for i = 0; words[i] != NULL and words[i+1] != NULL; i += 2:
            assert i/2 < sizeof(self->seed_ranges) / sizeof(self->seed_ranges[0])
            self->seed_ranges[i/2] = Range{
                start = atoll(words[i]),
                end = atoll(words[i]) + atoll(words[i+1]),
            }
            self->n_seed_ranges++
        free(words)


def main() -> int:
    input: Input* = calloc(1, sizeof(*input))

    f = fopen("input.txt", "r")
    assert f != NULL

    line: byte[1000]

    # Special-case first line
    assert fgets(line, sizeof(line) as int, f) != NULL
    input->add_seeds(line)

    while fgets(line, sizeof(line) as int, f) != NULL:
        if strstr(line, "map") != NULL:
            # start of new map
            assert input->nmaps < sizeof(input->maps)/sizeof(input->maps[0])
            input->nmaps++
        elif is_ascii_digit(line[0]):
            # add numbers to existing map
            assert input->nmaps > 0
            input->maps[input->nmaps - 1].add_triple(line)

    interesting_inputs = List{}
    for i = 0; i < input->nmaps; i++:
        # We get small values whenever the i'th map sees a start of its range.
        values = input->maps[i].get_input_range_starts()

        # Back through all previous maps.
        for k = i-1; k >= 0; k--:
            values2 = List{}
            for v = values.ptr; v < values.end(); v++:
                values3 = input->maps[k].inverse_image(*v)
                values2.extend(values3)
                free(values3.ptr)
            free(values.ptr)
            values = values2

        interesting_inputs.extend(values)
        free(values.ptr)

    # Let's also try start of each seed range
    for i = 0; i < input->n_seed_ranges; i++:
        interesting_inputs.append(input->seed_ranges[i].start)

    smallest = -1 as long
    for p = interesting_inputs.ptr; p < interesting_inputs.end(); p++:
        # Check if this is in any seed range
        found = False
        for i = 0; i < input->n_seed_ranges; i++:
            if input->seed_ranges[i].contains(*p):
                found = True
                break
        if found:
            # We have a valid seed. Let's check if we get smaller value than before.
            n = *p
            for k = 0; k < input->nmaps; k++:
                n = input->maps[k].map_number(n)
            if smallest == -1 or n < smallest:
                smallest = n

    printf("%lld\n", smallest)  # Output: 46
    return 0
