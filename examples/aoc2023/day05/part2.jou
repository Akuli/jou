import "stdlib/assert.jou"
import "stdlib/io.jou"
import "stdlib/list.jou"
import "stdlib/str.jou"
import "stdlib/ascii.jou"
import "stdlib/mem.jou"


class Map:
    triples: int64[3][50]
    ntriples: int

    def add_triple(self, s: byte*) -> None:
        a, b, c: int64
        assert sscanf(s, "%lld %lld %lld", &a, &b, &c) == 3

        assert self.ntriples < array_count(self.triples)
        self.triples[self.ntriples++] = [a, b, c]

    def get_input_range_starts(self) -> List[int64]:
        result = List[int64]{}
        for i = 0; i < self.ntriples; i++:
            result.append(self.triples[i][1])
        return result

    def map_number(self, n: int64) -> int64:
        for i = 0; i < self.ntriples; i++:
            dest_start = self.triples[i][0]
            source_start = self.triples[i][1]
            range_length = self.triples[i][2]
            if source_start <= n and n < source_start+range_length:
                return n - source_start + dest_start
        return n

    # Find all numbers n for which map_number(n) == output.
    def inverse_image(self, output: int64) -> List[int64]:
        result = List[int64]{}

        for i = 0; i < self.ntriples; i++:
            dest_start = self.triples[i][0]
            source_start = self.triples[i][1]

            # Solve equation:   output = n - source_start + dest_start
            n = output + source_start - dest_start
            if self.map_number(n) == output:
                result.append(n)

        if self.map_number(output) == output:
            result.append(output)

        return result

    # Find all numbers n for which map_number(n) is in a list of outputs.
    def inverse_image_of_list(self, outputs: List[int64]) -> List[int64]:
        result = List[int64]{}
        for p = outputs.ptr; p < outputs.end(); p++:
            to_add = self.inverse_image(*p)
            result.extend(to_add)
            free(to_add.ptr)
        return result


class Range:
    start: int64
    end: int64

    def contains(self, n: int64) -> bool:
        return self.start <= n and n < self.end


class Input:
    seed_ranges: Range[15]
    n_seed_ranges: int

    maps: Map[10]
    nmaps: int

    def add_seeds(self, line: byte*) -> None:
        assert self.n_seed_ranges == 0
        assert starts_with(line, "seeds: ")
        line = &line[6]

        words = split_by_ascii_whitespace(line)
        for i = 0; i+1 < words.len; i += 2:
            assert i/2 < array_count(self.seed_ranges)
            self.seed_ranges[i/2] = Range{
                start = atoll(words.ptr[i]),
                end = atoll(words.ptr[i]) + atoll(words.ptr[i+1]),
            }
            self.n_seed_ranges++
        free(words.ptr)

    def is_valid_seed(self, n: int64) -> bool:
        for i = 0; i < self.n_seed_ranges; i++:
            if self.seed_ranges[i].contains(n):
                return True
        return False


def main() -> int:
    input: Input* = calloc(1, sizeof(*input))

    f = fopen("sampleinput.txt", "r")
    assert f != NULL

    line: byte[1000]

    # Special-case first line
    assert fgets(line, sizeof(line) as int, f) != NULL
    input.add_seeds(line)

    while fgets(line, sizeof(line) as int, f) != NULL:
        if strstr(line, "map") != NULL:
            # start of new map
            assert input.nmaps < array_count(input.maps)
            input.nmaps++
        elif is_ascii_digit(line[0]):
            # add numbers to existing map
            assert input.nmaps > 0
            input.maps[input.nmaps - 1].add_triple(line)

    fclose(f)

    interesting_inputs = List[int64]{}
    for i = 0; i < input.nmaps; i++:
        # We get small values whenever the i'th map sees a start of its range.
        values = input.maps[i].get_input_range_starts()

        # Back the list of numbers through all previous maps.
        for k = i-1; k >= 0; k--:
            values2 = input.maps[k].inverse_image_of_list(values)
            free(values.ptr)
            values = values2

        interesting_inputs.extend(values)
        free(values.ptr)

    # Let's also try start of each seed range
    for i = 0; i < input.n_seed_ranges; i++:
        interesting_inputs.append(input.seed_ranges[i].start)

    smallest = -1 as int64
    for p = interesting_inputs.ptr; p < interesting_inputs.end(); p++:
        if input.is_valid_seed(*p):
            n = *p
            for i = 0; i < input.nmaps; i++:
                n = input.maps[i].map_number(n)
            if smallest == -1 or n < smallest:
                smallest = n

    free(interesting_inputs.ptr)
    free(input)

    printf("%lld\n", smallest)  # Output: 46
    return 0
