import "stdlib/ascii.jou"
import "stdlib/list.jou"
import "stdlib/io.jou"
import "stdlib/str.jou"
import "stdlib/mem.jou"


class File:
    name: byte[100]  # relative to containing directory, no "/" characters
    size: long

    def print(self, depth: int) -> None:
        printf("%*s%s (file, size=%lld)\n", 2*depth, "", self->name, self->size)


class Directory:
    name: byte[100]  # relative to containing directory, no "/" characters
    files: List[File]
    subdirs: List[Directory]

    def print(self, depth: int) -> None:
        printf("%*s%s (dir)\n", 2*depth, "", self->name)
        for d = self->subdirs.ptr; d < self->subdirs.end(); d++:
            d->print(depth+1)
        for f = self->files.ptr; f < self->files.end(); f++:
            f->print(depth+1)

    def total_size(self) -> long:
        result = 0L
        for d = self->subdirs.ptr; d < self->subdirs.end(); d++:
            result += d->total_size()
        for f = self->files.ptr; f < self->files.end(); f++:
            result += f->size
        return result

    def sum_of_total_sizes_less_than_100k(self) -> long:
        result = 0L
        if self->total_size() < 100_000:
            result += self->total_size()
        for d = self->subdirs.ptr; d < self->subdirs.end(); d++:
            result += d->sum_of_total_sizes_less_than_100k()
        return result

    def free(self) -> None:
        for d = self->subdirs.ptr; d < self->subdirs.end(); d++:
            d->free()
        free(self->subdirs.ptr)
        free(self->files.ptr)


def main() -> int:
    f = fopen("sampleinput.txt", "r")
    assert f != NULL

    root = Directory{name="root"}
    dirs = List[Directory*]{}  # topmost is current working directory

    line: byte[100]
    while fgets(line, sizeof(line) as int, f) != NULL:
        trim_ascii_whitespace(line)

        if strcmp(line, "$ cd /") == 0:
            dirs.len = 0
            dirs.append(&root)
        elif strcmp(line, "$ ls") == 0:
            # directory listing follows, will be processed when it comes
            pass
        elif strcmp(line, "$ cd ..") == 0:
            dirs.pop()
        elif starts_with(line, "$ cd "):
            cwd = dirs.end()[-1]
            found = False
            for d = cwd->subdirs.ptr; d < cwd->subdirs.end(); d++:
                if strcmp(d->name, &line[5]) == 0:
                    dirs.append(d)
                    found = True
                    break
            assert found
        elif starts_with(line, "dir "):
            subdir = Directory{}
            subdir_name = &line[4]
            assert strlen(subdir_name) < sizeof(subdir.name)
            strcpy(subdir.name, subdir_name)
            dirs.end()[-1]->subdirs.append(subdir)
        else:
            # file with size
            filename = strstr(line, " ")
            assert filename != NULL
            filename++  # skip space
            file = File{size = atoll(line)}
            assert strlen(filename) < sizeof(file.name)
            strcpy(file.name, filename)
            dirs.end()[-1]->files.append(file)

    free(dirs.ptr)
    fclose(f)

    # Output: root (dir)
    # Output:   a (dir)
    # Output:     e (dir)
    # Output:       i (file, size=584)
    # Output:     f (file, size=29116)
    # Output:     g (file, size=2557)
    # Output:     h.lst (file, size=62596)
    # Output:   b.txt (file, size=14848514)
    # Output:   c.dat (file, size=8504156)
    # Output:   d (dir)
    # Output:     j (file, size=4060174)
    # Output:     d.log (file, size=8033020)
    # Output:     d.ext (file, size=5626152)
    # Output:     k (file, size=7214296)
    root.print(0)

    # Output: 95437
    printf("%lld\n", root.sum_of_total_sizes_less_than_100k())

    root.free()
    return 0
