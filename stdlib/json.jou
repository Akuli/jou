import "stdlib/ascii.jou"
import "stdlib/assert.jou"
import "stdlib/list.jou"
import "stdlib/mem.jou"
import "stdlib/str.jou"
import "stdlib/utf8.jou"


# TODO: make this configurable?
const MAX_DEPTH: int = 64

const BUILDER_FLAG_EMPTY: uint8 = 0b01
const BUILDER_FLAG_OBJECT: uint8 = 0b10


@public
class JSONBuilder:
    pretty_print_indent: int  # 0 means as concise as possible (not pretty-print)
    output: List[byte]  # You must free(json_builder.output.ptr) or call finish()

    # Internals that you don't need to care about as a user
    stack: uint8[MAX_DEPTH]  # contains bitwise ORs of the flags
    depth: int               # number of items on stack
    waiting_for_value_after_a_key: bool

    def new_line(self) -> None:
        if self.pretty_print_indent != 0:
            self.output.append('\n')
            n = self.pretty_print_indent * self.depth
            while n --> 0:
                self.output.append(' ')

    def before_a_value(self) -> None:
        if self.depth == 0:
            # This assert fails if you try to create multiple top-level values.
            # If you want to create multiple values, you must use array or object.
            assert self.output.len == 0
            return

        if self.waiting_for_value_after_a_key:
            self.waiting_for_value_after_a_key = False
            return

        assert 0 < self.depth and self.depth <= array_count(self.stack)
        flags = &self.stack[self.depth - 1]
        if *flags & BUILDER_FLAG_EMPTY == 0:
            self.output.append(',')
        *flags &= ~BUILDER_FLAG_EMPTY

        self.new_line()

    @public
    def array(self) -> None:
        self.before_a_value()
        assert self.depth < array_count(self.stack)
        self.stack[self.depth++] = BUILDER_FLAG_EMPTY
        self.output.append('[')

    @public
    def object(self) -> None:
        self.before_a_value()
        assert self.depth < array_count(self.stack)
        self.stack[self.depth++] = BUILDER_FLAG_EMPTY | BUILDER_FLAG_OBJECT
        self.output.append('{')

    @public
    def key(self, key: byte*) -> None:
        assert key != NULL

        # This can only be used inside an object
        assert self.depth > 0
        assert self.stack[self.depth - 1] & BUILDER_FLAG_OBJECT != 0

        # You cannot add multiple keys without putting values in between
        assert not self.waiting_for_value_after_a_key

        self.string(key)
        self.output.append(':')
        if self.pretty_print_indent != 0:
            self.output.append(' ')
        self.waiting_for_value_after_a_key = True

    @public
    def end_array(self) -> None:
        assert not self.waiting_for_value_after_a_key
        assert self.depth > 0

        flags = self.stack[--self.depth]
        assert flags & BUILDER_FLAG_OBJECT == 0
        if flags & BUILDER_FLAG_EMPTY == 0:
            self.new_line()

        self.output.append(']')

    @public
    def end_object(self) -> None:
        assert not self.waiting_for_value_after_a_key
        assert self.depth > 0

        flags = self.stack[--self.depth]
        assert flags & BUILDER_FLAG_OBJECT != 0
        if flags & BUILDER_FLAG_EMPTY == 0:
            self.new_line()

        self.output.append('}')

    @public
    def boolean(self, b: bool) -> None:
        self.before_a_value()
        if b:
            self.output.extend_from_ptr("true", 4)
        else:
            self.output.extend_from_ptr("false", 5)

    @public
    def string(self, s: byte*) -> None:
        if s == NULL:
            self.null()
            return

        self.before_a_value()
        self.output.append('"')

        while *s != '\0':
            match *s:
                case '\n':
                    self.output.extend_from_ptr("\\n", 2)
                    s++
                case '\t':
                    self.output.extend_from_ptr("\\t", 2)
                    s++
                case '\r':
                    self.output.extend_from_ptr("\\r", 2)
                    s++
                case '"' | '\\':
                    self.output.append('\\')
                    self.output.append(*s++)
                case _:
                    if is_ascii_printable(*s):
                        self.output.append(*s++)
                    elif *s < 128:
                        # unprintable ASCII character, do these carefully
                        buf: byte[16]
                        sprintf(buf, "\\u00%02x", *s++)
                        self.output.extend_from_ptr(buf, strlen(buf))
                    elif starts_with(s, "\xe2\x80\xa8"):
                        # Unicode character U+2028, placing it directly into JSON may cause problems
                        self.output.extend_from_ptr("\\u2028", 6)
                        s = &s[3]
                    elif starts_with(s, "\xe2\x80\xa9"):
                        # Unicode character U+2029, placing it directly into JSON may cause problems
                        self.output.extend_from_ptr("\\u2029", 6)
                        s = &s[3]
                    else:
                        # part of a non-ASCII character in UTF-8, output it as is
                        self.output.append(*s++)
        self.output.append('"')

    @public
    def null(self) -> None:
        self.before_a_value()
        self.output.extend_from_ptr("null", 4)

    @public
    def number(self, n: double) -> None:
        self.before_a_value()

        # TODO: Jou doesn't have isnan/isinf yet
        #if isnan(x): --> emit "NaN"
        #if isinf(x): --> emit "Infinity" or "-Infinity"

        # AI says that 17 significant digits is always enough.
        buf: byte[64]
        snprintf(buf, sizeof(buf), "%.17g", n)

        # TODO: A hack for fi_FI.UTF-8 locale which produces commas instead of
        #       dots. Ideally we would solve this problem properly...
        for p = &buf[0]; *p != '\0'; p++:
            if *p == ',':
                *p = '.'

        # Handle NaN and infinities. They are technically not valid JSON, but
        # they are often used. For example, Python's JSON module produces them
        # by default.
        #
        # TODO: This is a bit hacky because Jou doesn't have isnan/isinf functions yet.
        match buf with strcmp:
            case "nan" | "Nan" | "NaN" | "NAN":
                buf = "NaN"
            case "inf" | "Inf" | "INF" | "infinity" | "Infinity" | "INFINITY":
                buf = "Infinity"
            case "-inf" | "-Inf" | "-INF" | "-infinity" | "-Infinity" | "-INFINITY":
                buf = "-Infinity"

        self.output.extend_from_ptr(buf, strlen(buf))

    # Return value must be free()'d
    @public
    def finish(self) -> byte*:
        assert self.depth == 0  # If this fails, you forgot to call end()
        self.output.append('\0')
        return self.output.ptr


# Array consists of:
#   '['
#   whitespace
#   ']' or:
#       value (including whitespace before and after)
#       ']' or:
#           ','
#           value (including whitespace before and after)
#           ']' or:
#               ...
def skip_array(s: byte*, depth: int) -> byte*:
    if s == NULL or depth > MAX_DEPTH:
        return NULL

    if *s++ != '[':
        return NULL

    while is_json_whitespace(*s):
        s++

    if *s == ']':
        s++
        return s

    while True:
        s = skip_value(s, depth + 1)  # skips leading and trailing whitespace
        if s == NULL:
            return NULL

        match *s++:
            case ',':
                pass
            case ']':
                return s
            case _:
                return NULL


@public
def json_array_first(s: byte*) -> byte*:
    if s == NULL:
        return NULL

    while is_json_whitespace(*s):
        s++
    if *s++ != '[':
        return NULL

    while is_json_whitespace(*s):
        s++
    return NULL if *s == ']' or *s == '\0' else s


@public
def json_array_next(s: byte*) -> byte*:
    s = skip_value(s, 0)
    if s == NULL or *s++ != ',':
        return NULL
    while is_json_whitespace(*s):
        s++
    return s


# Object consists of:
#   '{'
#   whitespace
#   '}' or:
#       string (the key)
#       whitespace
#       ':'
#       value (including whitespace before and after)
#       '}' or:
#           ','
#           whitespace
#           string (the key) and repeat from there
def skip_object(s: byte*, depth: int) -> byte*:
    if s == NULL or depth > MAX_DEPTH:
        return NULL

    if *s++ != '{':
        return NULL

    while is_json_whitespace(*s):
        s++

    if *s == '}':
        s++
        return s

    while True:
        s = skip_string(s)
        if s == NULL:
            return NULL

        while is_json_whitespace(*s):
            s++

        if *s++ != ':':
            return NULL

        s = skip_value(s, depth + 1)
        if s == NULL:
            return NULL

        match *s++:
            case '}':
                return s
            case ',':
                while is_json_whitespace(*s):
                    s++
            case _:
                return NULL


@public
def json_object_first(s: byte*) -> byte*:
    if s == NULL:
        return NULL

    while is_json_whitespace(*s):
        s++
    if *s++ != '{':
        return NULL

    while is_json_whitespace(*s):
        s++
    return s if *s == '"' else NULL


@public
def json_object_value(s: byte*) -> byte*:
    s = skip_string(s)
    if s == NULL:
        return NULL

    while is_json_whitespace(*s):
        s++

    if *s++ != ':':
        return NULL

    while is_json_whitespace(*s):
        s++
    return s


@public
def json_object_next(s: byte*) -> byte*:
    s = skip_value(json_object_value(s), 0)
    if s == NULL or *s++ != ',':
        return NULL
    while is_json_whitespace(*s):
        s++
    return s if *s == '"' else NULL


# Value consists of:
#   whitespace
#   string or number or object or array or true or false or null
#   whitespace
#
# The way how a value contains whitespace before and after it is IMO weird, but
# that's how the JSON spec at https://www.json.org/ does it.
def skip_value(s: byte*, depth: int) -> byte*:
    if s == NULL or depth > MAX_DEPTH:
        return NULL

    while is_json_whitespace(*s):
        s++

    match *s:
        case '"':
            s = skip_string(s)
        case '-' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | 'I' | 'N':
            s = skip_number(s)
        case '{':
            # This passes the depth through as is. Containers (object, array)
            # increment it for their subvalues.
            s = skip_object(s, depth)
        case '[':
            s = skip_array(s, depth)
        case 't':
            s = &s[4] if starts_with(s, "true") else NULL
        case 'f':
            s = &s[5] if starts_with(s, "false") else NULL
        case 'n':
            s = &s[4] if starts_with(s, "null") else NULL
        case _:
            s = NULL
    if s == NULL:
        return NULL

    while is_json_whitespace(*s):
        s++
    return s


# This is for the \u syntax inside strings.
def read_4_hex_digits(s: byte*) -> int:
    result = 0

    for i = 0; i < 4; i++:
        c = s[i]
        result <<= 4
        if '0' <= c and c <= '9':
            result |= c - '0'
        elif 'A' <= c and c <= 'F':
            result |= 10 + (c - 'A')
        elif 'a' <= c and c <= 'f':
            result |= 10 + (c - 'a')
        else:
            return -1

    return result


# String in JSON consists of:
#   '"'
#   zero or more of any of the following:
#       \"
#       \\
#       \/ (yes, forward slashes can be escaped in JSON)
#       \b
#       \f
#       \n
#       \r
#       \t
#       \u followed by 4 hex digits (specifies 16-bit value as in UTF-16)
#   '"'
#
# This function parses a string in JSON.
#
#   s: JSON
#   dest: String contents are written here, can be NULL to ignore the contents
#   dest_max: How many bytes to write to dest, does not '\0' terminate!
#
# Returns the JSON string s advanced just beyond the ending '"', or NULL if the
# given JSON is invalid.
def parse_string(s: byte*, dest: byte*, dest_max: int) -> byte*:
    if s == NULL or *s++ != '"':
        return NULL

    while True:
        match *s:
            case '\\':
                s++

                out_string: byte[5]
                match *s++:
                    case '"':
                        out_string = "\""
                    case '\\':
                        out_string = "\\"
                    case '/':
                        out_string = "/"
                    case 'b':
                        out_string = "\x08"  # Jou doesn't have \b escape
                    case 'f':
                        out_string = "\x0c"  # Jou doesn't have \f escape
                    case 'n':
                        out_string = "\n"
                    case 'r':
                        out_string = "\r"
                    case 't':
                        out_string = "\t"
                    case 'u':
                        # \uxxxx expects 4 hex characters
                        u1: int = read_4_hex_digits(s)
                        # \u0000 means JSON string contains a zero byte.
                        # TODO: test this
                        if u1 == -1:
                            return NULL
                        s = &s[4]

                        if 0xD800 <= u1 and u1 <= 0xDBFF:
                            # It is the first half of a surrogate pair. Let's
                            # get the second half too.
                            if not starts_with(s, "\\u"):
                                return NULL
                            s = &s[2]
                            u2: int = read_4_hex_digits(s)
                            if u2 == -1:
                                return NULL
                            s = &s[4]

                            if 0xDC00 <= u2 and u2 <= 0xDCFF:
                                # Surrogate pair is valid. Let's combine it
                                # into a UTF-8 character.
                                codepoint = ((u1 - 0xD800) << 10) | (u2 - 0xDC00)
                                codepoint += 0x10000
                                out_string = utf8_encode_char(codepoint as uint32)
                            else:
                                return NULL

                        else:
                            out_string = utf8_encode_char(u1 as uint32)
                    case _:
                        return NULL

                if out_string[0] == '\0':
                    # error detected in utf8_encode_char()
                    return NULL

                for i = 0; out_string[i] != '\0'; i++:
                    if dest != NULL and dest_max > 0:
                        *dest++ = out_string[i]
                        dest_max--

            case '"':  # end of string
                s++
                return s

            case _:
                if *s < 0x20:
                    # Weird ASCII characters are banned
                    return NULL

                p = s
                if utf8_decode_char(&s) <= 0:
                    # Invalid UTF-8
                    return NULL

                # A character is UTF-8 encoded in the JSON, output it as is
                while dest != NULL and dest_max > 0 and p < s:
                    *dest++ = *p++
                    dest_max--


@public
def string_from_json(json: byte*, out: byte*, out_size: int) -> bool:
    if json == NULL or out_size <= 0:
        return False

    while is_json_whitespace(*json):
        json++
    memset(out, 0, out_size)
    return parse_string(json, out, out_size - 1) != NULL


# Part of JSON parsing and validating. Returns NULL if json is invalid.
def skip_string(s: byte*) -> byte*:
    return parse_string(s, NULL, 0)


# Part of JSON parsing and validating. Returns NULL if json is invalid.
#
# Number consists of:
#   'NaN' or:
#       optional: '-'
#       'Infinity' or:
#           '0' or:
#               digit 1-9
#               digits 0-9 (zero or more)
#           optional:
#               '.'
#               digits 0-9 (at least one)
#           optional:
#               'E' or 'e'
#               optional: '+' or '-'
#               digits 0-9 (at least one)
#
# Technically NaN and Infinity are not allowed, but they are widely used
# extensions and e.g. Python supports them by default.
def skip_number(s: byte*) -> byte*:
    if s == NULL:
        return NULL

    if starts_with(s, "NaN"):
        return &s[3]

    if *s == '-':
        s++

    if starts_with(s, "Infinity"):
        return &s[8]

    if *s == '0':
        s++
        # No need to return NULL here. For input like "0123", this function
        # consumes "0" and something else fails later.
    elif is_ascii_digit(*s):
        while is_ascii_digit(*s):
            s++
    else:
        return NULL

    if *s == '.':
        s++
        if not is_ascii_digit(*s):
            return NULL
        while is_ascii_digit(*s):
            s++

    if *s == 'E' or *s == 'e':
        s++
        if *s == '+' or *s == '-':
            s++
        if not is_ascii_digit(*s):
            return NULL
        while is_ascii_digit(*s):
            s++

    return s


@public
def json_is_true(json: byte*) -> bool:
    if json == NULL:
        return False
    while is_json_whitespace(*json):
        json++
    return starts_with(json, "true")

@public
def json_is_false(json: byte*) -> bool:
    if json == NULL:
        return False
    while is_json_whitespace(*json):
        json++
    return starts_with(json, "false")

@public
def json_is_null(json: byte*) -> bool:
    if json == NULL:
        return False
    while is_json_whitespace(*json):
        json++
    return starts_with(json, "null")


# Not to be confused with is_ascii_whitespace() which allows more!
def is_json_whitespace(b: byte) -> bool:
    return b == ' ' or b == '\t' or b == '\n' or b == '\r'


@public
def is_valid_json(s: byte*) -> bool:
    s = skip_value(s, 0)
    return s != NULL and *s == '\0'
