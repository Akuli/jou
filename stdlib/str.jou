# Functions for working with strings (byte* pointers).

# Parsing. See also scanf() in io.jou.
declare sscanf(s: byte*, pattern: byte*, ...) -> int  # Parse a string. See sscanf() in io.jou.

# Formatting. See also printf() in io.jou.
#   sprintf() assumes that the result fits in dest (UB happens, if it overflows)
#   snprintf() truncates the string so that the string and its '\0' fit into a total of n bytes of space
declare sprintf(dest: byte*, pattern: byte*, ...) -> int
declare snprintf(dest: byte*, n: size_t, pattern: byte*, ...) -> int

# Find a substring. Return a pointer to the occurrence in haystack, or NULL if not found.
declare strstr(haystack: byte*, needle: byte*) -> byte*

# Similar to strstr(), but searches for a single byte rather than a substring.
declare strchr(haystack: byte*, needle: byte) -> byte*

# Calculate the length of a string in bytes. Note that strlen("รถ") == 2, for example.
declare strlen(s: byte*) -> size_t

# Compare the strings. Return 0 for equal, or nonzero for not equal.
declare strcmp(s1: byte*, s2: byte*) -> int

# Similar to strcmp(), but imagines the strings are at most n bytes long.
# In other words, if s1 or s2 is more than n bytes long, the rest is not compared.
declare strncmp(s1: byte*, s2: byte*, n: size_t) -> int

# Returns true if the string s starts with the given prefix.
def starts_with(s: byte*, prefix: byte*) -> bool:
    return strncmp(s, prefix, strlen(prefix)) == 0

# Returns true if the string s ends with the given prefix.
def ends_with(s: byte*, suffix: byte*) -> bool:
    offset = strlen(s) - strlen(suffix)
    return offset >= 0 and strcmp(&s[offset], suffix) == 0

# Return how many bytes at start of s appear in the accept string.
declare strspn(s: byte*, accept: byte*) -> size_t

# Copy a string. Assumes it fits. Returned value is dest.
declare strcpy(dest: byte*, source: byte*) -> byte*

# Append source to end of dest. Assumes it fits. Returned value is dest.
# Can be slow if dest is long, because it needs to find the end of dest.
declare strcat(dest: byte*, source: byte*) -> byte*

# Return a newly allocated (as in malloc()) copy of the string.
declare strdup(s: byte*) -> byte*
