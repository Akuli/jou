# TODO: delete this file, merge into others

import "stdlib/str.jou"
import "stdlib/io.jou"

import "./utils.jou"
import "./types.jou"


class CommandLineArgs:
    argv0: byte*  # Program name
    verbosity: int  # How much debug/progress info to print, how many times -v/--verbose passed
    valgrind: bool  # true --> Use valgrind when runnning user's jou program
    tokenize_only: bool  # If true, tokenize the file passed on command line and don't actually compile anything
    parse_only: bool  # If true, parse the file passed on command line and don't actually compile anything
    optlevel: int  # Optimization level (0 don't optimize, 3 optimize a lot)
    infile: byte*  # The "main" Jou file (can import other files)
    outfile: byte*  # If not NULL, where to output executable
    linker_flags: byte*  # String that is appended to linking command

# Command-line arguments are a global variable because I like it.
global command_line_args: CommandLineArgs

# Constants can appear in AST and also compilation steps after AST.
enum ConstantKind:
    EnumMember
    Integer
    Float
    Double
    String
    Null
    Bool

class IntegerConstant:
    size_in_bits: int
    is_signed: bool
    value: long

class EnumMemberConstant:
    enumtype: Type*
    memberidx: int

class Constant:
    kind: ConstantKind
    union:
        integer: IntegerConstant
        str: byte*
        # TODO: rename double_or_float_text --> float_or_double_text to be consistent with AST
        double_or_float_text: byte[100]  # convenient because LLVM wants a string anyway
        boolean: bool
        enum_member: EnumMemberConstant

    def print(self) -> None:
        if self->kind == ConstantKind::EnumMember:
            printf("enum member %d of %s", self->enum_member.memberidx, self->enum_member.enumtype->name)
        elif self->kind == ConstantKind::Bool:
            if self->boolean:
                printf("True")
            else:
                printf("False")
        elif self->kind == ConstantKind::Float:
            printf("float %s", self->double_or_float_text)
        elif self->kind == ConstantKind::Double:
            printf("double %s", self->double_or_float_text)
        elif self->kind == ConstantKind::Integer:
            if self->integer.is_signed:
                signed_or_unsigned = "signed"
            else:
                signed_or_unsigned = "unsigned"
            printf(
                "%lld (%d-bit %s)",
                self->integer.value,
                self->integer.size_in_bits,
                signed_or_unsigned,
            )
        elif self->kind == ConstantKind::Null:
            printf("NULL")
        elif self->kind == ConstantKind::String:
            printf("string ")
            print_string(self->str, strlen(self->str))
            printf("\n")
        else:
            assert False

    def get_type(self) -> Type*:
        if self->kind == ConstantKind::EnumMember:
            return self->enum_member.enumtype
        if self->kind == ConstantKind::Null:
            return voidPtrType
        if self->kind == ConstantKind::Double:
            return doubleType
        if self->kind == ConstantKind::Float:
            return floatType
        if self->kind == ConstantKind::Bool:
            return boolType
        if self->kind == ConstantKind::String:
            return byteType->pointer_type()
        if self->kind == ConstantKind::Integer:
            return get_integer_type(self->integer.size_in_bits, self->integer.is_signed)
        assert False

    def copy(self: Constant) -> Constant:
        if self.kind == ConstantKind::String:
            self.str = strdup(self.str)
            assert self.str != NULL
        return self


def int_constant(type: Type*, value: long) -> Constant:
    assert type->is_integer_type()
    return Constant{
        kind = ConstantKind::Integer,
        integer = IntegerConstant{
            size_in_bits = type->size_in_bits,
            is_signed = type->kind == TypeKind::SignedInteger,
            value = value
        }
    }
