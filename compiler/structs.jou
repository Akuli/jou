# TODO: delete this file, merge into others

import "stdlib/str.jou"
import "stdlib/math.jou"
import "stdlib/io.jou"

import "./ast.jou"
import "./types.jou"
import "./errors_and_warnings.jou"

class CommandLineArgs:
    argv0: byte*  # Program name
    verbosity: int  # How much debug/progress info to print, how many times -v/--verbose passed
    valgrind: bool  # true --> Use valgrind when runnning user's jou program
    tokenize_only: bool  # If true, tokenize the file passed on command line and don't actually compile anything
    parse_only: bool  # If true, parse the file passed on command line and don't actually compile anything
    optlevel: int  # Optimization level (0 don't optimize, 3 optimize a lot)
    infile: byte*  # The "main" Jou file (can import other files)
    outfile: byte*  # If not NULL, where to output executable
    linker_flags: byte*  # String that is appended to linking command

# Command-line arguments are a global variable because I like it.
global command_line_args: CommandLineArgs

# Constants can appear in AST and also compilation steps after AST.
enum ConstantKind:
    EnumMember
    Integer
    Float
    Double
    String
    Null
    Bool

class IntegerConstant:
    size_in_bits: int
    is_signed: bool
    value: long

class EnumMemberConstant:
    enumtype: Type*
    memberidx: int

class Constant:
    kind: ConstantKind
    union:
        integer: IntegerConstant
        str: byte*
        # TODO: rename double_or_float_text --> float_or_double_text to be consistent with AST
        double_or_float_text: byte[100]  # convenient because LLVM wants a string anyway
        boolean: bool
        enum_member: EnumMemberConstant

def copy_constant(c: Constant) -> Constant:
    if c.kind == ConstantKind::String:
        c.str = strdup(c.str)
        assert c.str != NULL
    return c

def int_constant(type: Type*, value: long) -> Constant:
    assert is_integer_type(type)
    return Constant{
        kind = ConstantKind::Integer,
        integer = IntegerConstant{
            size_in_bits = type->size_in_bits,
            is_signed = type->kind == TypeKind::SignedInteger,
            value = value
        }
    }

class Signature:
    name: byte[100]  # Function or method name. For methods it does not include the name of the class.
    nargs: int
    argtypes: Type**
    argnames: byte[100]*
    takes_varargs: bool  # true for functions like printf()
    # TODO: rename to return_type
    returntype: Type*    # NULL, if does not return a value
    is_noreturn: bool
    # TODO: rename to return_type_location
    returntype_location: Location  # meaningful even if returntype is NULL


class GlobalVariable:
    name: byte[100]  # Same as in user's code, never empty
    type: Type*
    defined_in_current_file: bool  # not declare-only (e.g. stdout) or imported
    usedptr: bool*  # If non-NULL, set to true when the variable is used. This is how we detect unused imports.


class LocalVariable:
    id: int  # Unique, but you can also compare pointers to LocalVariable.
    name: byte[100]  # Same name as in user's code, empty for temporary variables created by compiler
    type: Type*
    is_argument: bool    # First n variables are always the arguments

    def print_to_width(self, width: int) -> None:
        if self->name[0] != '\0':
            printf("%-*s", width, self->name)
        else:
            printf("$%-*d", max(width-1, 0), self->id)

    def print(self) -> None:
        self->print_to_width(0)


class ExpressionTypes:
    expr: AstExpression*  # not owned
    type: Type*
    implicit_cast_type: Type*  # NULL for no implicit cast

    # Flags to indicate whether special kinds of implicit casts happened
    implicit_array_to_pointer_cast: bool    # Foo[N] to Foo*
    implicit_string_to_array_cast: bool     # "..." to byte[N]

enum ExportSymbolKind:
    Function
    Type
    GlobalVar

class ExportSymbol:
    kind: ExportSymbolKind
    name: byte[100]  # TODO: maybe this should be 200 because it can be ClassName.method_name? or something else?
    union:
        funcsignature: Signature
        type: Type*  # ExportSymbolKind::Type and ExportSymbolKind::GlobalVar

# Type information about a function or method defined in the current file.
class FunctionOrMethodTypes:
    signature: Signature
    expr_types: ExpressionTypes**
    n_expr_types: int
    locals: LocalVariable**
    nlocals: int

class TypeAndUsedPtr:
    type: Type*
    usedptr: bool*

class SignatureAndUsedPtr:
    signature: Signature
    usedptr: bool*

# Type information about a file.
class FileTypes:
    current_fom_types: FunctionOrMethodTypes*  # conceptually this is internal to typecheck.c
    fomtypes: FunctionOrMethodTypes*
    nfomtypes: int
    globals: GlobalVariable*
    nglobals: int
    owned_types: Type**  # These will be freed later
    n_owned_types: int
    types: TypeAndUsedPtr*
    ntypes: int
    functions: SignatureAndUsedPtr*
    nfunctions: int
