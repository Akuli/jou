# This file defines classes that hold type information in the AST.
#
# These are included in the AST, but they are not set when the AST is
# created (parsing). Instead, they are filled in later during type checking.
# Previously I passed around the results of type checking with return values,
# but it was not as convenient as this is.

import "stdlib/assert.jou"
import "stdlib/str.jou"
import "stdlib/list.jou"
import "stdlib/mem.jou"

import "./types.jou"


@public
class ExpressionTypes:
    # Type of value that the expression evaluates to, before implicit casts are applied.
    # This is NULL before type checking, and if the expression  calling '-> None' function/method.
    orig_type: Type*

    # Type after applying implicit cast, if any. If there's no implicit cast, same as original_type.
    # This is NULL before type checking, and if the expression  calling '-> None' function/method.
    implicit_cast_type: Type*

    # Flags to indicate whether special kinds of implicit casts happened
    implicit_array_to_pointer_cast: bool    # Foo[N] to Foo*


@public
class LocalVariable:
    name: byte[100]  # Same name as in user's code, empty for temporary variables created by compiler
    type: Type*


# Type information about a function or method defined in the current file.
# Not created for anything imported from another file.
@public
class FunctionOrMethodTypes:
    signature: Signature
    locals: List[LocalVariable]

    def find_local_var(self, name: byte*) -> LocalVariable*:
        for var = self.locals.ptr; var < self.locals.end(); var++:
            if strcmp(var.name, name) == 0:
                return var
        return NULL

    def add_variable(self, t: Type*, name: byte*) -> None:
        var = LocalVariable{type = t}

        assert name != NULL
        assert self.find_local_var(name) == NULL
        assert strlen(name) < sizeof(var.name)
        strcpy(var.name, name)

        self.locals.append(var)

    def free(self) -> None:
        free(self.locals.ptr)
        self.signature.free()
