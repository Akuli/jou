import "stdlib/assert.jou"
import "stdlib/limits.jou"
import "stdlib/str.jou"
import "stdlib/list.jou"
import "stdlib/io.jou"
import "stdlib/mem.jou"

import "./types.jou"


def print_string(s: byte*) -> None:
    putchar('"')
    for i = 0; s[i] != '\0'; i++:
        if 32 <= s[i] and s[i] <= 126:
            # printable ascii character
            putchar(s[i])
        elif s[i] == '\n':
            printf("\\n")
        else:
            printf("\\x%02x", s[i])
    putchar('"')


# Constants can appear in AST and also compilation steps after AST.
@public
enum ConstantKind:
    Null    # First, so that zero-initializing a constant produces this, not something that requires cleanup
    EnumMember
    Integer
    Float
    Double
    PointerString
    Bool
    ArrayOfBytes  # TODO: delete this
    Array

class IntegerConstant:
    size_in_bits: int
    is_signed: bool
    value: int64  # "as uint64" is needed to get the right value for uint64 constants

class EnumMemberConstant:
    enumtype: Type*
    memberidx: int

@public
class Constant:
    kind: ConstantKind
    union:
        integer: IntegerConstant
        pointer_string: byte*
        array_of_bytes: List[byte]  # may contain zero bytes
        float_or_double_text: byte[100]  # convenient because LLVM wants a string anyway
        boolean: bool
        enum_member: EnumMemberConstant
        array_elements: List[Constant]

    @public
    def print(self) -> None:
        match self.kind:
            case ConstantKind.EnumMember:
                printf("enum member %d of %s\n", self.enum_member.memberidx, self.enum_member.enumtype.name)
            case ConstantKind.Bool:
                if self.boolean:
                    printf("True\n")
                else:
                    printf("False\n")
            case ConstantKind.Float:
                printf("float %s\n", self.float_or_double_text)
            case ConstantKind.Double:
                printf("double %s\n", self.float_or_double_text)
            case ConstantKind.Integer:
                if self.integer.is_signed:
                    signed_or_unsigned = "signed"
                else:
                    signed_or_unsigned = "unsigned"
                printf(
                    "%lld (%d-bit %s)\n",
                    self.integer.value,
                    self.integer.size_in_bits,
                    signed_or_unsigned,
                )
            case ConstantKind.Null:
                printf("NULL\n")
            case ConstantKind.ArrayOfBytes:
                printf("array of bytes: [")
                for i = 0; i < self.array_of_bytes.len; i++:
                    if i > 0:
                        printf(",")
                    printf("%d", self.array_of_bytes.ptr[i])
                printf("] (%zd bytes)\n", self.array_of_bytes.len)
            case ConstantKind.PointerString:
                printf("pointer string ")
                print_string(self.pointer_string)
                printf("\n")
            case ConstantKind.Array:
                printf("array of %d elements [", self.array_elements.len)
                for i = 0; i < self.array_elements.len; i++:
                    if i > 0:
                        printf(", ")
                    self.array_elements.ptr[i].print()
                printf("]\n")

    @public
    def free(self) -> None:
        match self.kind:
            case ConstantKind.ArrayOfBytes:
                free(self.array_of_bytes.ptr)
            case ConstantKind.PointerString:
                free(self.pointer_string)
            case ConstantKind.Array:
                for i = 0; i < self.array_elements.len; i++:
                    self.array_elements.ptr[i].free()
                free(self.array_elements.ptr)
            case _:
                pass

    @public
    def copy(self: Constant) -> Constant:
        match self.kind:
            case ConstantKind.ArrayOfBytes:
                old = self.array_of_bytes
                self.array_of_bytes = List[byte]{}
                self.array_of_bytes.extend(old)
            case ConstantKind.PointerString:
                self.pointer_string = strdup(self.pointer_string)
            case ConstantKind.Array:
                new_array = List[Constant]{}
                for i = 0; i < self.array_elements.len; i++:
                    new_array.append(self.array_elements.ptr[i].copy())
                self.array_elements = new_array
            case _:
                pass
        return self

    @public
    def get_type(self) -> Type*:
        match self.kind:
            case ConstantKind.EnumMember:
                return self.enum_member.enumtype
            case ConstantKind.Null:
                return void_ptr_type()
            case ConstantKind.Double:
                return double_type()
            case ConstantKind.Float:
                return float_type()
            case ConstantKind.Bool:
                return bool_type()
            case ConstantKind.ArrayOfBytes:
                assert self.array_of_bytes.len <= INT32_MAX
                return uint_type(8).array_type(self.array_of_bytes.len as int)
            case ConstantKind.PointerString:
                return uint_type(8).pointer_type()
            case ConstantKind.Integer:
                if self.integer.is_signed:
                    return int_type(self.integer.size_in_bits)
                else:
                    return uint_type(self.integer.size_in_bits)
            case ConstantKind.Array:
                # Empty arrays are not allowed, and all array elements are of the same type.
                assert self.array_elements.len > 0
                return self.array_elements.ptr[0].get_type().array_type(self.array_elements.len as int)


@public
def int_constant(type: Type*, value: int64) -> Constant:
    assert type.is_integer_type()
    return Constant{
        kind = ConstantKind.Integer,
        integer = IntegerConstant{
            size_in_bits = type.size_in_bits,
            is_signed = type.kind == TypeKind.SignedInteger,
            value = value
        }
    }
