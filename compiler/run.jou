import "stdlib/assert.jou"
import "stdlib/intnative.jou"
import "stdlib/str.jou"
import "stdlib/list.jou"
import "stdlib/mem.jou"
import "stdlib/io.jou"
import "stdlib/process.jou"

import "./ast.jou"
import "./state.jou"

if WINDOWS:
    import "./paths.jou"
else:
    import "../config.jou"


def get_quoted_object_file_paths() -> byte*:
    result = List[byte]{}
    for jou_file = global_compiler_state.jou_files.ptr; jou_file < global_compiler_state.jou_files.end(); jou_file++:
        assert jou_file.object_file_path != NULL
        # TODO: quote better?
        result.append(' ')
        result.append('"')
        result.extend_from_ptr(jou_file.object_file_path, strlen(jou_file.object_file_path))
        result.append('"')
    result.append('\0')
    return result.ptr


# Linker flags come from:
#   - files with 'link' statements
#   - command-line --linker-flags argument
def collect_linker_flags() -> byte*:
    maxlen: intnative = 0
    maxlen += strlen("-lm") + 1  # TODO: delete this
    if global_compiler_state.args.linker_flags != NULL:
        maxlen += strlen(global_compiler_state.args.linker_flags) + 1
    for jou_file = global_compiler_state.jou_files.ptr; jou_file < global_compiler_state.jou_files.end(); jou_file++:
        for stmt = jou_file.ast.ptr; stmt < jou_file.ast.end(); stmt++:
            if stmt.kind == AstStatementKind.Link:
                maxlen += strlen(stmt.link_statement.resolved_flags) + 1

    result: byte* = malloc(maxlen + 1)
    assert result != NULL
    strcpy(result, "")

    strcat(result, "-lm ")  # TODO: delete this
    if global_compiler_state.args.linker_flags != NULL:
        strcat(result, global_compiler_state.args.linker_flags)
        strcat(result, " ")
    for jou_file = global_compiler_state.jou_files.ptr; jou_file < global_compiler_state.jou_files.end(); jou_file++:
        for stmt = jou_file.ast.ptr; stmt < jou_file.ast.end(); stmt++:
            if stmt.kind == AstStatementKind.Link:
                strcat(result, stmt.link_statement.resolved_flags)
                strcat(result, " ")

    return result


@public
def run_linker(exepath: byte*) -> None:
    linker_flags = collect_linker_flags()
    quoted_object_files = get_quoted_object_file_paths()

    command: byte*
    if WINDOWS:
        # Assume mingw with clang has been downloaded with windows_setup.sh.
        #
        # During the bootstrapping, the location of mingw is something
        # like ../../../mingw64 relative to jou.exe location, and it is passed
        # with an environment variable.
        mingw_dir = getenv("JOU_MINGW_DIR")
        if mingw_dir != NULL:
            # Environment variable given
            mingw_dir = strdup(mingw_dir)
        else:
            # Assume the folder that contains jou.exe also contains mingw64
            jou_exe = find_current_executable()
            asprintf(&mingw_dir, "%s\\mingw64", dirname(jou_exe))
            free(jou_exe)

        # Could also use clang, but gcc has less dependencies so we can make the Windows zips smaller.
        # Windows quoting is weird. The outermost quotes get stripped here.
        asprintf(&command, "\"\"%s\\bin\\gcc.exe\" %s -o \"%s\" %s\"", mingw_dir, quoted_object_files, exepath, linker_flags)
        free(mingw_dir)
    else:
        # Assume clang is installed and use it to link. Could use ld, but clang is needed anyway.
        asprintf(&command, "'%s' %s -o '%s' %s", JOU_CLANG_PATH, quoted_object_files, exepath, linker_flags)

    free(linker_flags)
    free(quoted_object_files)

    if global_compiler_state.args.verbosity >= 1:
        printf("Running linker: %s\n", command)

    if system(command) != 0:
        exit(1)
    free(command)


@public
def run_exe(exepath: byte*) -> int:
    if global_compiler_state.args.verbosity >= 1:
        printf("Run: %s\n", exepath)

    command: byte*
    if WINDOWS:
        asprintf(&command, "\"%s\"", exepath)
        while strstr(command, "/") != NULL:
            *strstr(command, "/") = '\\'
    else:
        if global_compiler_state.args.valgrind:
            asprintf(&command, "valgrind -q --leak-check=full --show-leak-kinds=all --error-exitcode=1 '%s'", exepath)
        else:
            asprintf(&command, "'%s'", exepath)

    # Make sure that everything else shows up before the user's prints.
    fflush(get_stdout())
    fflush(get_stderr())

    ret = system(command)
    free(command)

    # Do not exit immediately, so that the compiler can clean up the memory it
    # uses. This makes error messages much shorter when running tests with
    # valgrind fails.
    return 0 if ret == 0 else 1  # TODO: extract actual error code / return value
