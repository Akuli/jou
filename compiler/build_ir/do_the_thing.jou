import "stdlib/mem.jou"

import "../ast.jou"
import "../llvm.jou"
import "../target.jou"
import "../types.jou"
import "./ast_to_builder.jou"
import "./builder.jou"
import "./llvm_utils.jou"


def build_llvm_ir_for_function_or_method(llvm_module: LLVMModule*, ast: AstFunctionOrMethod*) -> None:
    ast2ir = AstToIR{
        builder = Builder{
            llvm_module = llvm_module,
            llvm_builder = LLVMCreateBuilder(),
            llvm_func = declare_in_llvm(&ast->types.signature, llvm_module),
        },
        nlocals = ast->types.nlocals,
    }

    ast2ir.builder.set_current_block(ast2ir.builder.add_block())

    if (WINDOWS or MACOS or NETBSD) and ast->types.signature.is_main_function():
        # Insert a call to the special startup function into main()
        sig = Signature{name = "_jou_startup"}
        ast2ir.builder.call(&sig, NULL, 0)

    ast2ir.locals = malloc(sizeof(ast2ir.locals[0]) * ast2ir.nlocals)
    assert ast2ir.locals != NULL
    for i = 0; i < ast2ir.nlocals; i++:
        var_name = ast->types.locals[i]->name
        var_type = ast->types.locals[i]->type
        var_ptr = ast2ir.builder.stack_alloc(var_type)
        ast2ir.locals[i] = LocalVar{name = var_name, ptr = var_ptr}
        if i < ast->types.signature.nargs:
            # First n local variables are the function arguments
            ast2ir.builder.set_ptr(var_ptr, ast2ir.builder.get_argument(i, var_type))

    ast2ir.build_body(&ast->body)
    if ast->types.signature.returntype == NULL:
        ast2ir.builder.ret(NULL)  # implicit "return" when falling off end of function
    else:
        ast2ir.builder.unreachable()
    LLVMDisposeBuilder(ast2ir.builder.llvm_builder)
    free(ast2ir.locals)

    if (
        ast->types.signature.get_self_class() == NULL
        and not ast->public
        and not ast->types.signature.is_main_function()
    ):
        # private function
        LLVMSetLinkage(ast2ir.builder.llvm_func, LLVMLinkage.Private)


@public
def build_llvm_ir(ast: AstFile*) -> LLVMModule*:
    module = LLVMModuleCreateWithName(ast->path)
    LLVMSetTarget(module, target.triple)
    LLVMSetDataLayout(module, target.data_layout)

    for g = ast->types.globals; g < &ast->types.globals[ast->types.nglobals]; g++:
        t = type_to_llvm(g->type)
        globalptr = LLVMAddGlobal(module, t, g->name)
        if g->defined_in_current_file:
            LLVMSetInitializer(globalptr, LLVMConstNull(t))

    for i = 0; i < ast->body.nstatements; i++:
        stmt = &ast->body.statements[i]

        match stmt->kind:
            case AstStatementKind.FunctionDef:
                build_llvm_ir_for_function_or_method(module, &stmt->function)
            case AstStatementKind.Class:
                assert stmt->classdef.type != NULL
                for m = stmt->classdef.members; m < &stmt->classdef.members[stmt->classdef.nmembers]; m++:
                    if m->kind == AstClassMemberKind.Method:
                        build_llvm_ir_for_function_or_method(module, &m->method)
            case _:
                pass

    return module
