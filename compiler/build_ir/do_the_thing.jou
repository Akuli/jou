import "stdlib/mem.jou"

import "../ast.jou"
import "../llvm.jou"
import "../target.jou"
import "../types.jou"
import "./ast_to_builder.jou"
import "./llvm_builder.jou"
import "./llvm_utils.jou"


def build_llvm_ir_for_function_or_method(llvm_module: LLVMModule*, ast: AstFunctionOrMethod*) -> None:
    builder = Builder{
        llvm_module = llvm_module,
        llvm_builder = LLVMCreateBuilder(),
    }

    public = (
        ast->public
        or ast->types.signature.is_main_function()
        or ast->types.signature.get_self_class() != NULL
    )

    ast2ir = AstToIR{builder = &builder}
    ast2ir.begin_function(&ast->types.signature, ast->types.locals, ast->types.nlocals, public)

    if (WINDOWS or MACOS or NETBSD) and ast->types.signature.is_main_function():
        # Insert a call to the special startup function into main()
        sig = Signature{name = "_jou_startup"}
        builder.call(&sig, NULL, 0)

    ast2ir.build_body(&ast->body)
    ast2ir.end_function()

    LLVMDisposeBuilder(builder.llvm_builder)
    free(ast2ir.locals)

    if (
        ast->types.signature.get_self_class() == NULL
        and not ast->public
        and not ast->types.signature.is_main_function()
    ):
        # private function
        LLVMSetLinkage(builder.llvm_func, LLVMLinkage.Private)


@public
def build_llvm_ir(ast: AstFile*) -> LLVMModule*:
    module = LLVMModuleCreateWithName(ast->path)
    LLVMSetTarget(module, target.triple)
    LLVMSetDataLayout(module, target.data_layout)

    for g = ast->types.globals; g < &ast->types.globals[ast->types.nglobals]; g++:
        t = type_to_llvm(g->type)
        globalptr = LLVMAddGlobal(module, t, g->name)
        if g->defined_in_current_file:
            LLVMSetInitializer(globalptr, LLVMConstNull(t))

    for i = 0; i < ast->body.nstatements; i++:
        stmt = &ast->body.statements[i]

        match stmt->kind:
            case AstStatementKind.FunctionDef:
                build_llvm_ir_for_function_or_method(module, &stmt->function)
            case AstStatementKind.Class:
                assert stmt->classdef.type != NULL
                for m = stmt->classdef.members; m < &stmt->classdef.members[stmt->classdef.nmembers]; m++:
                    if m->kind == AstClassMemberKind.Method:
                        build_llvm_ir_for_function_or_method(module, &m->method)
            case _:
                pass

    return module
