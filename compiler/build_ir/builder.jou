# This file abstracts away all LLVM things needed to build the LLVM IR for a
# function or method.
#
# The idea is that instead of building just LLVM IR, we can also build other
# useful data structures by modifying only the IR builder. This means we don't
# walk through the AST in multiple different places that could handle some
# corner cases differently.
#
# Currently this is used only to build LLVM IR, but more uses are planned.

import "stdlib/str.jou"
import "stdlib/io.jou"
import "stdlib/mem.jou"

import "../constants.jou"
import "../llvm.jou"
import "../types.jou"
import "./llvm_utils.jou"


# TODO: useful, but doesn't belong here
def find_enum_member(enumtype: Type*, name: byte*) -> int:
    assert enumtype->kind == TypeKind.Enum
    for i = 0; i < enumtype->enummembers.count; i++:
        if strcmp(enumtype->enummembers.names[i], name) == 0:
            return i
    assert False


class BuilderValue:
    type: Type*
    llvm_value: LLVMValue*


class BuilderFunctionOrMethod:
    llvm_funcptr: LLVMValue*

    def make_private(self) -> None:
        LLVMSetLinkage(self->llvm_funcptr, LLVMLinkage.Private)


class BuilderBlock:
    llvm_block: LLVMBasicBlock*


class Builder:
    llvm_module: LLVMModule*
    llvm_builder: LLVMBuilder*
    llvm_func: LLVMValue*

    # TODO: Everything named legacy_llvm14_cast can be removed once we drop LLVM 14 support
    #       Needed due to LLVM opaque pointer types transition
    #
    # TODO: which casts are necessary on LLVM 14 and which are not?

    # *ptr = value
    def set_ptr(self, ptr: BuilderValue, value: BuilderValue) -> None:
        if ptr.type != value.type->pointer_type():
            printf("Cannot set value of %s to %s\n", ptr.type->name, value.type->name)
        assert ptr.type == value.type->pointer_type()
        ptr_type = LLVMPointerType(type_to_llvm(value.type), 0)
        llvm_ptr = LLVMBuildBitCast(self->llvm_builder, ptr.llvm_value, ptr_type, "legacy_llvm14_cast")
        LLVMBuildStore(self->llvm_builder, value.llvm_value, llvm_ptr)

    # *ptr
    def dereference(self, ptr: BuilderValue) -> BuilderValue:
        assert ptr.type->kind == TypeKind.Pointer
        llvm_result = LLVMBuildLoad2(self->llvm_builder, type_to_llvm(ptr.type->value_type), ptr.llvm_value, "dereference")
        return BuilderValue{type = ptr.type->value_type, llvm_value = llvm_result}

    # Allocates enough stack space in the function to hold a value of given type.
    # Returns a pointer to the stack space.
    def stack_alloc(self, t: Type*) -> BuilderValue:
        llvm_ptr = LLVMBuildAlloca(self->llvm_builder, type_to_llvm(t), "stack_alloc")
        llvm_ptr = LLVMBuildBitCast(self->llvm_builder, llvm_ptr, type_to_llvm(voidPtrType), "legacy_llvm14_cast")
        return BuilderValue{type = t->pointer_type(), llvm_value = llvm_ptr}

    # Returns &ptr[index]
    def indexed_pointer(self, ptr: BuilderValue, index: BuilderValue) -> BuilderValue:
        assert ptr.type->kind == TypeKind.Pointer
        assert index.type == longType  # doesn't work right if it's other type
        llvm_result = LLVMBuildGEP2(
            self->llvm_builder,
            type_to_llvm(ptr.type->value_type),
            ptr.llvm_value,
            &index.llvm_value,
            1,
            "indexed_pointer",
        )
        return BuilderValue{type = ptr.type, llvm_value = llvm_result}

    # Returns &ptr->field
    def class_field_pointer(self, ptr: BuilderValue, field_name: byte*) -> BuilderValue:
        assert ptr.type->kind == TypeKind.Pointer
        classtype = ptr.type->value_type
        assert classtype->kind == TypeKind.Class

        # TODO: method to find field
        field: ClassField* = NULL
        for f = classtype->classdata.fields; f < &classtype->classdata.fields[classtype->classdata.nfields]; f++:
            if strcmp(f->name, field_name) == 0:
                field = f
                break
        assert field != NULL

        llvm_struct_type = type_to_llvm(classtype)
        llvm_ptr = LLVMBuildBitCast(self->llvm_builder, ptr.llvm_value, LLVMPointerType(llvm_struct_type, 0), "legacy_llvm14_cast")
        llvm_result = LLVMBuildStructGEP2(self->llvm_builder, llvm_struct_type, llvm_ptr, field->union_id, field->name)
        llvm_result = LLVMBuildBitCast(self->llvm_builder, llvm_result, type_to_llvm(voidPtrType), "legacy_llvm14_cast")
        return BuilderValue{type = field->type->pointer_type(), llvm_value = llvm_result}

    # Returns &llvm_stringiable. Type needs to be passed in because a new builder
    # unaware of global variables is created for each function.
    def global_var_ptr(self, name: byte*, var_type: Type*) -> BuilderValue:
        llvm_result = LLVMGetNamedGlobal(self->llvm_module, name)
        assert llvm_result != NULL
        llvm_result = LLVMBuildBitCast(self->llvm_builder, llvm_result, type_to_llvm(voidPtrType), "legacy_llvm14_cast")
        return BuilderValue{type = var_type->pointer_type(), llvm_value = llvm_result}

    # Returns the i'th argument given to function
    def get_argument(self, i: int, argtype: Type*) -> BuilderValue:
        llvm_result = LLVMGetParam(self->llvm_func, i)
        return BuilderValue{type = argtype, llvm_value = llvm_result}

    # Function or method call. If method, self with the correct type must be included in args.
    def call(self, sig: Signature*, args: BuilderValue*, nargs: int) -> BuilderValue:
        assert nargs >= sig->nargs
        if nargs > sig->nargs:
            assert sig->takes_varargs

        assert nargs <= 100
        llvm_args: LLVMValue*[100]
        for i = 0; i < nargs; i++:
            if i < sig->nargs:
                # not a vararg
                assert args[i].type == sig->argtypes[i]
            llvm_args[i] = args[i].llvm_value

        debug_name: byte[100] = ""
        if sig->returntype != NULL:
            snprintf(debug_name, sizeof(debug_name), "%s_return_value", sig->name)

        llvm_func = declare_in_llvm(sig, self->llvm_module)
        llvm_return_value = LLVMBuildCall2(self->llvm_builder, signature_to_llvm(sig), llvm_func, llvm_args, nargs, debug_name)

        if sig->returntype == NULL:
            return BuilderValue{}
        else:
            assert llvm_return_value != NULL
            return BuilderValue{type = sig->returntype, llvm_value = llvm_return_value}

    # string as array of bytes
    def string_array(self, s: byte*, array_size: int) -> BuilderValue:
        assert strlen(s) < array_size
        padded: byte* = malloc(array_size)
        memset(padded, 0, array_size)
        strcpy(padded, s)
        llvm_array = LLVMConstString(padded, array_size, True as int)
        free(padded)
        return BuilderValue{type = byteType->array_type(array_size), llvm_value = llvm_array}

    # string as '\0' terminated pointer
    def string(self, s: byte*) -> BuilderValue:
        llvm_array = self->string_array(s, (strlen(s) + 1) as int).llvm_value
        llvm_string = LLVMAddGlobal(self->llvm_module, LLVMTypeOf(llvm_array), "string_literal")
        LLVMSetLinkage(llvm_string, LLVMLinkage.Private)  # This makes it a static global variable
        LLVMSetInitializer(llvm_string, llvm_array)
        llvm_string = LLVMBuildBitCast(self->llvm_builder, llvm_string, type_to_llvm(byteType->pointer_type()), "legacy_llvm14_cast")
        return BuilderValue{type = byteType->pointer_type(), llvm_value = llvm_string}

    def boolean(self, b: bool) -> BuilderValue:
        return BuilderValue{
            type = boolType,
            llvm_value = LLVMConstInt(LLVMInt1Type(), b as long, False as int),
        }

    def integer(self, t: Type*, value: long) -> BuilderValue:
        assert t->is_integer_type()
        return BuilderValue{
            type = t,
            llvm_value = LLVMConstInt(type_to_llvm(t), value, (t->kind == TypeKind.SignedInteger) as int),
        }

    def float_or_double(self, t: Type*, string: byte*) -> BuilderValue:
        assert t->kind == TypeKind.FloatingPoint
        return BuilderValue{
            type = t,
            llvm_value = LLVMConstRealOfString(type_to_llvm(t), string)
        }

    def zero_of_type(self, t: Type*) -> BuilderValue:
        return BuilderValue{
            type = t,
            llvm_value = LLVMConstNull(type_to_llvm(t)),
        }

    def enum_member(self, t: Type*, name: byte*) -> BuilderValue:
        return BuilderValue{
            type = t,
            llvm_value = LLVMConstInt(LLVMInt32Type(), find_enum_member(t, name), False as int),
        }

    def constant(self, c: Constant*) -> BuilderValue:
        llvm_constant: LLVMValue* = NULL
        match c->kind:
            case ConstantKind.Bool:
                return self->boolean(c->boolean)
            case ConstantKind.Integer:
                return self->integer(c->get_type(), c->integer.value)
            case ConstantKind.Float | ConstantKind.Double:
                return self->float_or_double(c->get_type(), c->double_or_float_text)
            case ConstantKind.Null:
                llvm_constant = LLVMConstNull(type_to_llvm(voidPtrType))
            case ConstantKind.String:
                return self->string(c->str)
            case ConstantKind.EnumMember:
                llvm_constant = LLVMConstInt(LLVMInt32Type(), c->enum_member.memberidx, False as int)

        assert llvm_constant != NULL
        return BuilderValue{type = c->get_type(), llvm_value = llvm_constant}

    # a + b
    def add(self, a: BuilderValue, b: BuilderValue) -> BuilderValue:
        assert a.type == b.type
        match a.type->kind:
            case TypeKind.FloatingPoint:
                llvm_sum = LLVMBuildFAdd(self->llvm_builder, a.llvm_value, b.llvm_value, "float_sum")
            case TypeKind.SignedInteger | TypeKind.UnsignedInteger:
                llvm_sum = LLVMBuildAdd(self->llvm_builder, a.llvm_value, b.llvm_value, "int_sum")
            case _:
                assert False
        return BuilderValue{type = a.type, llvm_value = llvm_sum}

    # a - b
    def sub(self, a: BuilderValue, b: BuilderValue) -> BuilderValue:
        assert a.type == b.type
        match a.type->kind:
            case TypeKind.FloatingPoint:
                llvm_diff = LLVMBuildFSub(self->llvm_builder, a.llvm_value, b.llvm_value, "float_diff")
            case TypeKind.SignedInteger | TypeKind.UnsignedInteger:
                llvm_diff = LLVMBuildSub(self->llvm_builder, a.llvm_value, b.llvm_value, "int_diff")
            case _:
                assert False
        return BuilderValue{type = a.type, llvm_value = llvm_diff}

    # a * b
    def mul(self, a: BuilderValue, b: BuilderValue) -> BuilderValue:
        assert a.type == b.type
        match a.type->kind:
            case TypeKind.FloatingPoint:
                llvm_prod = LLVMBuildFMul(self->llvm_builder, a.llvm_value, b.llvm_value, "float_prod")
            case TypeKind.SignedInteger | TypeKind.UnsignedInteger:
                llvm_prod = LLVMBuildMul(self->llvm_builder, a.llvm_value, b.llvm_value, "int_prod")
            case _:
                assert False
        return BuilderValue{type = a.type, llvm_value = llvm_prod}

    # a / b
    def div(self, a: BuilderValue, b: BuilderValue) -> BuilderValue:
        assert a.type == b.type
        match a.type->kind:
            case TypeKind.FloatingPoint:
                llvm_quot = LLVMBuildFDiv(self->llvm_builder, a.llvm_value, b.llvm_value, "float_quot")
            case TypeKind.SignedInteger:
                llvm_quot = build_llvm_signed_div(self->llvm_builder, a.llvm_value, b.llvm_value)
            case TypeKind.UnsignedInteger:
                llvm_quot = LLVMBuildUDiv(self->llvm_builder, a.llvm_value, b.llvm_value, "uint_quot")
            case _:
                assert False
        return BuilderValue{type = a.type, llvm_value = llvm_quot}

    # a % b
    def mod(self, a: BuilderValue, b: BuilderValue) -> BuilderValue:
        assert a.type == b.type
        match a.type->kind:
            case TypeKind.FloatingPoint:
                llvm_mod = LLVMBuildFRem(self->llvm_builder, a.llvm_value, b.llvm_value, "float_mod")
            case TypeKind.SignedInteger:
                llvm_mod = build_llvm_signed_mod(self->llvm_builder, a.llvm_value, b.llvm_value)
            case TypeKind.UnsignedInteger:
                llvm_mod = LLVMBuildURem(self->llvm_builder, a.llvm_value, b.llvm_value, "uint_mod")
            case _:
                assert False
        return BuilderValue{type = a.type, llvm_value = llvm_mod}

    # a == b
    def eq(self, a: BuilderValue, b: BuilderValue) -> BuilderValue:
        assert a.type == b.type
        match a.type->kind:
            case TypeKind.SignedInteger | TypeKind.UnsignedInteger | TypeKind.Enum | TypeKind.Bool:
                llvm_result = LLVMBuildICmp(self->llvm_builder, LLVMIntPredicate.EQ, a.llvm_value, b.llvm_value, "eq")
            case TypeKind.FloatingPoint:
                llvm_result = LLVMBuildFCmp(self->llvm_builder, LLVMRealPredicate.OEQ, a.llvm_value, b.llvm_value, "eq")
            case _:
                assert False
        return BuilderValue{type = boolType, llvm_value = llvm_result}

    # a < b
    def lt(self, a: BuilderValue, b: BuilderValue) -> BuilderValue:
        assert a.type == b.type
        match a.type->kind:
            case TypeKind.SignedInteger:
                llvm_result = LLVMBuildICmp(self->llvm_builder, LLVMIntPredicate.SLT, a.llvm_value, b.llvm_value, "lt")
            case TypeKind.UnsignedInteger:
                llvm_result = LLVMBuildICmp(self->llvm_builder, LLVMIntPredicate.ULT, a.llvm_value, b.llvm_value, "lt")
            case TypeKind.FloatingPoint:
                llvm_result = LLVMBuildFCmp(self->llvm_builder, LLVMRealPredicate.OLT, a.llvm_value, b.llvm_value, "lt")
            case _:
                assert False
        return BuilderValue{type = boolType, llvm_value = llvm_result}

    # not value
    def not_(self, value: BuilderValue) -> BuilderValue:
        llvm_result = LLVMBuildXor(self->llvm_builder, value.llvm_value, LLVMConstInt(LLVMInt1Type(), 1, False as int), "not")
        return BuilderValue{type = boolType, llvm_value = llvm_result}

    # sizeof(any value of given type)
    def size_of(self, t: Type*) -> BuilderValue:
        return BuilderValue{
            type = longType,
            llvm_value = LLVMSizeOf(type_to_llvm(t)),
        }

    # memset(ptr, 0, sizeof(*ptr))
    def memset_to_zero(self, ptr: BuilderValue) -> None:
        assert ptr.type->kind == TypeKind.Pointer
        size = self->size_of(ptr.type->value_type).llvm_value
        zero_byte = LLVMConstInt(LLVMInt8Type(), 0, False as int)
        LLVMBuildMemSet(self->llvm_builder, ptr.llvm_value, zero_byte, size, 0)

    # value as to
    def cast(self, value: BuilderValue, to: Type*) -> BuilderValue:
        llvm_result = build_llvm_cast(self->llvm_builder, value.llvm_value, value.type, to)
        return BuilderValue{type = to, llvm_value = llvm_result}

    # Blocks are used to implement e.g. if statements and loops.
    def add_block(self) -> BuilderBlock:
        llvm_block = LLVMAppendBasicBlock(self->llvm_func, "block")
        return BuilderBlock{llvm_block = llvm_block}

    # Decide which block will contain the resulting instructions.
    # This must be called after creating a new builder!!!
    def set_current_block(self, block: BuilderBlock) -> None:
        LLVMPositionBuilderAtEnd(self->llvm_builder, block.llvm_block)

    # Conditional branch:
    #
    #   if cond:
    #       then
    #   else:
    #       otherwise
    #
    # This leaves the builder in a "no current block" state, i.e. you must call
    # set_current_block() before the builder is usable again.
    def branch(self, cond: BuilderValue, then: BuilderBlock, otherwise: BuilderBlock) -> None:
        LLVMBuildCondBr(self->llvm_builder, cond.llvm_value, then.llvm_block, otherwise.llvm_block)

    # Go to the block. Similar to branch() but no condition. LLVM calls this
    # "unconditional branch", which IMO doesn't make sense because it always
    # jumps and hence doesn't branch.
    #
    # This leaves the builder in a "no current block" state, i.e. you must call
    # set_current_block() before the builder is usable again.
    def jump(self, next_block: BuilderBlock) -> None:
        LLVMBuildBr(self->llvm_builder, next_block.llvm_block)

    # Add an instruction that should never run.
    # May be used by optimizer, but also tells LLVM that the block ends here.
    def unreachable(self) -> None:
        LLVMBuildUnreachable(self->llvm_builder)

    # Return from function/method. Value should be NULL if the function is '-> None'.
    def ret(self, value: BuilderValue*) -> None:
        if value == NULL:
            LLVMBuildRetVoid(self->llvm_builder)
        else:
            LLVMBuildRet(self->llvm_builder, value->llvm_value)
