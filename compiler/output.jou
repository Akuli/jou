import "stdlib/str.jou"
import "stdlib/io.jou"
import "stdlib/process.jou"
import "stdlib/mem.jou"

import "../config.jou"
import "./llvm.jou"
import "./target.jou"
import "./paths.jou"
import "./command_line_args.jou"


def run_linker(objpaths: byte**, exepath: byte*) -> None:
    jou_exe = find_current_executable()
    instdir = dirname(jou_exe)

    if command_line_args.linker_flags != NULL:
        linker_flags = malloc(strlen(command_line_args.linker_flags) + 50)
        assert linker_flags != NULL
        strcpy(linker_flags, "-lm ")
        strcat(linker_flags, command_line_args.linker_flags)
    else:
        linker_flags = strdup("-lm")
        assert linker_flags != NULL

    size = 10L
    for i = 0; objpaths[i] != NULL; i++:
        size += strlen(objpaths[i]) + 10

    quoted_object_files: byte* = malloc(size)
    assert quoted_object_files != NULL
    quoted_object_files[0] = '\0'

    for i = 0; objpaths[i] != NULL; i++:
        if i != 0:
            strcat(quoted_object_files, " ")
        strcat(quoted_object_files, "\"")
        strcat(quoted_object_files, objpaths[i])  # TODO: escape properly?
        strcat(quoted_object_files, "\"")

    size = strlen(instdir) + strlen(quoted_object_files) + strlen(exepath) + strlen(linker_flags) + 100
    if get_jou_clang_path() != NULL:
        size += strlen(get_jou_clang_path())
    command: byte* = malloc(size)

    if WINDOWS:
        # Assume mingw with clang has been downloaded with windows_setup.sh.
        # Could also use clang, but gcc has less dependencies so we can make the Windows zips smaller.
        # Windows quoting is weird. The outermost quotes get stripped here.
        snprintf(command, size, "\"\"%s\\mingw64\\bin\\gcc.exe\" %s -o \"%s\" %s\"", instdir, quoted_object_files, exepath, linker_flags)
    else:
        # Assume clang is installed and use it to link. Could use lld, but clang is needed anyway.
        # instdir is not used in this case.
        snprintf(command, size, "'%s' %s -o '%s' %s", get_jou_clang_path(), quoted_object_files, exepath, linker_flags)

    free(quoted_object_files)
    free(jou_exe)
    free(linker_flags)

    if command_line_args.verbosity >= 2:
        printf("Running linker: %s\n", command)
    elif command_line_args.verbosity >= 1:
        printf("Running linker\n")

    if system(command) != 0:
        exit(1)
    free(command)


def compile_to_object_file(module: LLVMModule*) -> byte*:
    len = 0L
    objname = get_filename_without_jou_suffix(LLVMGetSourceFileName(module, &len))

    objname = realloc(objname, strlen(objname) + 10)
    if WINDOWS:
        strcat(objname, ".obj")
    else:
        strcat(objname, ".o")

    path = get_path_to_file_in_jou_compiled(objname)
    free(objname)

    if command_line_args.verbosity >= 1:
        printf("Emitting object file: %s\n", path)

    tmppath = strdup(path)
    error: byte* = NULL
    if LLVMTargetMachineEmitToFile(target.target_machine, module, tmppath, LLVMCodeGenFileType::ObjectFile, &error) != 0:
        assert error != NULL
        fprintf(stderr, "failed to emit object file \"%s\": %s\n", path, error)
        exit(1)
    free(tmppath)

    assert error == NULL
    return path
