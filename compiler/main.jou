import "stdlib/assert.jou"
import "stdlib/io.jou"
import "stdlib/list.jou"
import "stdlib/mem.jou"
import "stdlib/str.jou"

import "./ast.jou"
import "./builders/uvg_builder.jou"
import "./command_line_args.jou"
import "./errors_and_warnings.jou"
import "./evaluate.jou"
import "./global_symbols.jou"
import "./parallel_compile.jou"
import "./parser.jou"
import "./paths.jou"
import "./run.jou"
import "./state.jou"
import "./target.jou"
import "./token.jou"
import "./tokenizer.jou"
import "./typecheck/step1_global_symbols.jou"
import "./typecheck/step2_class_members.jou"
import "./typecheck/step3_function_and_method_bodies.jou"
import "./types.jou"


def defines_main(jou_file: JouFile*) -> bool:
    for stmt = jou_file.ast.ptr; stmt < jou_file.ast.end(); stmt++:
        if (
            stmt.kind == AstStatementKind.FunctionDef
            and strcmp(stmt.symbol().signature.name, "main") == 0
        ):
            return True
    return False


def warn_about_unused(jou_file: JouFile*) -> None:
    msg: byte[500]

    for stmt = jou_file.ast.ptr; stmt < jou_file.ast.end(); stmt++:
        if stmt.kind == AstStatementKind.Import and not stmt.import_statement.used:
            snprintf(msg, sizeof msg, "\"%s\" imported but not used", stmt.import_statement.specified_path)
            show_warning(stmt.location, msg)

    for sym_stmt = jou_file.symbol_statements.ptr; sym_stmt < jou_file.symbol_statements.ptr; sym_stmt++:
        stmt = *sym_stmt

        symbol = stmt.symbol()
        if symbol.public or symbol.used:
            continue

        # Do not show a warning if a private main function is unused.
        #
        # You are probably wondering: what the heck is a private main function?
        #
        # If an imported file has a main() function, it becomes private.
        #
        # This is useful in large Jou projects. For example, utils/json.jou
        # might have public functions for working with JSON, and some example
        # code in a main() function. That main() is usually private, but if you
        # run "jou utils/json.jou", then it becomes public and runs.
        if stmt.kind == AstStatementKind.FunctionDef and strcmp(symbol.name, "main") == 0:
            continue

        match stmt.kind:
            case AstStatementKind.Enum:
                short_desc = "enum"
            case AstStatementKind.Class:
                short_desc = "class"
            case _:
                short_desc = symbol.short_description()

        match stmt.kind:
            case AstStatementKind.FunctionDeclare | AstStatementKind.GlobalVariableDeclare:
                snprintf(msg, sizeof(msg), "%s '%s' declared but not used", short_desc, symbol.name)
            case _:
                snprintf(msg, sizeof(msg), "%s '%s' defined but not used", short_desc, symbol.name)

        show_warning(stmt.location, msg)


def check_imports_at_start_of_file(body: List[AstStatement]) -> None:
    seen_other = False
    for stmt = body.ptr; stmt < body.end(); stmt++:
        if stmt.kind == AstStatementKind.Import:
            if seen_other:
                fail(stmt.location, "imports must be in the beginning of the file")
        else:
            seen_other = True


def check_class_fields_before_methods(body: List[AstStatement]) -> None:
    for stmt = body.ptr; stmt < body.end(); stmt++:
        if stmt.kind == AstStatementKind.Class:
            seen_other = False
            for p = stmt.classdef.body.ptr; p < stmt.classdef.body.end(); p++:
                if p.kind == AstStatementKind.ClassField or p.kind == AstStatementKind.ClassUnion:
                    if seen_other:
                        fail(p.location, "class fields must be defined before methods")
                else:
                    seen_other = True


def check_duplicate_defining(body: List[AstStatement]) -> None:
    msg: byte[300]

    for stmt1 = body.ptr; stmt1 < body.end(); stmt1++:
        for stmt2 = &stmt1[1]; stmt2 < body.end(); stmt2++:
            if (
                stmt1.symbol() != NULL
                and stmt2.symbol() != NULL
                and strcmp(stmt1.symbol().name, stmt2.symbol().name) == 0
            ):
                snprintf(
                    msg,
                    sizeof(msg),
                    "a %s named '%s' already exists (defined on line %d)",
                    stmt1.symbol().short_description(),
                    stmt1.symbol().name,
                    stmt1.location.lineno,
                )
                fail(stmt2.location, msg)

    # Special-casing for the special constants, because they don't come from anything in AST
    for stmt = body.ptr; stmt < body.end(); stmt++:
        if stmt.symbol() != NULL and get_special_constant(stmt.symbol().name) != NULL:
            snprintf(msg, sizeof(msg), "a special constant named '%s' already exists", stmt.symbol().name)
            fail(stmt.location, msg)


def find_file(path: byte*) -> JouFile*:
    for p = global_compiler_state.jou_files.ptr; p < global_compiler_state.jou_files.end(); p++:
        if strcmp(p.path, path) == 0:
            return p
    return NULL


# AST must not move to new memory location after this runs
def collect_symbol_statements(ast: List[AstStatement]) -> List[AstStatement*]:
    result = List[AstStatement*]{}

    for stmt = ast.ptr; stmt < ast.end(); stmt++:
        if stmt.symbol() != NULL:
            result.append(stmt)
        if stmt.kind == AstStatementKind.Class:
            for member = stmt.classdef.body.ptr; member < stmt.classdef.body.end(); member++:
                if member.kind == AstStatementKind.MethodDef:
                    member.method.containing_classdef = &stmt.classdef
                    #result.append(member)  # TODO: enable this

    return result


def tokenize_and_parse(path: byte*, import_statement: AstStatement*) -> None:
    if find_file(path) != NULL:
        # already parsed
        return

    jou_file = JouFile{
        path = strdup(path),
        is_main_file = (strcmp(path, global_compiler_state.args.infile) == 0),
    }
    assert jou_file.path != NULL

    if global_compiler_state.args.verbosity >= 1:
        printf("Tokenizing %s\n", path)
    tokenize_result = tokenize(jou_file.path, import_statement)

    if global_compiler_state.args.verbosity >= 2:
        print_tokens(tokenize_result.tokens)

    if global_compiler_state.args.verbosity >= 1:
        printf("Parsing %s\n", path)
    jou_file.ast = parse(tokenize_result.tokens, jou_file.is_main_file)
    tokenize_result.free()

    if global_compiler_state.args.verbosity >= 1:
        printf("Evaluating compile-time if statements in %s\n", path)
    evaluate_compile_time_if_statements(&jou_file)

    if global_compiler_state.args.verbosity >= 2:
        printf("===== AST for file \"%s\" =====\n", path)
        for p = jou_file.ast.ptr; p < jou_file.ast.end(); p++:
            p.print()

    check_imports_at_start_of_file(jou_file.ast)
    check_class_fields_before_methods(jou_file.ast)
    check_duplicate_defining(jou_file.ast)

    # Must be after evaluating compile-time if statements and anything else
    # that may bring more stuff into the AST.
    jou_file.symbol_statements = collect_symbol_statements(jou_file.ast)

    global_compiler_state.jou_files.append(jou_file)

    for stmt = jou_file.ast.ptr; stmt < jou_file.ast.end(); stmt++:
        if stmt.kind == AstStatementKind.Import:
            tokenize_and_parse(stmt.import_statement.resolved_path, stmt)  # recursive call


def tokenize_and_parse_all_files() -> None:
    assert global_compiler_state.args.infile != NULL
    tokenize_and_parse(global_compiler_state.args.infile, NULL)


# Stores pointers to public statements from imported files into the file where
# they should now be accessible due to import.
#
# Must be done after parsing all files and evaluating compile-time if statements:
#   - This assumes that no more Jou files will be discovered afterwards.
#   - This doesn't e.g. look inside `if` statements when looping through @public things.
def make_imported_statements_available() -> None:
    if global_compiler_state.args.verbosity >= 1:
        printf("Making imported statements available...\n")

    msg: byte[500]
    seen_before = List[JouFile*]{}

    for importer = global_compiler_state.jou_files.ptr; importer < global_compiler_state.jou_files.end(); importer++:
        seen_before.len = 0

        for the_import = importer.ast.ptr; the_import < importer.ast.end(); the_import++:
            if the_import.kind != AstStatementKind.Import:
                continue

            imported = find_file(the_import.import_statement.resolved_path)
            assert imported != NULL

            if importer == imported:
                fail(the_import.location, "the file itself cannot be imported")

            for i = 0; i < seen_before.len; i++:
                if seen_before.ptr[i] == imported:
                    snprintf(msg, sizeof msg, "file \"%s\" is imported twice", the_import.import_statement.specified_path)
                    fail(the_import.location, msg)
            seen_before.append(imported)

            for imported_stmt = imported.ast.ptr; imported_stmt < imported.ast.end(); imported_stmt++:
                if imported_stmt.symbol() == NULL or not imported_stmt.symbol().public:
                    continue

                # Check if two imported files define something conflicting
                for old_imported = importer.available_symbols.ptr; old_imported < importer.available_symbols.end(); old_imported++:
                    if strcmp(old_imported.statement.symbol().name, imported_stmt.symbol().name) == 0:
                        snprintf(
                            msg,
                            sizeof(msg),
                            "files \"%s\" and \"%s\" cannot be imported into the same file, because they both define '%s'",
                            old_imported.the_import.specified_path,
                            the_import.import_statement.specified_path,
                            imported_stmt.symbol().name,
                        )
                        fail(the_import.location, msg)

                importer.available_symbols.append(AvailableSymbol{
                    statement = imported_stmt,
                    the_import = &the_import.import_statement,
                    import_location = the_import.location,
                })

        # Check if this file defines something that conflicts with an import
        for stmt = importer.ast.ptr; stmt < importer.ast.end(); stmt++:
            if stmt.symbol() == NULL:
                continue

            for old_imported = importer.available_symbols.ptr; old_imported < importer.available_symbols.end(); old_imported++:
                assert old_imported.the_import != NULL  # non-imported symbols not added yet
                if strcmp(old_imported.statement.symbol().name, stmt.symbol().name) == 0:
                    snprintf(
                        msg,
                        sizeof(msg),
                        "a %s named '%s' already exists (imported from \"%s\" on line %d)",
                        old_imported.statement.symbol().short_description(),
                        stmt.symbol().name,
                        old_imported.the_import.specified_path,
                        old_imported.import_location.lineno,
                    )
                    fail(stmt.location, msg)

    # We have now listed all imported symbols that will be available.
    for jou_file = global_compiler_state.jou_files.ptr; jou_file < global_compiler_state.jou_files.end(); jou_file++:
        # Add symbols defined in the file itself
        for stmt = jou_file.ast.ptr; stmt < jou_file.ast.end(); stmt++:
            if stmt.symbol() != NULL:
                jou_file.available_symbols.append(AvailableSymbol{statement = stmt})

        # We have now listed all imported that will be available. Set up hash
        # table for quick access to them.
        create_global_symbol_lookup_hash_table(jou_file)

    free(seen_before.ptr)


def typecheck_everything() -> None:
    make_imported_statements_available()
    typecheck_step1_global_symbols()
    typecheck_step2_class_members()
    typecheck_step3_function_and_method_bodies()


def build_and_analyze_all_uvgs() -> None:
    print_uvgs = global_compiler_state.args.verbosity >= 2
    for jou_file = global_compiler_state.jou_files.ptr; jou_file < global_compiler_state.jou_files.end(); jou_file++:
        if global_compiler_state.args.verbosity >= 1:
            printf("Building and analyzing UVGs for %s\n", jou_file.path)
        build_and_analyze_uvgs(jou_file, print_uvgs)


def tokenize_only() -> None:
    tokenize_result = tokenize(global_compiler_state.args.infile, NULL)
    print_tokens(tokenize_result.tokens)
    tokenize_result.free()

    fail_if_warnings_and_flag()


def parse_only() -> None:
    tokenize_result = tokenize(global_compiler_state.args.infile, NULL)
    ast = parse(tokenize_result.tokens, True)
    printf("===== AST for file \"%s\" =====\n", global_compiler_state.args.infile)
    for p = ast.ptr; p < ast.end(); p++:
        p.print()
    for p = ast.ptr; p < ast.end(); p++:
        p.free()
    free(ast.ptr)
    tokenize_result.free()
    fail_if_warnings_and_flag()


def uvg_only() -> None:
    tokenize_and_parse_all_files()
    typecheck_everything()

    mainfile = find_file(global_compiler_state.args.infile)
    assert mainfile != NULL
    build_and_analyze_uvgs(mainfile, True)


def check() -> None:
    tokenize_and_parse_all_files()
    typecheck_everything()
    build_and_analyze_all_uvgs()

    for jou_file = global_compiler_state.jou_files.ptr; jou_file < global_compiler_state.jou_files.end(); jou_file++:
        warn_about_unused(jou_file)

    # Check for missing main() as late as possible, so that other errors come first.
    # This way Jou users can work on other functions before main() function is written.
    mainfile = find_file(global_compiler_state.args.infile)
    assert mainfile != NULL
    if not defines_main(mainfile):
        fail(Location{path=mainfile.path}, "missing `main` function to execute the program")

    fail_if_warnings_and_flag()


def compile_to_object_files() -> None:
    check()
    init_global_target()

    needs_compiling = List[JouFile*]{}
    for jou_file = global_compiler_state.jou_files.ptr; jou_file < global_compiler_state.jou_files.end(); jou_file++:
        exists: bool
        assert jou_file.object_file_path == NULL
        jou_file.object_file_path = get_path_to_object_file_in_jou_compiled(jou_file, &exists)
        assert jou_file.object_file_path != NULL

        if exists:
            if global_compiler_state.args.verbosity >= 1:
                printf("Reusing previously compiled file: %s\n", jou_file.object_file_path)
        else:
            needs_compiling.append(jou_file)

    compile_to_object_files_in_parallel(needs_compiling)
    free(needs_compiling.ptr)


def compile_to_jou_compiled_and_run() -> int:
    compile_to_object_files()
    exepath = get_jou_compiled_exe_path()
    run_linker(exepath)
    ret = run_exe(exepath)
    free(exepath)
    return ret


def compile_to_outfile() -> None:
    assert global_compiler_state.args.outfile != NULL
    compile_to_object_files()
    run_linker(global_compiler_state.args.outfile)


def main(argc: int, argv: byte**) -> int:
    global_compiler_state.args = parse_command_line_args(argc, argv)
    global_compiler_state.stdlib_path = find_stdlib()
    init_types()

    ret = 0
    match global_compiler_state.args.mode:
        case CompilingMode.TokenizeOnly:
            tokenize_only()
        case CompilingMode.ParseOnly:
            parse_only()
        case CompilingMode.UvgOnly:
            uvg_only()
        case CompilingMode.Check:
            check()
            printf("Checked %d files.\n", global_compiler_state.jou_files.len as int)
        case CompilingMode.CompileToFile:
            compile_to_outfile()
        case CompilingMode.Run:
            ret = compile_to_jou_compiled_and_run()

    fail_if_warnings_and_flag()

    # not really necessary, but makes valgrind much happier
    global_compiler_state.free()

    return ret
