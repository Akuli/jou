import "stdlib/io.jou"
import "stdlib/list.jou"
import "stdlib/mem.jou"
import "stdlib/str.jou"
import "stdlib/process.jou"

import "./ast.jou"
import "./builders/hash_builder.jou"
import "./builders/llvm_builder.jou"
import "./builders/uvg_builder.jou"
import "./command_line_args.jou"
import "./errors_and_warnings.jou"
import "./evaluate.jou"
import "./llvm.jou"
import "./parser.jou"
import "./paths.jou"
import "./run.jou"
import "./state.jou"
import "./target.jou"
import "./token.jou"
import "./tokenizer.jou"
import "./typecheck/common.jou"
import "./typecheck/step1_create_types.jou"
import "./typecheck/step2_populate_types.jou"
import "./typecheck/step3_function_and_method_bodies.jou"
import "./types.jou"


def defines_main(ast: AstFile*) -> bool:
    for p = ast.body.ptr; p < ast.body.end(); p++:
        if p.kind == AstStatementKind.FunctionDef and p.function.types.signature.is_main_function():
            return True
    return False


def statement_conflicts_with_an_import(stmt: AstStatement*, importsym: ExportSymbol*) -> bool:
    match stmt.kind:
        case AstStatementKind.FunctionDeclare | AstStatementKind.FunctionDef:
            return (
                importsym.kind == ExportSymbolKind.Function
                and strcmp(importsym.name, stmt.function.ast_signature.name) == 0
            )
        case AstStatementKind.GlobalVariableDeclare | AstStatementKind.Const:
            return (
                (
                    importsym.kind == ExportSymbolKind.GlobalVar
                    and strcmp(importsym.name, stmt.global_var_declare.name) == 0
                ) or (
                    importsym.kind == ExportSymbolKind.Constant
                    and strcmp(importsym.name, stmt.const_statement.name) == 0
                )
            )
        case AstStatementKind.GlobalVariableDef:
            return (
                importsym.kind == ExportSymbolKind.GlobalVar
                and strcmp(importsym.name, stmt.global_var_def.name) == 0
            )
        case AstStatementKind.Class:
            return (
                (importsym.kind == ExportSymbolKind.Type or importsym.kind == ExportSymbolKind.GenericClass)
                and strcmp(importsym.name, stmt.classdef.name) == 0
            )
        case AstStatementKind.Enum:
            return (
                importsym.kind == ExportSymbolKind.Type
                and strcmp(importsym.name, stmt.enumdef.name) == 0
            )
        case AstStatementKind.Import | AstStatementKind.Link | AstStatementKind.Pass | AstStatementKind.Assert:
            return False
        case _:
            printf("%d\n", stmt.kind as int)
            stmt.print()
            assert False


def print_llvm_ir(module: LLVMModule*, is_optimized: bool) -> None:
    if is_optimized:
        opt_or_unopt = "Optimized"
    else:
        opt_or_unopt = "Unoptimized"

    len = 0 as int64
    filename = LLVMGetSourceFileName(module, &len)
    printf("===== %s LLVM IR for file \"%.*s\" =====\n", opt_or_unopt, len as int, filename)

    s = LLVMPrintModuleToString(module)
    puts(s)
    LLVMDisposeMessage(s)


def optimize(module: LLVMModule*, level: int) -> None:
    if global_compiler_state.args.verbosity >= 1:
        len = 0 as int64
        filename = LLVMGetSourceFileName(module, &len)
        printf("Optimizing %s (level %d)\n", filename, level)

    assert 1 <= level and level <= 3
    passes: byte[100]
    sprintf(passes, "default<O%d>", level)

    options = LLVMCreatePassBuilderOptions()
    error = LLVMRunPasses(module, passes, global_compiler_state.target.target_machine, options)
    LLVMDisposePassBuilderOptions(options)

    if error != NULL:
        msg = LLVMGetErrorMessage(error)
        fprintf(get_stderr(), "Optimizing with LLVM failed: %s\n", msg)
        fprintf(get_stderr(), "This is a bug. Please create an issue at https://github.com/Akuli/jou\n", msg)
        exit(1)

    if global_compiler_state.args.verbosity >= 2:
        print_llvm_ir(module, True)


declare rename(oldpath: byte*, newpath: byte*) -> int

def write_llvm_ir_to_file(mod: LLVMModule*, o_path: byte*) -> None:
    if global_compiler_state.args.verbosity >= 1:
        printf("Writing LLVM IR to %s\n", o_path)

    # If we want to create foo.o, first write to foo_temp.o.
    # This way we don't end up with a corrupted foo.o if the compiler is interrupted.
    # See also https://github.com/Akuli/jou/issues/873
    assert ends_with(o_path, ".o")
    o_path_2: byte*
    asprintf(&o_path_2, "%.*s_temp.o", (strlen(o_path) - 2) as int, o_path)

    error: byte* = NULL
    if LLVMTargetMachineEmitToFile(
        global_compiler_state.target.target_machine,
        mod,
        o_path_2,
        LLVMCodeGenFileType.ObjectFile,
        &error,
    ) != 0:
        assert error != NULL
        fprintf(get_stderr(), "failed to emit object file \"%s\": %s\n", o_path, error)
        exit(1)

    if rename(o_path_2, o_path) != 0:
        fprintf(get_stderr(), "renaming object file failed (%s --> %s)\n", o_path_2, o_path)
        exit(1)

    free(o_path_2)


def add_imported_symbol(jou_file: JouFile*, es: ExportSymbol*, imp: AstImport*) -> None:
    for p = jou_file.ast.body.ptr; p < jou_file.ast.body.end(); p++:
        if statement_conflicts_with_an_import(p, es):
            match es.kind:
                case ExportSymbolKind.Function:
                    wat = "function"
                case ExportSymbolKind.GlobalVar:
                    wat = "global variable"
                case ExportSymbolKind.Type:
                    wat = "type"
                case ExportSymbolKind.GenericClass:
                    wat = "generic class"
                case ExportSymbolKind.Constant:
                    wat = "constant"

            msg: byte[500]
            snprintf(msg, sizeof msg, "a %s named '%s' already exists", wat, es.name)
            fail(p.location, msg)

    match es.kind:
        case ExportSymbolKind.Function:
            jou_file.ast.types.add_function(&es.funcsignature, &imp.used)
        case ExportSymbolKind.Type:
            jou_file.ast.types.add_type(es.type, &imp.used)
        case ExportSymbolKind.GenericClass:
            jou_file.ast.types.add_generic_class(es.type, &imp.used)
        case ExportSymbolKind.GlobalVar:
            jou_file.ast.types.add_global_var(es.name, es.type, &imp.used)
        case ExportSymbolKind.Constant:
            jou_file.ast.types.add_constant(es.name, &es.constant, &imp.used)


def warn_about_unused(ast: AstFile*) -> None:
    msg: byte[500]

    for stmt = ast.body.ptr; stmt < ast.body.end(); stmt++:
        match stmt.kind:
            case AstStatementKind.Import:
                if not stmt.import_statement.used:
                    snprintf(msg, sizeof msg, "\"%s\" imported but not used", stmt.import_statement.specified_path)
                    show_warning(stmt.location, msg)
            case AstStatementKind.FunctionDef | AstStatementKind.FunctionDeclare:
                if stmt.kind == AstStatementKind.FunctionDeclare:
                    did_what = "declared"
                else:
                    did_what = "defined"

                f = &stmt.function
                if not f.public and not f.used and not f.types.signature.is_main_function():
                    sigstr = f.types.signature.to_string(False, False)
                    snprintf(msg, sizeof msg, "function %s %s but not used", sigstr, did_what)
                    free(sigstr)
                    show_warning(stmt.location, msg)
            case AstStatementKind.Enum:
                if not stmt.enumdef.public and not stmt.enumdef.used:
                    snprintf(msg, sizeof msg, "enum %s defined but not used", stmt.enumdef.name)
                    show_warning(stmt.location, msg)
            case AstStatementKind.GlobalVariableDef:
                if not stmt.global_var_def.public and not stmt.global_var_def.used:
                    snprintf(msg, sizeof msg, "global variable '%s' defined but not used", stmt.global_var_def.name)
                    show_warning(stmt.location, msg)
            case AstStatementKind.GlobalVariableDeclare:
                if not stmt.global_var_declare.public and not stmt.global_var_declare.used:
                    snprintf(msg, sizeof msg, "global variable '%s' declared but not used", stmt.global_var_declare.name)
                    show_warning(stmt.location, msg)
            case AstStatementKind.Class:
                if not stmt.classdef.public and not stmt.classdef.used:
                    snprintf(msg, sizeof msg, "class '%s' defined but not used", stmt.classdef.name)
                    show_warning(stmt.location, msg)
            case AstStatementKind.Const:
                if not stmt.const_statement.public and not stmt.const_statement.used:
                    snprintf(msg, sizeof msg, "constant '%s' defined but not used", stmt.const_statement.name)
                    show_warning(stmt.location, msg)
            case _:
                pass


def build_and_verify_llvm_ir(jou_file: JouFile*) -> LLVMModule*:
    if global_compiler_state.args.verbosity >= 1:
        printf("Building LLVM IR: %s\n", jou_file.path)
    mod = build_llvm_ir(&jou_file.ast)
    if global_compiler_state.args.verbosity >= 2:
        print_llvm_ir(mod, False)

    # If this fails, it is not just users writing dumb code, it is a bug in this compiler.
    # This compiler should always fail with an error elsewhere, or generate valid LLVM IR.
    LLVMVerifyModule(mod, LLVMVerifierFailureAction.AbortProcess, NULL)

    return mod


def find_existing_object_file_or_compile_to_object_file(jou_file: JouFile*) -> byte*:
    content_hash = build_content_hash(&jou_file.ast)
    exists: bool
    o_path = get_path_to_object_file_in_jou_compiled(jou_file.path, content_hash, &exists)

    if exists:
        if global_compiler_state.args.verbosity >= 1:
            printf("Reusing previously compiled file: %s\n", o_path)
    else:
        mod = build_and_verify_llvm_ir(jou_file)
        if global_compiler_state.args.optlevel != 0:
            optimize(mod, global_compiler_state.args.optlevel)
        write_llvm_ir_to_file(mod, o_path)
        LLVMDisposeModule(mod)

    return o_path


def check_imports_at_start_of_file(body: List[AstStatement]) -> None:
    seen_other = False
    for p = body.ptr; p < body.end(); p++:
        if p.kind == AstStatementKind.Import:
            if seen_other:
                fail(p.location, "imports must be in the beginning of the file")
        else:
            seen_other = True


def check_class_fields_before_methods(body: List[AstStatement]) -> None:
    for stmt = body.ptr; stmt < body.end(); stmt++:
        if stmt.kind == AstStatementKind.Class:
            seen_other = False
            for p = stmt.classdef.body.ptr; p < stmt.classdef.body.end(); p++:
                if p.kind == AstStatementKind.ClassField or p.kind == AstStatementKind.ClassUnion:
                    if seen_other:
                        fail(p.location, "class fields must be defined before methods")
                else:
                    seen_other = True


def find_file(path: byte*) -> JouFile*:
    for p = global_compiler_state.jou_files.ptr; p < global_compiler_state.jou_files.end(); p++:
        if strcmp(p.path, path) == 0:
            return p
    return NULL


def tokenize_and_parse(path: byte*, import_location: Location*) -> None:
    if find_file(path) != NULL:
        # already parsed
        return

    jou_file = JouFile{path = strdup(path)}
    assert jou_file.path != NULL

    if global_compiler_state.args.verbosity >= 1:
        printf("Tokenizing %s\n", path)
    tokens = tokenize(jou_file.path, import_location)

    if global_compiler_state.args.verbosity >= 2:
        print_tokens(tokens)

    if global_compiler_state.args.verbosity >= 1:
        printf("Parsing %s\n", path)
    jou_file.ast = parse(tokens)
    free_tokens(tokens)

    if strcmp(path, global_compiler_state.args.infile) == 0:
        jou_file.ast.is_main_file = True

    if global_compiler_state.args.verbosity >= 1:
        printf("Evaluating compile-time if statements in %s\n", path)
    evaluate_compile_time_if_statements(&jou_file.ast)

    if global_compiler_state.args.verbosity >= 2:
        jou_file.ast.print()

    check_imports_at_start_of_file(jou_file.ast.body)
    check_class_fields_before_methods(jou_file.ast.body)

    global_compiler_state.jou_files.append(jou_file)

    for stmt = jou_file.ast.body.ptr; stmt < jou_file.ast.body.end(); stmt++:
        if stmt.kind == AstStatementKind.Import:
            tokenize_and_parse(stmt.import_statement.resolved_path, &stmt.location)  # recursive call


def tokenize_and_parse_all_files() -> None:
    assert global_compiler_state.stdlib_path != NULL

    assert_fail_path: byte* = NULL
    asprintf(&assert_fail_path, "%s/_assert_fail.jou", global_compiler_state.stdlib_path)
    assert assert_fail_path != NULL
    tokenize_and_parse(assert_fail_path, NULL)
    free(assert_fail_path)

    tokenize_and_parse(global_compiler_state.args.infile, NULL)


# Each step of type checking produces exported symbols that other files can import.
# This method hands them over to the importing files.
def exports_to_imports(pending_exports: List[ExportSymbol]*) -> None:
    for to = global_compiler_state.jou_files.ptr; to < global_compiler_state.jou_files.end(); to++:
        seen_before = List[JouFile*]{}

        for stmt = to.ast.body.ptr; stmt < to.ast.body.end(); stmt++:
            if stmt.kind != AstStatementKind.Import:
                continue

            from = find_file(stmt.import_statement.resolved_path)
            assert from != NULL
            from_index = ((from as int64) - (global_compiler_state.jou_files.ptr as int64)) / sizeof(global_compiler_state.jou_files.ptr[0])

            if from == to:
                fail(stmt.location, "the file itself cannot be imported")

            for p = seen_before.ptr; p < seen_before.end(); p++:
                if *p == from:
                    msg: byte[500]
                    snprintf(msg, sizeof msg, "file \"%s\" is imported twice", stmt.import_statement.specified_path)
                    fail(stmt.location, msg)
            seen_before.append(from)

            for es = pending_exports[from_index].ptr; es < pending_exports[from_index].end(); es++:
                if global_compiler_state.args.verbosity >= 2:
                    match es.kind:
                        case ExportSymbolKind.Function:
                            kindstr = "function"
                        case ExportSymbolKind.GlobalVar:
                            kindstr = "global var"
                        case ExportSymbolKind.Type:
                            kindstr = "type"
                        case ExportSymbolKind.GenericClass:
                            kindstr = "generic class"
                        case ExportSymbolKind.Constant:
                            kindstr = "constant"
                    printf("Adding imported %s %s: %s --> %s\n",
                        kindstr, es.name, from.path, to.path)

                add_imported_symbol(to, es, &stmt.import_statement)

        free(seen_before.ptr)

    for i = 0; i < global_compiler_state.jou_files.len; i++:
        for es = pending_exports[i].ptr; es < pending_exports[i].end(); es++:
            es.free()
        free(pending_exports[i].ptr)
        pending_exports[i] = List[ExportSymbol]{}


def typecheck_all_files() -> None:
    if global_compiler_state.args.verbosity >= 1:
        printf("Type-checking...\n")

    pending_exports: List[ExportSymbol]* = malloc(sizeof(pending_exports[0]) * global_compiler_state.jou_files.len)
    assert pending_exports != NULL

    i = 0
    for p = global_compiler_state.jou_files.ptr; p < global_compiler_state.jou_files.end(); p++:
        if global_compiler_state.args.verbosity >= 1:
            printf("  step 1: %s\n", p.path)
        pending_exports[i++] = typecheck_step1_create_types(&p.ast)

    exports_to_imports(pending_exports)

    i = 0
    for p = global_compiler_state.jou_files.ptr; p < global_compiler_state.jou_files.end(); p++:
        if global_compiler_state.args.verbosity >= 1:
            printf("  step 2: %s\n", p.path)
        pending_exports[i++] = typecheck_step2_populate_types(&p.ast)

    exports_to_imports(pending_exports)

    for p = global_compiler_state.jou_files.ptr; p < global_compiler_state.jou_files.end(); p++:
        if global_compiler_state.args.verbosity >= 1:
            printf("  step 3: %s\n", p.path)
        typecheck_step3_function_and_method_bodies(&p.ast)
        if global_compiler_state.args.verbosity >= 3:
            # AST now contains types. If very verbose, print them.
            p.ast.print()

    free(pending_exports)


def build_and_analyze_all_uvgs() -> None:
    print_uvgs = global_compiler_state.args.verbosity >= 2
    for p = global_compiler_state.jou_files.ptr; p < global_compiler_state.jou_files.end(); p++:
        if global_compiler_state.args.verbosity >= 1:
            printf("Building and analyzing UVGs for %s\n", p.path)
        build_and_analyze_uvgs(&p.ast, print_uvgs)


# Linker flags come from:
#   - files with 'link' statements
#   - command-line --linker-flags argument
def collect_linker_flags() -> byte*:
    maxlen = 0 as int64
    maxlen += strlen("-lm") + 1  # TODO: delete this
    if global_compiler_state.args.linker_flags != NULL:
        maxlen += strlen(global_compiler_state.args.linker_flags) + 1
    for p = global_compiler_state.jou_files.ptr; p < global_compiler_state.jou_files.end(); p++:
        for stmt = p.ast.body.ptr; stmt < p.ast.body.end(); stmt++:
            if stmt.kind == AstStatementKind.Link:
                maxlen += strlen(stmt.link_statement.resolved_flags) + 1

    result: byte* = malloc(maxlen + 1)
    assert result != NULL
    strcpy(result, "")

    strcat(result, "-lm ")  # TODO: delete this
    if global_compiler_state.args.linker_flags != NULL:
        strcat(result, global_compiler_state.args.linker_flags)
        strcat(result, " ")
    for p = global_compiler_state.jou_files.ptr; p < global_compiler_state.jou_files.end(); p++:
        for stmt = p.ast.body.ptr; stmt < p.ast.body.end(); stmt++:
            if stmt.kind == AstStatementKind.Link:
                strcat(result, stmt.link_statement.resolved_flags)
                strcat(result, " ")

    return result


def tokenize_only() -> None:
    tokens = tokenize(global_compiler_state.args.infile, NULL)
    print_tokens(tokens)
    free_tokens(tokens)

    fail_if_warnings_and_flag()


def parse_only() -> None:
    tokens = tokenize(global_compiler_state.args.infile, NULL)
    ast = parse(tokens)
    ast.print()
    ast.free()
    free_tokens(tokens)
    fail_if_warnings_and_flag()


def uvg_only() -> None:
    tokenize_and_parse_all_files()
    typecheck_all_files()

    mainfile = find_file(global_compiler_state.args.infile)
    assert mainfile != NULL
    build_and_analyze_uvgs(&mainfile.ast, True)


def compile_to_object_files(linker_flags: byte**) -> List[byte*]:
    tokenize_and_parse_all_files()
    typecheck_all_files()
    build_and_analyze_all_uvgs()

    for p = global_compiler_state.jou_files.ptr; p < global_compiler_state.jou_files.end(); p++:
        warn_about_unused(&p.ast)

    init_target(&global_compiler_state.target)
    objpaths = List[byte*]{}
    for p = global_compiler_state.jou_files.ptr; p < global_compiler_state.jou_files.end(); p++:
        o_path = find_existing_object_file_or_compile_to_object_file(p)
        objpaths.append(o_path)

    *linker_flags = collect_linker_flags()

    # Check for missing main() as late as possible, so that other errors come first.
    # This way Jou users can work on other functions before main() function is written.
    mainfile = find_file(global_compiler_state.args.infile)
    assert mainfile != NULL
    if not defines_main(&mainfile.ast):
        fail(Location{path=mainfile.path}, "missing `main` function to execute the program")

    fail_if_warnings_and_flag()
    return objpaths


def compile_to_jou_compiled_and_run() -> None:
    linker_flags: byte*
    objpaths = compile_to_object_files(&linker_flags)

    exepath = get_jou_compiled_exe_path()
    run_linker(objpaths, exepath, linker_flags)
    run_exe(exepath)

    for p = objpaths.ptr; p < objpaths.end(); p++:
        free(*p)
    free(objpaths.ptr)
    free(linker_flags)
    free(exepath)


def compile_to_outfile() -> None:
    assert global_compiler_state.args.outfile != NULL

    linker_flags: byte*
    objpaths = compile_to_object_files(&linker_flags)

    run_linker(objpaths, global_compiler_state.args.outfile, linker_flags)

    for p = objpaths.ptr; p < objpaths.end(); p++:
        free(*p)
    free(objpaths.ptr)
    free(linker_flags)


def main(argc: int, argv: byte**) -> int:
    global_compiler_state.args = parse_command_line_args(argc, argv)
    global_compiler_state.stdlib_path = find_stdlib()
    init_types()

    if global_compiler_state.args.tokenize_only:
        tokenize_only()
    elif global_compiler_state.args.parse_only:
        parse_only()
    elif global_compiler_state.args.uvg_only:
        uvg_only()
    elif global_compiler_state.args.outfile == NULL:
        compile_to_jou_compiled_and_run()
    else:
        compile_to_outfile()

    fail_if_warnings_and_flag()

    # not really necessary, but makes valgrind much happier
    global_compiler_state.free()

    return 0
