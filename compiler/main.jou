import "stdlib/io.jou"
import "stdlib/process.jou"
import "stdlib/mem.jou"
import "stdlib/errno.jou"
import "stdlib/str.jou"

import "./build_cfg.jou"
import "./evaluate.jou"
import "./run.jou"
import "./codegen.jou"
import "./print.jou"
import "./llvm.jou"
import "./output.jou"
import "./typecheck.jou"
import "./target.jou"
import "./types.jou"
import "./free.jou"
import "./parser.jou"
import "./paths.jou"
import "./errors_and_warnings.jou"
import "./structs.jou"
import "./update.jou"
import "./tokenizer.jou"
import "./ast.jou"


def print_help(argv0: byte*) -> None:
    printf("Usage:\n")
    printf("  %s [-o OUTFILE] [-O0|-O1|-O2|-O3] [--verbose] [--linker-flags \"...\"] FILENAME\n", argv0)
    printf("  %s --help       # This message\n", argv0)
    printf("  %s --update     # Download and install the latest Jou\n", argv0)
    printf("\n")
    printf("Options:\n")
    printf("  -o OUTFILE       output an executable file, don't run the code\n")
    printf("  -O0/-O1/-O2/-O3  set optimization level (0 = no optimization, 1 = default, 3 = runs fastest)\n")
    printf("  -v / --verbose   display some progress information\n")
    printf("  -vv              display a lot of information about all compilation steps\n")
    printf("  --valgrind       use valgrind when running the code\n")
    printf("  --tokenize-only  display only the output of the tokenizer, don't do anything else\n")
    printf("  --parse-only     display only the AST (parse tree), don't do anything else\n")
    printf("  --linker-flags   appended to the linker command, so you can use external libraries\n")


def parse_arguments(argc: int, argv: byte**) -> None:
    memset(&command_line_args, 0, sizeof command_line_args)
    command_line_args.argv0 = argv[0]
    # Set default optimize to O1, user sets optimize will overwrite the default flag
    command_line_args.optlevel = 1

    if argc == 2 and strcmp(argv[1], "--help") == 0:
        print_help(argv[0])
        exit(0)

    if argc == 2 and strcmp(argv[1], "--update") == 0:
        update_jou_compiler()
        exit(0)

    i = 1
    while i < argc:
        if strcmp(argv[i], "--help") == 0 or strcmp(argv[i], "--update") == 0:
            fprintf(stderr, "%s: \"%s\" cannot be used with other arguments (try \"%s --help\")\n", argv[0], argv[i], argv[0])
            exit(2)
        elif strcmp(argv[i], "--verbose") == 0:
            command_line_args.verbosity++
            i++
        elif starts_with(argv[i], "-v") and strspn(&argv[i][1], "v") == strlen(argv[i])-1:
            command_line_args.verbosity += (strlen(argv[i]) as int) - 1
            i++
        elif strcmp(argv[i], "--valgrind") == 0:
            command_line_args.valgrind = True
            i++
        elif strcmp(argv[i], "--tokenize-only") == 0:
            if argc > 3:
                fprintf(stderr, "%s: --tokenize-only cannot be used together with other flags (try \"%s --help\")\n", argv[0], argv[0])
                exit(2)
            command_line_args.tokenize_only = True
            i++
        elif strcmp(argv[i], "--parse-only") == 0:
            if argc > 3:
                fprintf(stderr, "%s: --parse-only cannot be used together with other flags (try \"%s --help\")", argv[0], argv[0])
                exit(2)
            command_line_args.parse_only = True
            i++
        elif strcmp(argv[i], "--linker-flags") == 0:
            if command_line_args.linker_flags != NULL:
                fprintf(stderr, "%s: --linker-flags cannot be given multiple times (try \"%s --help\")\n", argv[0], argv[0])
                exit(2)

            if argc-i < 2:
                fprintf(stderr, "%s: there must be a string of flags after --linker-flags (try \"%s --help\")\n", argv[0], argv[0])
                exit(2)

            command_line_args.linker_flags = argv[i+1]
            i += 2
        elif (
            strlen(argv[i]) == 3
            and starts_with(argv[i], "-O")
            and argv[i][2] >= '0'
            and argv[i][2] <= '3'
        ):
            command_line_args.optlevel = argv[i][2] - '0'
            i++
        elif strcmp(argv[i], "-o") == 0:
            if argc-i < 2:
                fprintf(stderr, "%s: there must be a file name after -o", argv[0])
                fprintf(stderr, " (try \"%s --help\")\n", argv[0])
                exit(2)

            command_line_args.outfile = argv[i+1]
            if strlen(command_line_args.outfile) > 4 and ends_with(command_line_args.outfile, ".jou"):
                fprintf(stderr, "%s: the filename after -o should be an executable, not a Jou file (try \"%s --help\")\n", argv[0], argv[0])
                exit(2)
            i += 2
        elif argv[i][0] == '-':
            fprintf(stderr, "%s: unknown argument \"%s\"", argv[0], argv[i])
            fprintf(stderr, " (try \"%s --help\")\n", argv[0])
            exit(2)
        elif command_line_args.infile != NULL:
            fprintf(stderr, "%s: you can only pass one Jou file (try \"%s --help\")\n", argv[0], argv[0])
            exit(2)
        else:
            command_line_args.infile = argv[i++]

    if command_line_args.infile == NULL:
        fprintf(stderr, "%s: missing Jou file name (try \"%s --help\")\n", argv[0], argv[0])
        exit(2)


def open_the_file(path: byte*, import_location: Location*) -> FILE*:
    f = fopen(path, "rb")
    if f == NULL:
        msg: byte[500]
        if import_location != NULL:
            snprintf(msg, sizeof(msg), "cannot import from \"%s\": %s", path, strerror(get_errno()))
            fail(*import_location, msg)
        else:
            snprintf(msg, sizeof(msg), "cannot open file: %s", strerror(get_errno()))
            fail(Location{path=path}, msg)
    return f


def defines_main(ast: AstFile*) -> bool:
    for i = 0; i < ast->body.nstatements; i++:
        s = &ast->body.statements[i]
        if s->kind == AstStatementKind::Function and strcmp(s->function.signature.name, "main") == 0:
            return True
    return False


def statement_conflicts_with_an_import(stmt: AstStatement*, importsym: ExportSymbol*) -> bool:
    if stmt->kind == AstStatementKind::Function:
        return (
            importsym->kind == ExportSymbolKind::Function
            and strcmp(importsym->name, stmt->function.signature.name) == 0
        )

    if (
        stmt->kind == AstStatementKind::GlobalVariableDeclaration
        or stmt->kind == AstStatementKind::GlobalVariableDefinition
    ):
        return (
            importsym->kind == ExportSymbolKind::GlobalVar
            and strcmp(importsym->name, stmt->var_declaration.name) == 0
        )

    if stmt->kind == AstStatementKind::Class:
        return (
            importsym->kind == ExportSymbolKind::Type
            and strcmp(importsym->name, stmt->classdef.name) == 0
        )

    if stmt->kind == AstStatementKind::Enum:
        return (
            importsym->kind == ExportSymbolKind::Type
            and strcmp(importsym->name, stmt->enumdef.name) == 0
        )

    assert False  # TODO


class FileState:
    path: byte*
    ast: AstFile
    types: FileTypes
    module: LLVMModule*

    def add_imported_symbol(self, es: ExportSymbol*, imp: AstImport*) -> None:
        for i = 0; i < self->ast.body.nstatements; i++:
            if statement_conflicts_with_an_import(&self->ast.body.statements[i], es):
                if es->kind == ExportSymbolKind::Function:
                    wat = "function"
                elif es->kind == ExportSymbolKind::GlobalVar:
                    wat = "global variable"
                elif es->kind == ExportSymbolKind::Type:
                    wat = "type"
                else:
                    assert False

                msg: byte[500]
                snprintf(msg, sizeof msg, "a %s named '%s' already exists", wat, es->name)
                fail(self->ast.body.statements[i].location, msg)

        if es->kind == ExportSymbolKind::Function:
            self->types.functions = realloc(self->types.functions, sizeof(self->types.functions[0]) * (self->types.nfunctions + 1))
            assert self->types.functions != NULL
            self->types.functions[self->types.nfunctions++] = SignatureAndUsedPtr{
                signature = copy_signature(&es->funcsignature),
                usedptr = &imp->used,
            }
        elif es->kind == ExportSymbolKind::Type:
            self->types.types = realloc(self->types.types, sizeof(self->types.types[0]) * (self->types.ntypes + 1))
            assert self->types.types != NULL
            self->types.types[self->types.ntypes++] = TypeAndUsedPtr{
                type = es->type,
                usedptr = &imp->used,
            }
        elif es->kind == ExportSymbolKind::GlobalVar:
            g = GlobalVariable{
                type = es->type,
                usedptr = &imp->used,
            }

            assert strlen(es->name) < sizeof g.name
            strcpy(g.name, es->name)

            self->types.globals = realloc(self->types.globals, sizeof(self->types.globals[0]) * (self->types.nglobals + 1))
            assert self->types.globals != NULL
            self->types.globals[self->types.nglobals++] = g
        else:
            assert False


class CompileState:
    stdlib_path: byte*
    files: FileState*
    nfiles: int

    def find_file(self, path: byte*) -> FileState*:
        for fs = self->files; fs < &self->files[self->nfiles]; fs++:
            if strcmp(fs->path, path) == 0:
                return fs
        return NULL

    def parse(self, filename: byte*, import_location: Location*) -> None:
        if self->find_file(filename) != NULL:
            # already parsed
            return

        fs = FileState{path = strdup(filename)}

        if command_line_args.verbosity >= 1:
            printf("Tokenizing %s\n", filename)
        tokens = tokenize(fs.path, import_location)

        if command_line_args.verbosity >= 2:
            print_tokens(tokens)

        if command_line_args.verbosity >= 1:
            printf("Parsing %s\n", filename)
        fs.ast = parse(tokens, self->stdlib_path)
        free_tokens(tokens)

        # TODO: enable this
        if command_line_args.verbosity >= 1:
            printf("Evaluating compile-time if statements in %s\n", filename)
        evaluate_compile_time_if_statements(&fs.ast.body)

        if command_line_args.verbosity >= 2:
            fs.ast.print()

        # If it's not the file passed on command line, it shouldn't define main()
        if strcmp(filename, command_line_args.infile) != 0 and defines_main(&fs.ast):
            # Set error location to import, so user immediately knows which file
            # imports something that defines main().
            assert import_location != NULL
            fail(*import_location, "imported file should not have `main` function")

        self->files = realloc(self->files, sizeof(self->files[0]) * (self->nfiles + 1))
        assert self->files != NULL
        self->files[self->nfiles++] = fs

        for imp = fs.ast.imports; imp < &fs.ast.imports[fs.ast.nimports]; imp++:
            self->parse(imp->resolved_path, &imp->location)  # recursive call

    def parse_from_stdlib(self, filename: byte*) -> None:
        path = malloc(strlen(self->stdlib_path) + strlen(filename) + 123)
        sprintf(path, "%s/%s", self->stdlib_path, filename)
        self->parse(path, NULL)
        free(path)

    # Each stage of type checking produces exported symbols that other files can import.
    # This method hands them over to the importing files.
    def exports_to_imports(self, pending_exports: ExportSymbol**) -> None:
        for to = self->files; to < &self->files[self->nfiles]; to++:
            seen_before: FileState** = NULL
            seen_before_len = 0

            for imp = to->ast.imports; imp < &to->ast.imports[to->ast.nimports]; imp++:
                from = self->find_file(imp->resolved_path)
                assert from != NULL
                from_index = ((from as long) - (self->files as long)) / sizeof(self->files[0])

                if from == to:
                    fail(imp->location, "the file itself cannot be imported")

                for i = 0; i < seen_before_len; i++:
                    if seen_before[i] == from:
                        msg: byte[500]
                        snprintf(msg, sizeof msg, "file \"%s\" is imported twice", imp->specified_path)
                        fail(imp->location, msg)

                seen_before = realloc(seen_before, sizeof(seen_before[0]) * (seen_before_len + 1))
                seen_before[seen_before_len++] = from

                for es = pending_exports[from_index]; es->name[0] != '\0'; es++:
                    if command_line_args.verbosity >= 2:
                        if es->kind == ExportSymbolKind::Function:
                            kindstr = "function"
                        elif es->kind == ExportSymbolKind::GlobalVar:
                            kindstr = "global var"
                        elif es->kind == ExportSymbolKind::Type:
                            kindstr = "type"
                        else:
                            assert False
                        printf("Adding imported %s %s: %s --> %s\n",
                            kindstr, es->name, from->path, to->path)

                    to->add_imported_symbol(es, imp)

            free(seen_before)

        for i = 0; i < self->nfiles; i++:
            for es = pending_exports[i]; es->name[0] != '\0'; es++:
                free_export_symbol(es)
            free(pending_exports[i])
            pending_exports[i] = NULL

    def typecheck_all_files(self) -> None:
        if command_line_args.verbosity >= 1:
            printf("Type-checking...\n")

        pending_exports: ExportSymbol** = malloc(sizeof(pending_exports[0]) * self->nfiles)

        for i = 0; i < self->nfiles; i++:
            if command_line_args.verbosity >= 1:
                printf("  stage 1: %s\n", self->files[i].path)
            pending_exports[i] = typecheck_stage1_create_types(&self->files[i].types, &self->files[i].ast)

        self->exports_to_imports(pending_exports)

        for i = 0; i < self->nfiles; i++:
            if command_line_args.verbosity >= 1:
                printf("  stage 2: %s\n", self->files[i].path)
            pending_exports[i] = typecheck_stage2_populate_types(&self->files[i].types, &self->files[i].ast)

        self->exports_to_imports(pending_exports)

        for i = 0; i < self->nfiles; i++:
            if command_line_args.verbosity >= 1:
                printf("  stage 3: %s\n", self->files[i].path)
            typecheck_stage3_function_and_method_bodies(&self->files[i].types, &self->files[i].ast)

        free(pending_exports)


def optimize(module: LLVMModule*, level: int) -> None:
    assert 1 <= level and level <= 3

    pm = LLVMCreatePassManager()

    # The default settings should be fine for Jou because they work well for
    # C and C++, and Jou is quite similar to C.
    pmbuilder = LLVMPassManagerBuilderCreate()
    LLVMPassManagerBuilderSetOptLevel(pmbuilder, level)
    LLVMPassManagerBuilderPopulateModulePassManager(pmbuilder, pm)
    LLVMPassManagerBuilderDispose(pmbuilder)

    LLVMRunPassManager(pm, module)
    LLVMDisposePassManager(pm)


def compile_ast_to_object_file(fs: FileState*) -> byte*:
    if command_line_args.verbosity >= 1:
        printf("Building Control Flow Graphs: %s\n", fs->path)

    cfgfile = build_control_flow_graphs(&fs->ast, &fs->types)
    for imp = fs->ast.imports; imp < &fs->ast.imports[fs->ast.nimports]; imp++:
        if not imp->used:
            msg: byte[500]
            snprintf(msg, sizeof msg, "\"%s\" imported but not used", imp->specified_path)
            show_warning(imp->location, msg)

    if command_line_args.verbosity >= 2:
        print_control_flow_graphs(&cfgfile)

    # TODO: implement this
#    if command_line_args.verbosity >= 1:
#        printf("Analyzing CFGs: %s\n", fs->path)
#    simplify_control_flow_graphs(&cfgfile)
#    if command_line_args.verbosity >= 2:
#        print_control_flow_graphs(&cfgfile)

    if command_line_args.verbosity >= 1:
        printf("Building LLVM IR: %s\n", fs->path)

    mod = codegen(&cfgfile, &fs->types)
    # TODO: free the control flow graphs, this crashes for some reason
    #free_control_flow_graphs(&cfgfil

    if command_line_args.verbosity >= 2:
        print_llvm_ir(mod, False)

    # If this fails, it is not just users writing dumb code, it is a bug in this compiler.
    # This compiler should always fail with an error elsewhere, or generate valid LLVM IR.
    LLVMVerifyModule(mod, LLVMVerifierFailureAction::AbortProcess, NULL)

    if command_line_args.optlevel != 0:
        if command_line_args.verbosity >= 1:
            printf("Optimizing %s (level %d)\n", fs->path, command_line_args.optlevel)
        optimize(mod, command_line_args.optlevel)
        if command_line_args.verbosity >= 2:
            print_llvm_ir(mod, True)

    objpath = compile_to_object_file(mod)
    LLVMDisposeModule(mod)
    return objpath


def tokenize_only(path: byte*) -> None:
    tokens = tokenize(command_line_args.infile, NULL)
    print_tokens(tokens)
    free_tokens(tokens)


def parse_only(path: byte*, stdlib_path: byte*) -> None:
    tokens = tokenize(command_line_args.infile, NULL)
    ast = parse(tokens, stdlib_path)
    ast.print()
    ast.free()
    free_tokens(tokens)


def main(argc: int, argv: byte**) -> int:
    init_target()
    init_types()
    stdlib = find_stdlib()

    parse_arguments(argc, argv)

    if command_line_args.verbosity >= 2:
        printf("Target triple: %s\n", target.triple)
        printf("Data layout: %s\n", target.data_layout)

    if command_line_args.tokenize_only:
        tokenize_only(command_line_args.infile)
        return 0

    if command_line_args.parse_only:
        parse_only(command_line_args.infile, stdlib)
        return 0

    compst = CompileState{ stdlib_path = stdlib }

    # This part recursively finds and parses imported files.
    compst.parse_from_stdlib("_assert_fail.jou")
    if WINDOWS or MACOS or NETBSD:
        compst.parse_from_stdlib("_jou_startup.jou")
    compst.parse(command_line_args.infile, NULL)

    compst.typecheck_all_files()

    objpaths: byte** = calloc(sizeof objpaths[0], compst.nfiles + 1)
    for i = 0; i < compst.nfiles; i++:
        objpaths[i] = compile_ast_to_object_file(&compst.files[i])

    # Check for missing main() as late as possible, so that other errors come first.
    # This way Jou users can work on other functions before main() function is written.
    mainfile = compst.find_file(command_line_args.infile)
    assert mainfile != NULL
    if not defines_main(&mainfile->ast):
        fail(Location{path=mainfile->path, lineno=0}, "missing `main` function to execute the program")

    for fs = compst.files; fs < &compst.files[compst.nfiles]; fs++:
        fs->ast.free()
        free(fs->path)
        free_file_types(&fs->types)
    free(compst.files)
    free(stdlib)

    if command_line_args.outfile != NULL:
        exepath = strdup(command_line_args.outfile)
    else:
        exepath = get_default_exe_path()

    run_linker(objpaths, exepath)
    for i = 0; objpaths[i] != NULL; i++:
        free(objpaths[i])
    free(objpaths)

    ret = 0
    if command_line_args.outfile == NULL:
        if command_line_args.verbosity >= 1:
            printf("Run: %s\n", exepath)
        ret = run_exe(exepath, command_line_args.valgrind)

    free(exepath)

    # not really necessary, but makes valgrind much happier
    free_global_type_state()
    cleanup_target()

    return ret
