import "stdlib/assert.jou"
import "stdlib/io.jou"
import "stdlib/list.jou"
import "stdlib/mem.jou"
import "stdlib/str.jou"
import "stdlib/process.jou"

import "./ast.jou"
import "./builders/hash_builder.jou"
import "./builders/llvm_builder.jou"
import "./builders/uvg_builder.jou"
import "./command_line_args.jou"
import "./errors_and_warnings.jou"
import "./evaluate.jou"
import "./llvm.jou"
import "./parser.jou"
import "./paths.jou"
import "./run.jou"
import "./state.jou"
import "./target.jou"
import "./token.jou"
import "./tokenizer.jou"
import "./typecheck/step1_global_symbols.jou"
import "./typecheck/step2_class_members.jou"
import "./typecheck/step3_function_and_method_bodies.jou"
import "./types.jou"


def defines_main(jou_file: JouFile*) -> bool:
    for stmt = jou_file.ast.ptr; stmt < jou_file.ast.end(); stmt++:
        if stmt.kind == AstStatementKind.FunctionDef and stmt.symbol().signature.is_main_function():
            return True
    return False


def print_llvm_ir(module: LLVMModule*, is_optimized: bool) -> None:
    if is_optimized:
        opt_or_unopt = "Optimized"
    else:
        opt_or_unopt = "Unoptimized"

    len = 0 as int64
    filename = LLVMGetSourceFileName(module, &len)
    printf("===== %s LLVM IR for file \"%.*s\" =====\n", opt_or_unopt, len as int, filename)

    s = LLVMPrintModuleToString(module)
    puts(s)
    LLVMDisposeMessage(s)


def optimize(module: LLVMModule*, level: int) -> None:
    if global_compiler_state.args.verbosity >= 1:
        len = 0 as int64
        filename = LLVMGetSourceFileName(module, &len)
        printf("Optimizing %s (level %d)\n", filename, level)

    assert 1 <= level and level <= 3
    passes: byte[100]
    sprintf(passes, "default<O%d>", level)

    options = LLVMCreatePassBuilderOptions()
    error = LLVMRunPasses(module, passes, global_compiler_state.target.target_machine, options)
    LLVMDisposePassBuilderOptions(options)

    if error != NULL:
        msg = LLVMGetErrorMessage(error)
        fprintf(get_stderr(), "Optimizing with LLVM failed: %s\n", msg)
        fprintf(get_stderr(), "This is a bug. Please create an issue at https://github.com/Akuli/jou\n", msg)
        exit(1)

    if global_compiler_state.args.verbosity >= 2:
        print_llvm_ir(module, True)


declare rename(oldpath: byte*, newpath: byte*) -> int

def write_llvm_ir_to_file(mod: LLVMModule*, o_path: byte*) -> None:
    if global_compiler_state.args.verbosity >= 1:
        printf("Writing LLVM IR to %s\n", o_path)

    # If we want to create foo.o, first write to foo_temp.o.
    # This way we don't end up with a corrupted foo.o if the compiler is interrupted.
    # See also https://github.com/Akuli/jou/issues/873
    assert ends_with(o_path, ".o")
    o_path_2: byte*
    asprintf(&o_path_2, "%.*s_temp.o", (strlen(o_path) - 2) as int, o_path)

    error: byte* = NULL
    if LLVMTargetMachineEmitToFile(
        global_compiler_state.target.target_machine,
        mod,
        o_path_2,
        LLVMCodeGenFileType.ObjectFile,
        &error,
    ) != 0:
        assert error != NULL
        fprintf(get_stderr(), "failed to emit object file \"%s\": %s\n", o_path, error)
        exit(1)

    if rename(o_path_2, o_path) != 0:
        fprintf(get_stderr(), "renaming object file failed (%s --> %s)\n", o_path_2, o_path)
        exit(1)

    free(o_path_2)


def warn_about_unused(jou_file: JouFile*) -> None:
    msg: byte[500]

    for stmt = jou_file.ast.ptr; stmt < jou_file.ast.end(); stmt++:
        if stmt.kind == AstStatementKind.Import and not stmt.import_statement.used:
            snprintf(msg, sizeof msg, "\"%s\" imported but not used", stmt.import_statement.specified_path)
            show_warning(stmt.location, msg)
            continue

        if (
            stmt.kind == AstStatementKind.FunctionDef
            and stmt.function.symbol.signature.is_main_function()
        ):
            continue

        symbol = stmt.symbol()
        if symbol == NULL or symbol.public or symbol.used:
            continue

        match stmt.kind:
            case AstStatementKind.Enum:
                short_desc = "enum"
            case AstStatementKind.Class:
                short_desc = "class"
            case _:
                short_desc = symbol.short_description()

        match stmt.kind:
            case AstStatementKind.FunctionDeclare | AstStatementKind.GlobalVariableDeclare:
                snprintf(msg, sizeof(msg), "%s '%s' declared but not used", short_desc, symbol.name)
            case _:
                snprintf(msg, sizeof(msg), "%s '%s' defined but not used", short_desc, symbol.name)

        show_warning(stmt.location, msg)


def build_and_verify_llvm_ir(jou_file: JouFile*) -> LLVMModule*:
    if global_compiler_state.args.verbosity >= 1:
        printf("Building LLVM IR: %s\n", jou_file.path)
    mod = build_llvm_ir(jou_file)
    if global_compiler_state.args.verbosity >= 2:
        print_llvm_ir(mod, False)

    # If this fails, it is not just users writing dumb code, it is a bug in this compiler.
    # This compiler should always fail with an error elsewhere, or generate valid LLVM IR.
    LLVMVerifyModule(mod, LLVMVerifierFailureAction.AbortProcess, NULL)

    return mod


def find_existing_object_file_or_compile_to_object_file(jou_file: JouFile*) -> byte*:
    content_hash = build_content_hash(jou_file)
    exists: bool
    o_path = get_path_to_object_file_in_jou_compiled(jou_file.path, content_hash, &exists)

    if exists:
        if global_compiler_state.args.verbosity >= 1:
            printf("Reusing previously compiled file: %s\n", o_path)
    else:
        mod = build_and_verify_llvm_ir(jou_file)
        if global_compiler_state.args.optlevel != 0:
            optimize(mod, global_compiler_state.args.optlevel)
        write_llvm_ir_to_file(mod, o_path)
        LLVMDisposeModule(mod)

    return o_path


def check_imports_at_start_of_file(body: List[AstStatement]) -> None:
    seen_other = False
    for stmt = body.ptr; stmt < body.end(); stmt++:
        if stmt.kind == AstStatementKind.Import:
            if seen_other:
                fail(stmt.location, "imports must be in the beginning of the file")
        else:
            seen_other = True


def check_class_fields_before_methods(body: List[AstStatement]) -> None:
    for stmt = body.ptr; stmt < body.end(); stmt++:
        if stmt.kind == AstStatementKind.Class:
            seen_other = False
            for p = stmt.classdef.body.ptr; p < stmt.classdef.body.end(); p++:
                if p.kind == AstStatementKind.ClassField or p.kind == AstStatementKind.ClassUnion:
                    if seen_other:
                        fail(p.location, "class fields must be defined before methods")
                else:
                    seen_other = True


def check_duplicate_defining(body: List[AstStatement]) -> None:
    msg: byte[300]

    for stmt1 = body.ptr; stmt1 < body.end(); stmt1++:
        for stmt2 = &stmt1[1]; stmt2 < body.end(); stmt2++:
            if (
                stmt1.symbol() != NULL
                and stmt2.symbol() != NULL
                and strcmp(stmt1.symbol().name, stmt2.symbol().name) == 0
            ):
                snprintf(
                    msg,
                    sizeof(msg),
                    "a %s named '%s' already exists (defined on line %d)",
                    stmt1.symbol().short_description(),
                    stmt1.symbol().name,
                    stmt1.location.lineno,
                )
                fail(stmt2.location, msg)

    # Special-casing for the special constants, because they don't come from anything in AST
    for stmt = body.ptr; stmt < body.end(); stmt++:
        if stmt.symbol() != NULL and get_special_constant(stmt.symbol().name) != NULL:
            snprintf(msg, sizeof(msg), "a special constant named '%s' already exists", stmt.symbol().name)
            fail(stmt.location, msg)


def find_file(path: byte*) -> JouFile*:
    for p = global_compiler_state.jou_files.ptr; p < global_compiler_state.jou_files.end(); p++:
        if strcmp(p.path, path) == 0:
            return p
    return NULL


def tokenize_and_parse(path: byte*, import_location: Location*) -> None:
    if find_file(path) != NULL:
        # already parsed
        return

    jou_file = JouFile{
        path = strdup(path),
        is_main_file = (strcmp(path, global_compiler_state.args.infile) == 0),
    }
    assert jou_file.path != NULL

    if global_compiler_state.args.verbosity >= 1:
        printf("Tokenizing %s\n", path)
    tokens = tokenize(jou_file.path, import_location)

    if global_compiler_state.args.verbosity >= 2:
        print_tokens(tokens)

    if global_compiler_state.args.verbosity >= 1:
        printf("Parsing %s\n", path)
    jou_file.ast = parse(tokens)
    free_tokens(tokens)

    if global_compiler_state.args.verbosity >= 1:
        printf("Evaluating compile-time if statements in %s\n", path)
    evaluate_compile_time_if_statements(&jou_file)

    if global_compiler_state.args.verbosity >= 2:
        printf("===== AST for file \"%s\" =====\n", path)
        for p = jou_file.ast.ptr; p < jou_file.ast.end(); p++:
            p.print()

    check_imports_at_start_of_file(jou_file.ast)
    check_class_fields_before_methods(jou_file.ast)
    check_duplicate_defining(jou_file.ast)

    global_compiler_state.jou_files.append(jou_file)

    for stmt = jou_file.ast.ptr; stmt < jou_file.ast.end(); stmt++:
        if stmt.kind == AstStatementKind.Import:
            tokenize_and_parse(stmt.import_statement.resolved_path, &stmt.location)  # recursive call


def tokenize_and_parse_all_files() -> None:
    assert global_compiler_state.args.infile != NULL
    tokenize_and_parse(global_compiler_state.args.infile, NULL)


# Stores pointers to public statements from imported files into the file where
# they should now be accessible due to import.
#
# Must be done after parsing all files and evaluating compile-time if statements:
#   - This assumes that no more Jou files will be discovered afterwards.
#   - This doesn't e.g. look inside `if` statements when looping through @public things.
def make_imported_statements_available() -> None:
    if global_compiler_state.args.verbosity >= 1:
        printf("Making imported statements available...\n")

    msg: byte[500]
    seen_before = List[JouFile*]{}

    for importer = global_compiler_state.jou_files.ptr; importer < global_compiler_state.jou_files.end(); importer++:
        seen_before.len = 0

        for the_import = importer.ast.ptr; the_import < importer.ast.end(); the_import++:
            if the_import.kind != AstStatementKind.Import:
                continue

            imported = find_file(the_import.import_statement.resolved_path)
            assert imported != NULL

            if importer == imported:
                fail(the_import.location, "the file itself cannot be imported")

            for i = 0; i < seen_before.len; i++:
                if seen_before.ptr[i] == imported:
                    snprintf(msg, sizeof msg, "file \"%s\" is imported twice", the_import.import_statement.specified_path)
                    fail(the_import.location, msg)
            seen_before.append(imported)

            for imported_stmt = imported.ast.ptr; imported_stmt < imported.ast.end(); imported_stmt++:
                if imported_stmt.symbol() == NULL or not imported_stmt.symbol().public:
                    continue

                # Check if two imported files define something conflicting
                for old_imported = importer.imported_from_other_files.ptr; old_imported < importer.imported_from_other_files.end(); old_imported++:
                    if strcmp(old_imported.statement_in_other_file.symbol().name, imported_stmt.symbol().name) == 0:
                        snprintf(
                            msg,
                            sizeof(msg),
                            "files \"%s\" and \"%s\" cannot be imported into the same file, because they both define '%s'",
                            old_imported.the_import.specified_path,
                            the_import.import_statement.specified_path,
                            imported_stmt.symbol().name,
                        )
                        fail(the_import.location, msg)

                importer.imported_from_other_files.append(Imported{
                    statement_in_other_file = imported_stmt,
                    the_import = &the_import.import_statement,
                    import_location = the_import.location,
                })

        # Check if this file defines something that conflicts with an import
        for stmt = importer.ast.ptr; stmt < importer.ast.end(); stmt++:
            if stmt.symbol() == NULL:
                continue

            for old_imported = importer.imported_from_other_files.ptr; old_imported < importer.imported_from_other_files.end(); old_imported++:
                if strcmp(old_imported.statement_in_other_file.symbol().name, stmt.symbol().name) == 0:
                    snprintf(
                        msg,
                        sizeof(msg),
                        "a %s named '%s' already exists (imported from \"%s\" on line %d)",
                        old_imported.statement_in_other_file.symbol().short_description(),
                        stmt.symbol().name,
                        old_imported.the_import.specified_path,
                        old_imported.import_location.lineno,
                    )
                    fail(stmt.location, msg)

    free(seen_before.ptr)


def typecheck_everything() -> None:
    make_imported_statements_available()
    typecheck_step1_global_symbols()
    typecheck_step2_class_members()
    typecheck_step3_function_and_method_bodies()


def build_and_analyze_all_uvgs() -> None:
    print_uvgs = global_compiler_state.args.verbosity >= 2
    for jou_file = global_compiler_state.jou_files.ptr; jou_file < global_compiler_state.jou_files.end(); jou_file++:
        if global_compiler_state.args.verbosity >= 1:
            printf("Building and analyzing UVGs for %s\n", jou_file.path)
        build_and_analyze_uvgs(jou_file, print_uvgs)


# Linker flags come from:
#   - files with 'link' statements
#   - command-line --linker-flags argument
def collect_linker_flags() -> byte*:
    maxlen = 0 as int64
    maxlen += strlen("-lm") + 1  # TODO: delete this
    if global_compiler_state.args.linker_flags != NULL:
        maxlen += strlen(global_compiler_state.args.linker_flags) + 1
    for jou_file = global_compiler_state.jou_files.ptr; jou_file < global_compiler_state.jou_files.end(); jou_file++:
        for stmt = jou_file.ast.ptr; stmt < jou_file.ast.end(); stmt++:
            if stmt.kind == AstStatementKind.Link:
                maxlen += strlen(stmt.link_statement.resolved_flags) + 1

    result: byte* = malloc(maxlen + 1)
    assert result != NULL
    strcpy(result, "")

    strcat(result, "-lm ")  # TODO: delete this
    if global_compiler_state.args.linker_flags != NULL:
        strcat(result, global_compiler_state.args.linker_flags)
        strcat(result, " ")
    for jou_file = global_compiler_state.jou_files.ptr; jou_file < global_compiler_state.jou_files.end(); jou_file++:
        for stmt = jou_file.ast.ptr; stmt < jou_file.ast.end(); stmt++:
            if stmt.kind == AstStatementKind.Link:
                strcat(result, stmt.link_statement.resolved_flags)
                strcat(result, " ")

    return result


def tokenize_only() -> None:
    tokens = tokenize(global_compiler_state.args.infile, NULL)
    print_tokens(tokens)
    free_tokens(tokens)

    fail_if_warnings_and_flag()


def parse_only() -> None:
    tokens = tokenize(global_compiler_state.args.infile, NULL)
    ast = parse(tokens)
    printf("===== AST for file \"%s\" =====\n", global_compiler_state.args.infile)
    for p = ast.ptr; p < ast.end(); p++:
        p.print()
    for p = ast.ptr; p < ast.end(); p++:
        p.free()
    free(ast.ptr)
    free_tokens(tokens)
    fail_if_warnings_and_flag()


def uvg_only() -> None:
    tokenize_and_parse_all_files()
    typecheck_everything()

    mainfile = find_file(global_compiler_state.args.infile)
    assert mainfile != NULL
    build_and_analyze_uvgs(mainfile, True)


def compile_to_object_files(linker_flags: byte**) -> List[byte*]:
    tokenize_and_parse_all_files()
    typecheck_everything()
    build_and_analyze_all_uvgs()

    for jou_file = global_compiler_state.jou_files.ptr; jou_file < global_compiler_state.jou_files.end(); jou_file++:
        warn_about_unused(jou_file)

    init_target(&global_compiler_state.target)
    objpaths = List[byte*]{}
    for jou_file = global_compiler_state.jou_files.ptr; jou_file < global_compiler_state.jou_files.end(); jou_file++:
        o_path = find_existing_object_file_or_compile_to_object_file(jou_file)
        objpaths.append(o_path)

    *linker_flags = collect_linker_flags()

    # Check for missing main() as late as possible, so that other errors come first.
    # This way Jou users can work on other functions before main() function is written.
    mainfile = find_file(global_compiler_state.args.infile)
    assert mainfile != NULL
    if not defines_main(mainfile):
        fail(Location{path=mainfile.path}, "missing `main` function to execute the program")

    fail_if_warnings_and_flag()
    return objpaths


def compile_to_jou_compiled_and_run() -> None:
    linker_flags: byte*
    objpaths = compile_to_object_files(&linker_flags)

    exepath = get_jou_compiled_exe_path()
    run_linker(objpaths, exepath, linker_flags)
    run_exe(exepath)

    for p = objpaths.ptr; p < objpaths.end(); p++:
        free(*p)
    free(objpaths.ptr)
    free(linker_flags)
    free(exepath)


def compile_to_outfile() -> None:
    assert global_compiler_state.args.outfile != NULL

    linker_flags: byte*
    objpaths = compile_to_object_files(&linker_flags)

    run_linker(objpaths, global_compiler_state.args.outfile, linker_flags)

    for p = objpaths.ptr; p < objpaths.end(); p++:
        free(*p)
    free(objpaths.ptr)
    free(linker_flags)


def main(argc: int, argv: byte**) -> int:
    global_compiler_state.args = parse_command_line_args(argc, argv)
    global_compiler_state.stdlib_path = find_stdlib()
    init_types()

    match global_compiler_state.args.mode:
        case CompilingMode.TokenizeOnly:
            tokenize_only()
        case CompilingMode.ParseOnly:
            parse_only()
        case CompilingMode.UvgOnly:
            uvg_only()
        case CompilingMode.Run:
            compile_to_jou_compiled_and_run()
        case CompilingMode.CompileToFile:
            compile_to_outfile()
        case CompilingMode.Check:
            assert False  # TODO: implement

    fail_if_warnings_and_flag()

    # not really necessary, but makes valgrind much happier
    global_compiler_state.free()

    return 0
