# This file is used to calculate 64-bit hashes. They are used to check whether
# source files have changed so that we need to recompile.
#
# The hash algorithm we use is FNV-1a:
# https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
# It is super easy to implement. We use the 64-bit variant to get a reasonably
# low probability for collisions.
#
# Of course, this is not cryptographically secure, but it doesn't matter for a
# compiler: if someone can place whatever they want into `jou_compiled`, you're
# doomed anyway :)


# TODO: xor should be built in to language, not implemented here
def xor_bytes(a: byte, b: byte) -> byte:
    result = 0
    power_of_two = 1

    while a != 0 or b != 0:
        if a % 2 != b % 2:
            result += power_of_two
        a /= 2 as byte
        b /= 2 as byte
        power_of_two *= 2

    return result as byte


# Do not instantiate this as `Hash{}`, that uses wrong initial value.
# Use new_hash() function.
@public
class Hash:
    hash: long
    created_correctly: bool

    # Add data to hash
    def add_bytes(self, data: byte*, len: long) -> None:
        assert self->created_correctly  # If this fails, use new_hash() function
        for i = 0L; i < len; i++:
            (&self->hash as byte*)[0] = xor_bytes(self->hash as byte, data[i])
            self->hash *= 1099511628211L

    def add_string(self, s: byte*) -> None:
        self->add_bytes(s, strlen(s))

    def add_int(self, i: int) -> None:
        self->add_bytes(&i as byte*, sizeof(i))

    def add_long(self, l: long) -> None:
        self->add_bytes(&l as byte*, sizeof(l))


@public
def new_hash() -> Hash:
    h: long = 0
    # Hash of empty data
    # Set value to cb f2 9c e4 84 22 23 25 (assumes little endian)
    # TODO: not possible to put this in a const
    (&h as byte*)[0] = 0x25 as byte
    (&h as byte*)[1] = 0x23 as byte
    (&h as byte*)[2] = 0x22 as byte
    (&h as byte*)[3] = 0x84 as byte
    (&h as byte*)[4] = 0xe4 as byte
    (&h as byte*)[5] = 0x9c as byte
    (&h as byte*)[6] = 0xf2 as byte
    (&h as byte*)[7] = 0xcb as byte
    return Hash{hash = h, created_correctly = True}
