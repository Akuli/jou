import "stdlib/ascii.jou"
import "stdlib/str.jou"
import "stdlib/io.jou"
import "stdlib/mem.jou"
import "./token.jou"
import "./ast.jou"
import "./errors_and_warnings.jou"
import "./paths.jou"


# arity = number of operands, e.g. 2 for a binary operator such as "+"
#
# This cannot be used for ++ and --, because with them we can't know the kind from
# just the token (e.g. ++ could mean pre-increment or post-increment).
def build_operator_expression(t: Token*, arity: int, operands: AstExpression*) -> AstExpression:
    assert arity == 1 or arity == 2
    nbytes = arity * sizeof operands[0]
    ptr = malloc(nbytes)
    memcpy(ptr, operands, nbytes)

    result = AstExpression{location = t->location, operands = ptr}

    if t->is_operator("&"):
        assert arity == 1
        result.kind = AstExpressionKind.AddressOf
    elif t->is_operator("["):
        assert arity == 2
        result.kind = AstExpressionKind.Indexing
    elif t->is_operator("=="):
        assert arity == 2
        result.kind = AstExpressionKind.Eq
    elif t->is_operator("!="):
        assert arity == 2
        result.kind = AstExpressionKind.Ne
    elif t->is_operator(">"):
        assert arity == 2
        result.kind = AstExpressionKind.Gt
    elif t->is_operator(">="):
        assert arity == 2
        result.kind = AstExpressionKind.Ge
    elif t->is_operator("<"):
        assert arity == 2
        result.kind = AstExpressionKind.Lt
    elif t->is_operator("<="):
        assert arity == 2
        result.kind = AstExpressionKind.Le
    elif t->is_operator("+"):
        assert arity == 2
        result.kind = AstExpressionKind.Add
    elif t->is_operator("-"):
        if arity == 2:
            result.kind = AstExpressionKind.Sub
        else:
            result.kind = AstExpressionKind.Negate
    elif t->is_operator("*"):
        if arity == 2:
            result.kind = AstExpressionKind.Mul
        else:
            result.kind = AstExpressionKind.Dereference
    elif t->is_operator("/"):
        assert arity == 2
        result.kind = AstExpressionKind.Div
    elif t->is_operator("%"):
        assert arity == 2
        result.kind = AstExpressionKind.Mod
    elif t->is_keyword("and"):
        assert arity == 2
        result.kind = AstExpressionKind.And
    elif t->is_keyword("or"):
        assert arity == 2
        result.kind = AstExpressionKind.Or
    elif t->is_keyword("not"):
        assert arity == 1
        result.kind = AstExpressionKind.Not
    else:
        assert False

    assert result.get_arity() == arity
    return result

# reverse code golfing: https://xkcd.com/1960/
def determine_the_kind_of_a_statement_that_starts_with_an_expression(
    this_token_is_after_that_initial_expression: Token*
) -> AstStatementKind:
    if this_token_is_after_that_initial_expression->is_operator("="):
        return AstStatementKind.Assign
    if this_token_is_after_that_initial_expression->is_operator("+="):
        return AstStatementKind.InPlaceAdd
    if this_token_is_after_that_initial_expression->is_operator("-="):
        return AstStatementKind.InPlaceSub
    if this_token_is_after_that_initial_expression->is_operator("*="):
        return AstStatementKind.InPlaceMul
    if this_token_is_after_that_initial_expression->is_operator("/="):
        return AstStatementKind.InPlaceDiv
    if this_token_is_after_that_initial_expression->is_operator("%="):
        return AstStatementKind.InPlaceMod
    return AstStatementKind.ExpressionStatement

class MemberInfo:
    kind: byte*
    name: byte[100]
    name_location: Location

def check_class_for_duplicate_names(classdef: AstClassDef*) -> None:
    n = 0
    for i = 0; i < classdef->nmembers; i++:
        member = &classdef->members[i]
        # We will make a separate MemberInfo for each union field
        if member->kind == AstClassMemberKind.Union:
            n += member->union_fields.nfields
        else:
            n++

    infos: MemberInfo* = malloc(n * sizeof infos[0] * 1000)
    destptr: MemberInfo* = infos

    for i = 0; i < classdef->nmembers; i++:
        member = &classdef->members[i]
        if member->kind == AstClassMemberKind.Field:
            *destptr++ = MemberInfo{
                kind = "a field",
                name = member->field.name,
                name_location = member->field.name_location,
            }
        elif member->kind == AstClassMemberKind.Union:
            for k = 0; k < member->union_fields.nfields; k++:
                *destptr++ = MemberInfo{
                    kind = "a union member",
                    name = member->union_fields.fields[k].name,
                    name_location = member->union_fields.fields[k].name_location,
                }
        elif member->kind == AstClassMemberKind.Method:
            *destptr++ = MemberInfo{
                kind = "a method",
                name = member->method.signature.name,
                name_location = member->method.signature.name_location,
            }
        else:
            assert False

    assert destptr == &infos[n]

    for p1 = infos; p1 < destptr; p1++:
        for p2 = &p1[1]; p2 < destptr; p2++:
            if strcmp(p1->name, p2->name) == 0:
                message: byte[500]
                snprintf(
                    message, sizeof message,
                    "class %s already has %s named '%s'",
                    classdef->name, p1->kind, p1->name,
                )
                fail(p2->name_location, message)

    free(infos)


# TODO: this function is just bad...
def read_assertion_from_file(start: Location, end: Location) -> byte*:
    assert start.path == end.path

    f = fopen(start.path, "rb")
    assert f != NULL

    line: byte[1024]
    lineno = 1
    while lineno < start.lineno:
        assert fgets(line, sizeof(line) as int, f) != NULL
        lineno++

    result: byte* = malloc(2000 * (end.lineno - start.lineno + 1))
    result[0] = '\0'

    while lineno <= end.lineno:
        assert fgets(line, sizeof(line) as int, f) != NULL
        lineno++

        # TODO: strings containing '#' ... so much wrong with dis
        if strstr(line, "#") != NULL:
            *strstr(line, "#") = '\0'
        trim_ascii_whitespace(line)

        # Add spaces between lines, but not after '(' or before ')'
        if not starts_with(line, ")") and not ends_with(result, "("):
            strcat(result, " ")
        strcat(result, line)

    fclose(f)

    trim_ascii_whitespace(result)
    if starts_with(result, "assert"):
        memmove(result, &result[6], strlen(&result[6]) + 1)
        trim_ascii_whitespace(result)

    return result


class Parser:
    tokens: Token*
    stdlib_path: byte*
    is_parsing_method_body: bool

    def eat_newline(self) -> None:
        if self->tokens->kind != TokenKind.Newline:
            self->tokens->fail_expected_got("end of line")
        self->tokens++

    def parse_import(self) -> AstImport:
        assert self->tokens->is_keyword("import")
        import_keyword = self->tokens++

        path_token = self->tokens++
        if path_token->kind != TokenKind.String:
            path_token->fail_expected_got("a string to specify the file name")

        self->eat_newline()

        if starts_with(path_token->long_string, "stdlib/"):
            # Starts with stdlib --> import from where stdlib actually is
            tmp = NULL
            part1 = self->stdlib_path
            part2 = &path_token->long_string[7]
        elif starts_with(path_token->long_string, "."):
            # Relative to directory where the file is
            tmp = strdup(path_token->location.path)
            part1 = dirname(tmp)
            part2 = path_token->long_string
        else:
            fail(
                path_token->location,
                "import path must start with 'stdlib/' (standard-library import) or a dot (relative import)"
            )

        # 1 for slash, 1 for \0, 1 for fun
        path = malloc(strlen(part1) + strlen(part2) + 3)
        sprintf(path, "%s/%s", part1, part2)
        free(tmp)

        simplify_path(path)
        return AstImport{
            location = import_keyword->location,
            specified_path = strdup(path_token->long_string),
            resolved_path = path,
        }

    def parse_type(self) -> AstType:
        if not (
            self->tokens->kind == TokenKind.Name
            or self->tokens->is_keyword("None")
            or self->tokens->is_keyword("void")
            or self->tokens->is_keyword("noreturn")
            or self->tokens->is_keyword("short")
            or self->tokens->is_keyword("int")
            or self->tokens->is_keyword("long")
            or self->tokens->is_keyword("byte")
            or self->tokens->is_keyword("float")
            or self->tokens->is_keyword("double")
            or self->tokens->is_keyword("bool")
        ):
            self->tokens->fail_expected_got("a type")

        result = AstType{
            kind = AstTypeKind.Named,
            location = self->tokens->location,
            name = self->tokens->short_string,
        }
        self->tokens++

        while self->tokens->is_operator("*") or self->tokens->is_operator("["):
            p: AstType* = malloc(sizeof *p)
            *p = result

            if self->tokens->is_operator("*"):
                result = AstType{
                    location = (self->tokens++)->location,  # TODO: shouldn't need all the parentheses
                    kind = AstTypeKind.Pointer,
                    value_type = p,
                }
            else:
                location = (self->tokens++)->location

                len_expression: AstExpression* = malloc(sizeof *len_expression)
                *len_expression = self->parse_expression()

                if not self->tokens->is_operator("]"):
                    self->tokens->fail_expected_got("a ']' to end the array size")
                self->tokens++

                result = AstType{
                    location = location,
                    kind = AstTypeKind.Array,
                    array = AstArrayType{
                        member_type = p,
                        length = len_expression,
                    }
                }

        return result

    def parse_name_type_value(self, expected_what_for_name: byte*) -> AstNameTypeValue:
        if self->tokens->kind != TokenKind.Name:
            assert expected_what_for_name != NULL
            self->tokens->fail_expected_got(expected_what_for_name)

        result = AstNameTypeValue{name = self->tokens->short_string, name_location = self->tokens->location}
        self->tokens++

        if not self->tokens->is_operator(":"):
            self->tokens->fail_expected_got("':' and a type after it (example: \"foo: int\")")
        self->tokens++
        result.type = self->parse_type()

        if self->tokens->is_operator("="):
            self->tokens++
            p: AstExpression* = malloc(sizeof *p)
            *p = self->parse_expression()
            result.value = p

        return result

    def parse_function_or_method_signature(self, is_method: bool) -> AstSignature:
        if self->tokens->kind != TokenKind.Name:
            if is_method:
                self->tokens->fail_expected_got("a method name")
            else:
                self->tokens->fail_expected_got("a function name")

        result = AstSignature{
            name_location = self->tokens->location,
            name = self->tokens->short_string,
        }
        self->tokens++

        if not self->tokens->is_operator("("):
            self->tokens->fail_expected_got("a '(' to denote the start of arguments")
        self->tokens++

        used_self = False
        while not self->tokens->is_operator(")"):
            if result.takes_varargs:
                fail(self->tokens->location, "if '...' is used, it must be the last parameter")

            if self->tokens->is_operator("..."):
                result.takes_varargs = True
                self->tokens++

            elif self->tokens->is_keyword("self"):
                if not is_method:
                    fail(self->tokens->location, "'self' cannot be used here")

                self_arg = AstNameTypeValue{
                    name = "self",
                    name_location = self->tokens->location,
                }
                self->tokens++

                if self->tokens->is_operator(":"):
                    self->tokens++
                    self_arg.type = self->parse_type()

                result.args = realloc(result.args, sizeof result.args[0] * (result.nargs+1))
                result.args[result.nargs++] = self_arg
                used_self = True

            else:
                arg = self->parse_name_type_value("an argument name")
                if arg.value != NULL:
                    fail(arg.value->location, "arguments cannot have default values")

                for i = 0; i < result.nargs; i++:
                    if strcmp(result.args[i].name, arg.name) == 0:
                        message: byte[200]
                        snprintf(
                            message, sizeof message,
                            "there are multiple arguments named '%s'", arg.name)
                        fail(arg.name_location, message)

                result.args = realloc(result.args, sizeof result.args[0] * (result.nargs+1))
                result.args[result.nargs++] = arg

            if not self->tokens->is_operator(","):
                break
            self->tokens++

        if not self->tokens->is_operator(")"):
            self->tokens->fail_expected_got("a ')'")
        self->tokens++

        # TODO:
        #   * If is_method, ensure that self parameter exists and is first
        #   * Else, ensure that self parameter does not exists

        # Special case for common typo:   def foo():
        if self->tokens->is_operator(":"):
            if is_method:
                fail(self->tokens->location, "return type must be specified with '->', or with '-> None' if the method doesn't return anything")
            else:
                fail(self->tokens->location, "return type must be specified with '->', or with '-> None' if the function doesn't return anything")
        if not self->tokens->is_operator("->"):
            self->tokens->fail_expected_got("a '->'")
        self->tokens++

        if not used_self and is_method:
            throwerror: byte[300]
            snprintf(throwerror, sizeof throwerror, "missing self, should be 'def %s(self, ...)'", result.name)
            fail(self->tokens->location, throwerror)

        result.return_type = self->parse_type()
        return result

    def parse_call(self) -> AstCall:
        assert self->tokens->kind == TokenKind.Name  # must be checked when calling this function
        result = AstCall{location = self->tokens->location, name = self->tokens->short_string}
        self->tokens++
        assert self->tokens->is_operator("(")
        self->tokens++

        while not self->tokens->is_operator(")"):
            result.args = realloc(result.args, sizeof result.args[0] * (result.nargs+1))
            result.args[result.nargs++] = self->parse_expression()
            if not self->tokens->is_operator(","):
                break
            self->tokens++

        if not self->tokens->is_operator(")"):
            self->tokens->fail_expected_got("a ')'")
        self->tokens++

        return result

    def parse_instantiation(self) -> AstInstantiation:
        assert self->tokens->kind == TokenKind.Name
        result = AstInstantiation{class_name_location = self->tokens->location, class_name = self->tokens->short_string}
        self->tokens++
        assert self->tokens->is_operator("{")
        self->tokens++

        while not self->tokens->is_operator("}"):
            if self->tokens->kind != TokenKind.Name:
                self->tokens->fail_expected_got("a field name")
            field_name = self->tokens->short_string
            for i = 0; i < result.nfields; i++:
                if strcmp(result.field_names[i], field_name) == 0:
                    error: byte[500]
                    snprintf(error, sizeof error, "multiple values were given for field '%s'", field_name)
                    fail(self->tokens->location, error)
            result.field_names = realloc(result.field_names, (result.nfields + 1) * sizeof result.field_names[0])
            result.field_names[result.nfields] = field_name
            self->tokens++

            if not self->tokens->is_operator("="):
                msg: byte[300]
                snprintf(msg, sizeof msg, "'=' followed by a value for field '%s'", field_name)
                self->tokens->fail_expected_got(msg)
            self->tokens++

            result.field_values = realloc(result.field_values, sizeof result.field_values[0] * (result.nfields+1))
            result.field_values[result.nfields] = self->parse_expression()

            result.nfields++
            if not self->tokens->is_operator(","):
                break
            self->tokens++

        if not self->tokens->is_operator("}"):
            self->tokens->fail_expected_got("a '}'")
        self->tokens++

        return result

    def parse_array(self) -> AstArray:
        assert self->tokens->is_operator("[")
        self->tokens++

        result = AstArray{}
        while not self->tokens->is_operator("]"):
            result.items = realloc(result.items, (result.length + 1) * sizeof result.items[0])
            result.items[result.length++] = self->parse_expression()
            if not self->tokens->is_operator(","):
                break
            self->tokens++

        if not self->tokens->is_operator("]"):
            self->tokens->fail_expected_got("a ']' to end the array")
        if result.length == 0:
            fail(self->tokens->location, "arrays cannot be empty")
        self->tokens++

        return result

    def parse_elementary_expression(self) -> AstExpression:
        expr = AstExpression{location = self->tokens->location}

        if self->tokens->kind == TokenKind.Short:
            expr.kind = AstExpressionKind.Short
            expr.short_value = self->tokens->short_value
            self->tokens++
        elif self->tokens->kind == TokenKind.Int:
            expr.kind = AstExpressionKind.Int
            expr.int_value = self->tokens->int_value
            self->tokens++
        elif self->tokens->kind == TokenKind.Long:
            expr.kind = AstExpressionKind.Long
            expr.long_value = self->tokens->long_value
            self->tokens++
        elif self->tokens->kind == TokenKind.Byte:
            expr.kind = AstExpressionKind.Byte
            expr.byte_value = self->tokens->byte_value
            self->tokens++
        elif self->tokens->kind == TokenKind.String:
            expr.kind = AstExpressionKind.String
            expr.string = strdup(self->tokens->long_string)
            self->tokens++
        elif self->tokens->kind == TokenKind.Float:
            expr.kind = AstExpressionKind.Float
            expr.float_or_double_text = self->tokens->short_string
            self->tokens++
        elif self->tokens->kind == TokenKind.Double:
            expr.kind = AstExpressionKind.Double
            expr.float_or_double_text = self->tokens->short_string
            self->tokens++
        elif self->tokens->is_keyword("True"):
            expr.kind = AstExpressionKind.Bool
            expr.bool_value = True
            self->tokens++
        elif self->tokens->is_keyword("False"):
            expr.kind = AstExpressionKind.Bool
            expr.bool_value = False
            self->tokens++
        elif self->tokens->is_keyword("NULL"):
            expr.kind = AstExpressionKind.Null
            self->tokens++
        elif self->tokens->is_keyword("None"):
            fail(self->tokens->location, "None is not a value in Jou, use e.g. -1 for numbers or NULL for pointers")
        elif self->tokens->is_keyword("self"):
            if not self->is_parsing_method_body:
                fail(self->tokens->location, "'self' cannot be used here")
            expr.kind = AstExpressionKind.Self
            self->tokens++
        elif self->tokens->kind == TokenKind.Name:
            if self->tokens[1].is_operator("("):
                expr.kind = AstExpressionKind.Call
                expr.call = self->parse_call()
            elif self->tokens[1].is_operator("{"):
                expr.kind = AstExpressionKind.Instantiate
                expr.instantiation = self->parse_instantiation()
            else:
                expr.kind = AstExpressionKind.GetVariable
                expr.varname = self->tokens->short_string
                self->tokens++
        elif self->tokens->is_operator("("):
            self->tokens++
            expr = self->parse_expression()
            if not self->tokens->is_operator(")"):
                self->tokens->fail_expected_got("a ')'")
            self->tokens++
        elif self->tokens->is_operator("["):
            expr.kind = AstExpressionKind.Array
            expr.array = self->parse_array()
        else:
            self->tokens->fail_expected_got("an expression")

        return expr

    def parse_expression_with_fields_and_methods_and_indexing(self) -> AstExpression:
        result = self->parse_elementary_expression()

        while self->tokens->is_operator(".") or self->tokens->is_operator("->") or self->tokens->is_operator("["):
            if self->tokens->is_operator("["):
                open_bracket = self->tokens++
                operands = [result, self->parse_expression()]
                if not self->tokens->is_operator("]"):
                    self->tokens->fail_expected_got("a ']'")
                self->tokens++
                result = build_operator_expression(open_bracket, 2, operands)

            else:
                start_op = self->tokens++
                if self->tokens->kind != TokenKind.Name:
                    self->tokens->fail_expected_got("a field or method name")

                instance: AstExpression* = malloc(sizeof *instance)
                *instance = result

                if self->tokens[1].is_operator("("):
                    call = self->parse_call()
                    call.method_call_self = instance
                    call.uses_arrow_operator = start_op->is_operator("->")
                    result = AstExpression{
                        location = call.location,
                        kind = AstExpressionKind.Call,
                        call = call,
                    }
                else:
                    result = AstExpression{
                        location = self->tokens->location,
                        kind = AstExpressionKind.GetClassField,
                        class_field = AstClassField{
                            instance = instance,
                            uses_arrow_operator = start_op->is_operator("->"),
                            field_name = self->tokens->short_string,
                        },
                    }
                    self->tokens++

        return result

    def parse_expression_with_unary_operators(self) -> AstExpression:
        # prefix = sequneces of 0 or more unary operator tokens: start,start+1,...,end-1
        prefix_start = self->tokens
        while (
            self->tokens->is_operator("++")
            or self->tokens->is_operator("--")
            or self->tokens->is_operator("&")
            or self->tokens->is_operator("*")
            or self->tokens->is_keyword("sizeof")
        ):
            self->tokens++
        prefix_end = self->tokens

        result = self->parse_expression_with_fields_and_methods_and_indexing()

        suffix_start = self->tokens
        while self->tokens->is_operator("++") or self->tokens->is_operator("--"):
            self->tokens++
        suffix_end = self->tokens

        while prefix_start != prefix_end or suffix_start != suffix_end:
            # ++ and -- "bind tighter", so *foo++ is equivalent to *(foo++)
            # It is implemented by always consuming ++/-- prefixes and suffixes when they exist.
            if prefix_start != prefix_end and prefix_end[-1].is_operator("++"):
                token = --prefix_end
                kind = AstExpressionKind.PreIncr
            elif prefix_start != prefix_end and prefix_end[-1].is_operator("--"):
                token = --prefix_end
                kind = AstExpressionKind.PreDecr
            elif suffix_start != suffix_end and suffix_start[0].is_operator("++"):
                token = suffix_start++
                kind = AstExpressionKind.PostIncr
            elif suffix_start != suffix_end and suffix_start[0].is_operator("--"):
                token = suffix_start++
                kind = AstExpressionKind.PostDecr
            else:
                # We don't have ++ or --, so it must be something in the prefix
                assert prefix_start != prefix_end and suffix_start == suffix_end
                token = --prefix_end
                if token->is_operator("*"):
                    kind = AstExpressionKind.Dereference
                elif token->is_operator("&"):
                    kind = AstExpressionKind.AddressOf
                elif token->is_keyword("sizeof"):
                    kind = AstExpressionKind.SizeOf
                else:
                    assert False

            p: AstExpression* = malloc(sizeof(*p))
            *p = result
            result = AstExpression{location = token->location, kind = kind, operands = p}

        return result

    def parse_expression_with_mul_and_div(self) -> AstExpression:
        result = self->parse_expression_with_unary_operators()
        while self->tokens->is_operator("*") or self->tokens->is_operator("/") or self->tokens->is_operator("%"):
            t = self->tokens++
            lhs_rhs = [result, self->parse_expression_with_unary_operators()]
            result = build_operator_expression(t, 2, lhs_rhs)
        return result

    def parse_expression_with_add(self) -> AstExpression:
        if self->tokens->is_operator("-"):
            minus = self->tokens++
        else:
            minus = NULL

        result = self->parse_expression_with_mul_and_div()
        if minus != NULL:
            result = build_operator_expression(minus, 1, &result)

        while self->tokens->is_operator("+") or self->tokens->is_operator("-"):
            t = self->tokens++
            lhs_rhs = [result, self->parse_expression_with_mul_and_div()]
            result = build_operator_expression(t, 2, lhs_rhs)

        return result

    # "as" operator has somewhat low precedence, so that "1+2 as float" works as expected
    def parse_expression_with_as(self) -> AstExpression:
        result = self->parse_expression_with_add()
        while self->tokens->is_keyword("as"):
            as_location = (self->tokens++)->location  # TODO: shouldn't need so many parentheses
            p: AstAs* = malloc(sizeof(*p))
            *p = AstAs{type = self->parse_type(), value = result}
            result = AstExpression{
                location = as_location,
                kind = AstExpressionKind.As,
                as_ = p,
            }
        return result

    def parse_expression_with_comparisons(self) -> AstExpression:
        result = self->parse_expression_with_as()
        if self->tokens->is_comparison():
            t = self->tokens++
            lhs_rhs = [result, self->parse_expression_with_as()]
            result = build_operator_expression(t, 2, lhs_rhs)
        if self->tokens->is_comparison():
            fail(self->tokens->location, "comparisons cannot be chained")
        return result

    def parse_expression_with_not(self) -> AstExpression:
        if self->tokens->is_keyword("not"):
            not_token = self->tokens
            self->tokens++
        else:
            not_token = NULL

        if self->tokens->is_keyword("not"):
            fail(self->tokens->location, "'not' cannot be repeated")

        result = self->parse_expression_with_comparisons()
        if not_token != NULL:
            result = build_operator_expression(not_token, 1, &result)
        return result

    def parse_expression_with_and_or(self) -> AstExpression:
        result = self->parse_expression_with_not()
        got_and = False
        got_or = False

        while True:
            if self->tokens->is_keyword("and"):
                got_and = True
            elif self->tokens->is_keyword("or"):
                got_or = True
            else:
                break
            if got_and and got_or:
                fail(self->tokens->location, "'and' cannot be chained with 'or', you need more parentheses")

            t = self->tokens++
            lhs_rhs = [result, self->parse_expression_with_not()]
            result = build_operator_expression(t, 2, lhs_rhs)

        return result

    def parse_expression(self) -> AstExpression:
        return self->parse_expression_with_and_or()

    # does not eat a trailing newline
    def parse_oneline_statement(self) -> AstStatement:
        result = AstStatement{ location = self->tokens->location }
        if self->tokens->is_keyword("return"):
            self->tokens++
            result.kind = AstStatementKind.Return
            if self->tokens->kind != TokenKind.Newline:
                result.return_value = malloc(sizeof *result.return_value)
                *result.return_value = self->parse_expression()
        elif self->tokens->is_keyword("assert"):
            self->tokens++
            result.kind = AstStatementKind.Assert
            start = self->tokens->location
            result.assertion.condition = self->parse_expression()
            end = self->tokens->location
            result.assertion.condition_str = read_assertion_from_file(start, end)
        elif self->tokens->is_keyword("pass"):
            self->tokens++
            result.kind = AstStatementKind.Pass
        elif self->tokens->is_keyword("break"):
            self->tokens++
            result.kind = AstStatementKind.Break
        elif self->tokens->is_keyword("continue"):
            self->tokens++
            result.kind = AstStatementKind.Continue
        elif self->tokens->kind == TokenKind.Name and self->tokens[1].is_operator(":"):
            # "foo: int" creates a variable "foo" of type "int"
            result.kind = AstStatementKind.DeclareLocalVar
            result.var_declaration = self->parse_name_type_value(NULL)
        else:
            expr = self->parse_expression()
            result.kind = determine_the_kind_of_a_statement_that_starts_with_an_expression(self->tokens)
            if result.kind == AstStatementKind.ExpressionStatement:
                if not expr.is_valid_as_a_statement():
                    fail(expr.location, "not a valid statement")
                result.expression = expr
            else:
                self->tokens++
                result.assignment = AstAssignment{target = expr, value = self->parse_expression()}
                if self->tokens->is_operator("="):
                    # Would fail elsewhere anyway, but let's make the error message clear
                    fail(self->tokens->location, "only one variable can be assigned at a time")

        return result

    def parse_if_statement(self) -> AstIfStatement:
        ifs_and_elifs: AstConditionAndBody* = NULL
        n = 0

        assert self->tokens->is_keyword("if")
        while True:
            self->tokens++
            cond = self->parse_expression()
            body = self->parse_body()
            ifs_and_elifs = realloc(ifs_and_elifs, sizeof ifs_and_elifs[0] * (n+1))
            ifs_and_elifs[n++] = AstConditionAndBody{condition = cond, body = body}
            if not self->tokens->is_keyword("elif"):
                break

        if self->tokens->is_keyword("else"):
            self->tokens++
            else_body = self->parse_body()
        else:
            else_body = AstBody{}

        return AstIfStatement{
            if_and_elifs = ifs_and_elifs,
            n_if_and_elifs = n,
            else_body = else_body,
        }

    def parse_while_loop(self) -> AstConditionAndBody:
        assert self->tokens->is_keyword("while")
        self->tokens++
        cond = self->parse_expression()
        body = self->parse_body()
        return AstConditionAndBody{condition = cond, body = body}

    def parse_for_loop(self) -> AstForLoop:
        assert self->tokens->is_keyword("for")
        self->tokens++

        # Check if it's "for i in ..." loop, those are not supported
        if (
            self->tokens[0].kind == TokenKind.Name
            and self->tokens[1].kind == TokenKind.Name
            and strcmp(self->tokens[1].short_string, "in") == 0
        ):
            fail(self->tokens[1].location, "Python-style for loops aren't supported. Use e.g. 'for i = 0; i < 10; i++'")

        init: AstStatement* = malloc(sizeof *init)
        incr: AstStatement* = malloc(sizeof *incr)

        *init = self->parse_oneline_statement()
        if not self->tokens->is_operator(";"):
            self->tokens->fail_expected_got("a ';'")
        self->tokens++
        cond = self->parse_expression()
        if not self->tokens->is_operator(";"):
            self->tokens->fail_expected_got("a ';'")
        self->tokens++
        *incr = self->parse_oneline_statement()

        return AstForLoop{
            init = init,
            cond = cond,
            incr = incr,
            body = self->parse_body(),
        }

    def parse_match_statement(self) -> AstMatchStatement:
        assert self->tokens->is_keyword("match")
        self->tokens++

        result = AstMatchStatement{match_obj = self->parse_expression()}
        self->parse_start_of_body()

        while self->tokens->kind != TokenKind.Dedent:
            if not self->tokens->is_keyword("case"):
                self->tokens->fail_expected_got("the 'case' keyword")
            if result.case_underscore != NULL:
                fail(
                    self->tokens->location,
                    "this case will never run, because 'case _:' above matches anything",
                )
            self->tokens++

            if (
                self->tokens->kind == TokenKind.Name
                and strcmp(self->tokens->short_string, "_") == 0
                and self->tokens[1].is_operator(":")
            ):
                # case _:
                result.case_underscore_location = (self->tokens++)->location
                result.case_underscore = malloc(sizeof(*result.case_underscore))
                assert result.case_underscore != NULL
                *result.case_underscore = self->parse_body()
            else:
                result.cases = realloc(result.cases, sizeof result.cases[0] * (result.ncases + 1))
                result.cases[result.ncases++] = AstCase{
                    case_obj = self->parse_expression(),
                    body = self->parse_body(),
                }
        self->tokens++

        return result

    # Parses the "x: int" part of "x, y, z: int", leaving "y, z: int" to be parsed later.
    def parse_first_of_multiple_local_var_declares(self) -> AstNameTypeValue:
        assert self->tokens->kind == TokenKind.Name

        ntv = AstNameTypeValue{
            name = self->tokens->short_string,
            name_location = self->tokens->location,
        }

        # Take a backup of the parser where first variable name and its comma are consumed.
        save_state = *self
        save_state.tokens = &save_state.tokens[2]

        # Skip variables and commas so we can parse the type that comes after it
        self->tokens++
        while self->tokens->is_operator(",") and self->tokens[1].kind == TokenKind.Name:
            self->tokens = &self->tokens[2]

        # Error for "x, y = 0"
        if self->tokens->is_operator("="):
            fail(self->tokens->location, "only one variable can be assigned at a time")

        if self->tokens->is_operator("="):
            fail(self->tokens->location, "only one variable can be assigned at a time")

        if not self->tokens->is_operator(":"):
            self->tokens->fail_expected_got("':' and a type after it (example: \"foo, bar: int\")")
        self->tokens++

        ntv.type = self->parse_type()

        # Error for "x, y: int = 0"
        if self->tokens->is_operator("="):
            fail(self->tokens->location, "only one variable can be assigned at a time")

        *self = save_state
        return ntv

    def parse_statement(self) -> AstStatement:
        if self->tokens->is_keyword("import"):
            fail(self->tokens->location, "imports must be in the beginning of the file")
        if self->tokens->is_keyword("def"):
            return AstStatement{
                location = self->tokens->location,
                kind = AstStatementKind.Function,
                function = self->parse_function_or_method(False),
            }

        if self->tokens->is_keyword("declare"):
            location = (self->tokens++)->location
            if self->tokens->is_keyword("global"):
                self->tokens++
                result = AstStatement{
                    location = location,
                    kind = AstStatementKind.GlobalVariableDeclaration,
                    var_declaration = self->parse_name_type_value("a variable name"),
                }
                if result.var_declaration.value != NULL:
                    fail(
                        result.var_declaration.value->location,
                        "a value cannot be given when declaring a global variable",
                    )
            else:
                result = AstStatement{
                    location = location,
                    kind = AstStatementKind.Function,
                    function = AstFunctionOrMethod{signature = self->parse_function_or_method_signature(False)},
                }
            self->eat_newline()
            return result

        if self->tokens->is_keyword("global"):
            result = AstStatement{
                location = (self->tokens++)->location,
                kind = AstStatementKind.GlobalVariableDefinition,
                var_declaration = self->parse_name_type_value("a variable name"),
            }
            if result.var_declaration.value != NULL:
                fail(
                    result.var_declaration.value->location,
                    "specifying a value for a global variable is not supported yet",
                )
            self->eat_newline()
            return result

        if self->tokens->is_keyword("class"):
            return AstStatement{
                location = self->tokens->location,
                kind = AstStatementKind.Class,
                classdef = self->parse_class(),
            }

        if self->tokens->is_keyword("enum"):
            return AstStatement{
                location = self->tokens->location,
                kind = AstStatementKind.Enum,
                enumdef = self->parse_enum(),
            }

        if self->tokens->is_keyword("if"):
            return AstStatement{
                location = self->tokens->location,
                kind = AstStatementKind.If,
                if_statement = self->parse_if_statement(),
            }

        if self->tokens->is_keyword("for"):
            return AstStatement{
                location = self->tokens->location,
                kind = AstStatementKind.ForLoop,
                for_loop = self->parse_for_loop(),
            }

        if self->tokens->is_keyword("while"):
            return AstStatement{
                location = self->tokens->location,
                kind = AstStatementKind.WhileLoop,
                while_loop = self->parse_while_loop(),
            }

        if self->tokens->is_keyword("match"):
            return AstStatement{
                location = self->tokens->location,
                kind = AstStatementKind.Match,
                match_statement = self->parse_match_statement(),
            }

        if (
            self->tokens[0].kind == TokenKind.Name
            and self->tokens[1].is_operator(",")
            and self->tokens[2].kind == TokenKind.Name
        ):
            return AstStatement{
                location = self->tokens->location,
                kind = AstStatementKind.DeclareLocalVar,
                var_declaration = self->parse_first_of_multiple_local_var_declares(),
            }

        result = self->parse_oneline_statement()
        self->eat_newline()
        return result

    def parse_start_of_body(self) -> None:
        if not self->tokens->is_operator(":"):
            self->tokens->fail_expected_got("':' followed by a new line with more indentation")
        self->tokens++

        if self->tokens->kind != TokenKind.Newline:
            self->tokens->fail_expected_got("a new line with more indentation after ':'")
        self->tokens++

        if self->tokens->kind != TokenKind.Indent:
            self->tokens->fail_expected_got("more indentation after ':'")
        self->tokens++

    def parse_body(self) -> AstBody:
        self->parse_start_of_body()

        result: AstStatement* = NULL
        n = 0
        while self->tokens->kind != TokenKind.Dedent:
            result = realloc(result, sizeof result[0] * (n+1))
            result[n++] = self->parse_statement()
        self->tokens++

        return AstBody{ statements = result, nstatements = n }

    def parse_function_or_method(self, is_method: bool) -> AstFunctionOrMethod:
        assert self->tokens->is_keyword("def")
        self->tokens++

        signature = self->parse_function_or_method_signature(is_method)
        if strcmp(signature.name, "__init__") == 0 and is_method:
            fail(self->tokens->location, "Jou does not have a special __init__ method like Python")
        if signature.takes_varargs:
            fail(self->tokens->location, "functions with variadic arguments cannot be defined yet")

        assert not self->is_parsing_method_body
        self->is_parsing_method_body = is_method
        body = self->parse_body()
        self->is_parsing_method_body = False

        return AstFunctionOrMethod{signature = signature, body = body}

    def parse_class(self) -> AstClassDef:
        assert self->tokens->is_keyword("class")
        self->tokens++

        if self->tokens->kind != TokenKind.Name:
            self->tokens->fail_expected_got("a name for the class")

        result = AstClassDef{
            name = self->tokens->short_string,
            name_location = self->tokens->location,
        }
        self->tokens++

        self->parse_start_of_body()
        while self->tokens->kind != TokenKind.Dedent:
            if self->tokens->is_keyword("def"):
                new_member = AstClassMember{
                    kind = AstClassMemberKind.Method,
                    method = self->parse_function_or_method(True),
                }

            elif self->tokens->is_keyword("union"):
                union_keyword_location = (self->tokens++)->location
                self->parse_start_of_body()

                union_fields = AstUnionFields{}
                while self->tokens->kind != TokenKind.Dedent:
                    field = self->parse_name_type_value("a union member")
                    if field.value != NULL:
                        fail(field.value->location, "union members cannot have default values")

                    union_fields.fields = realloc(union_fields.fields, (union_fields.nfields + 1) * sizeof union_fields.fields[0])
                    union_fields.fields[union_fields.nfields++] = field
                    self->eat_newline()

                self->tokens++

                if union_fields.nfields < 2:
                    fail(union_keyword_location, "unions must have at least 2 members")

                new_member = AstClassMember{
                    kind = AstClassMemberKind.Union,
                    union_fields = union_fields,
                }

            else:
                field = self->parse_name_type_value("a method, a field or a union")
                if field.value != NULL:
                    fail(field.value->location, "class fields cannot have default values")
                new_member = AstClassMember{
                    kind = AstClassMemberKind.Field,
                    field = field,
                }
                self->eat_newline()

            result.members = realloc(result.members, (result.nmembers + 1) * sizeof result.members[0])
            result.members[result.nmembers++] = new_member

        self->tokens++
        check_class_for_duplicate_names(&result)
        return result

    def parse_enum(self) -> AstEnumDef:
        assert self->tokens->is_keyword("enum")
        self->tokens++

        if self->tokens->kind != TokenKind.Name:
            self->tokens->fail_expected_got("a name for the enum")

        result = AstEnumDef{
            name = self->tokens->short_string,
            name_location = self->tokens->location,
        }
        self->tokens++

        self->parse_start_of_body()
        while self->tokens->kind != TokenKind.Dedent:
            if self->tokens->kind != TokenKind.Name:
                self->tokens->fail_expected_got("a name for an enum member")

            for i = 0; i < result.member_count; i++:
                if strcmp(result.member_names[i], self->tokens->short_string) == 0:
                    assert sizeof self->tokens->short_string == 100
                    error: byte[200]
                    sprintf(error, "the enum has two members named '%s'", self->tokens->short_string)
                    fail(self->tokens->location, error)

            result.member_names = realloc(result.member_names, sizeof result.member_names[0] * (result.member_count + 1))
            result.member_names[result.member_count++] = self->tokens->short_string
            self->tokens++
            self->eat_newline()

        self->tokens++
        return result

def parse(tokens: Token*, stdlib_path: byte*) -> AstFile:
    parser = Parser{tokens = tokens, stdlib_path = stdlib_path}
    result = AstFile{path = tokens[0].location.path}

    while parser.tokens->is_keyword("import"):
        result.imports = realloc(result.imports, sizeof result.imports[0] * (result.nimports+1))
        result.imports[result.nimports++] = parser.parse_import()

    while parser.tokens->kind != TokenKind.EndOfFile:
        result.body.statements = realloc(result.body.statements, sizeof result.body.statements[0] * (result.body.nstatements + 1))
        result.body.statements[result.body.nstatements++] = parser.parse_statement()

    return result
