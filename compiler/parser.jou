import "stdlib/assert.jou"
import "stdlib/ascii.jou"
import "stdlib/intnative.jou"
import "stdlib/list.jou"
import "stdlib/str.jou"
import "stdlib/mem.jou"

import "./token.jou"
import "./global_symbols.jou"
import "./state.jou"
import "./ast.jou"
import "./errors_and_warnings.jou"
import "./paths.jou"
import "./constants.jou"
import "./types.jou"


# arity = number of operands, e.g. 2 for a binary operator such as "+"
#
# This cannot be used for ++ and --, because with them we can't know the kind from
# just the token (e.g. ++ could mean pre-increment or post-increment).
def build_operator_expression(t: Token*, arity: int, operands: AstExpression*) -> AstExpression:
    assert arity == 1 or arity == 2 or arity == 3
    nbytes = arity * sizeof operands[0]
    ptr = malloc(nbytes)
    memcpy(ptr, operands, nbytes)

    result = AstExpression{location = t.location, operands = ptr}

    if t.is_operator("["):
        assert arity == 2
        result.kind = AstExpressionKind.Indexing
    elif t.is_operator("=="):
        assert arity == 2
        result.kind = AstExpressionKind.Eq
    elif t.is_operator("!="):
        assert arity == 2
        result.kind = AstExpressionKind.Ne
    elif t.is_operator(">"):
        assert arity == 2
        result.kind = AstExpressionKind.Gt
    elif t.is_operator(">="):
        assert arity == 2
        result.kind = AstExpressionKind.Ge
    elif t.is_operator("<"):
        assert arity == 2
        result.kind = AstExpressionKind.Lt
    elif t.is_operator("<="):
        assert arity == 2
        result.kind = AstExpressionKind.Le
    elif t.is_operator("+"):
        assert arity == 2
        result.kind = AstExpressionKind.Add
    elif t.is_operator("-"):
        assert arity == 1 or arity == 2
        if arity == 2:
            result.kind = AstExpressionKind.Sub
        else:
            result.kind = AstExpressionKind.Negate
    elif t.is_operator("*"):
        assert arity == 1 or arity == 2
        if arity == 2:
            result.kind = AstExpressionKind.Mul
        else:
            result.kind = AstExpressionKind.Dereference
    elif t.is_operator("/"):
        assert arity == 2
        result.kind = AstExpressionKind.Div
    elif t.is_operator("%"):
        assert arity == 2
        result.kind = AstExpressionKind.Mod
    elif t.is_operator("&"):
        assert arity == 1 or arity == 2
        if arity == 1:
            result.kind = AstExpressionKind.AddressOf
        else:
            result.kind = AstExpressionKind.BitAnd
    elif t.is_operator("|"):
        assert arity == 2
        result.kind = AstExpressionKind.BitOr
    elif t.is_operator("^"):
        assert arity == 2
        result.kind = AstExpressionKind.BitXor
    elif t.is_operator("<<"):
        assert arity == 2
        result.kind = AstExpressionKind.BitShiftLeft
    elif t.is_operator(">>"):
        assert arity == 2
        result.kind = AstExpressionKind.BitShiftRight
    elif t.is_keyword("and"):
        assert arity == 2
        result.kind = AstExpressionKind.And
    elif t.is_keyword("or"):
        assert arity == 2
        result.kind = AstExpressionKind.Or
    elif t.is_keyword("not"):
        assert arity == 1
        result.kind = AstExpressionKind.Not
    elif t.is_keyword("if"):
        assert arity == 3
        result.kind = AstExpressionKind.TernaryIf
    else:
        assert False

    assert result.get_arity() == arity
    return result


# reverse code golfing: https://xkcd.com/1960/
def determine_the_kind_of_a_statement_that_starts_with_an_expression(
    this_token_is_after_that_initial_expression: Token*
) -> AstStatementKind:
    if this_token_is_after_that_initial_expression.is_operator("="):
        return AstStatementKind.Assign
    if this_token_is_after_that_initial_expression.is_operator("+="):
        return AstStatementKind.InPlaceAdd
    if this_token_is_after_that_initial_expression.is_operator("-="):
        return AstStatementKind.InPlaceSub
    if this_token_is_after_that_initial_expression.is_operator("*="):
        return AstStatementKind.InPlaceMul
    if this_token_is_after_that_initial_expression.is_operator("/="):
        return AstStatementKind.InPlaceDiv
    if this_token_is_after_that_initial_expression.is_operator("%="):
        return AstStatementKind.InPlaceMod
    if this_token_is_after_that_initial_expression.is_operator("&="):
        return AstStatementKind.InPlaceBitAnd
    if this_token_is_after_that_initial_expression.is_operator("|="):
        return AstStatementKind.InPlaceBitOr
    if this_token_is_after_that_initial_expression.is_operator("^="):
        return AstStatementKind.InPlaceBitXor
    if this_token_is_after_that_initial_expression.is_operator("<<="):
        return AstStatementKind.InPlaceBitShiftLeft
    if this_token_is_after_that_initial_expression.is_operator(">>="):
        return AstStatementKind.InPlaceBitShiftRight
    return AstStatementKind.ExpressionStatement


def skip_string_or_byte(s: byte*) -> byte*:
    assert *s == '"' or *s == '\''
    quote = *s
    s++

    while *s != '\0' and *s != quote:
        s++
        if s[-1] == '\\' and *s != '\0':
            # Skip anything escaped, so \\\" (backslash then quote) works
            s++

    if *s == quote:
        s++
    return s


def get_assertion_code_as_string(start: Token*, end: Token*) -> byte*:
    # TODO: "pointer as intnative" cast should be allowed
    len = ((end.file_content_ptr as int64) - (start.file_content_ptr as int64)) as intnative
    assert len > 0

    s: byte* = malloc(len + 1)
    assert s != NULL
    memcpy(s, start.file_content_ptr, len)
    s[len] = '\0'

    p = s
    while *p != '\0':
        match *p:
            case '"' | '\'':
                p = skip_string_or_byte(p)
            case '#':
                # Remove comments
                comment_end = &p[strcspn(p, "\n")]
                memmove(p, comment_end, strlen(comment_end) + 1)
            case '\n':
                # Delete spaces and other newlines that surround this newline
                bad = "\n\r "
                delete_end = &p[strspn(p, bad)]
                while p > s and strchr(bad, p[-1]) != NULL:
                    p--
                # Add space in place of newline and other deleted stuff, but not if
                # it would be awkwardly after '(' or before ')'
                if (p == s or p[-1] != '(') and *delete_end != ')':
                    # Replace with space
                    *p = ' '
                    p++
                memmove(p, delete_end, strlen(delete_end) + 1)
            case _:
                p++

    trim_ascii_whitespace(s)
    return s


def decorate(stmt: AstStatement*, decor: byte*, location: Location) -> None:
    assert decor[0] == '@'

    if strcmp(decor, "@public") == 0:
        match stmt.kind:
            case AstStatementKind.FunctionDeclare | AstStatementKind.FunctionDef:
                if strcmp(stmt.function.ast_signature.name, "main") == 0:
                    fail(location, "the main() function cannot be @public")
            case _:
                pass

        symbol = stmt.symbol()
        if symbol == NULL:
            fail(location, "the @public decorator cannot be used here")
        symbol.public = True

    elif strcmp(decor, "@inline") == 0:
        match stmt.kind:
            case AstStatementKind.FunctionDef:
                if strcmp(stmt.function.ast_signature.name, "main") == 0:
                    # TODO: test this
                    fail(location, "the main() function cannot be @inline")
                stmt.function.inline = True
            case AstStatementKind.MethodDef:
                stmt.method.inline = True
            case _:
                # TODO: test this
                fail(location, "the @inline decorator cannot be used here")

    else:
        msg: byte[200]
        snprintf(msg, sizeof(msg), "there is no decorator named '%s'", decor)
        fail(location, msg)


# Determines whether the next tokens are "Class{attribute = value}" syntax.
# Not as simple as you might expect, because the class can be generic.
# Example: Foo[int, byte*]{x = 1, y="hello"}
def looks_like_instantiate(t: Token*) -> bool:
    if t.kind != TokenKind.Name:
        return False
    t++
    if t.is_operator("{"):
        return True
    if t.is_operator("["):
        # Find matching ']' and see if there's '{' after it.
        depth = 1
        t++
        while depth > 0 and t.kind != TokenKind.EndOfFile:
            if t.is_operator("["):
                depth++
            if t.is_operator("]"):
                depth--
            t++
        return t.is_operator("{")
    return False


# The multiple cases of "case a | b | c | d:" appear as a nested bitwise OR
# expression. Here's what this function does to it:
#
#   BitOr(BitOr(BitOr(a, b), c), d)     -->     [a, b, c, d]
#
def flatten_bitwise_ors(expr: AstExpression) -> List[AstExpression]:
    result = List[AstExpression]{}
    todo = List[AstExpression]{}
    todo.append(expr)

    while todo.len > 0:
        expr = todo.pop()
        if expr.kind == AstExpressionKind.BitOr:
            # Visit right side first so that it appears on the left in result
            todo.append(expr.operands[1])
            todo.append(expr.operands[0])
            free(expr.operands)
        else:
            result.append(expr)

    free(todo.ptr)
    return result


enum WhatAreWeParsing:
    TopLevel  # must be first, so that this is the default (zero)
    ClassBody
    FunctionBody
    MethodBody


class Parser:
    tokens: Token*
    is_main_file: bool
    loop_vars: List[byte*]  # NULL means a loop that doesn't look like "for foo = bar; ..."
    what_are_we_parsing: WhatAreWeParsing
    containing_class_name: byte[100]

    def check_top_level(self, what_is_it: byte*) -> None:
        if self.what_are_we_parsing != WhatAreWeParsing.TopLevel:
            msg: byte[500]
            snprintf(msg, sizeof(msg), "%s must be on top level, not e.g. inside a function", what_is_it)
            fail(self.tokens.location, msg)

    def check_function_or_method(self, what_is_it: byte*) -> None:
        match self.what_are_we_parsing:
            case WhatAreWeParsing.FunctionBody | WhatAreWeParsing.MethodBody:
                pass
            case _:
                msg: byte[500]
                snprintf(msg, sizeof(msg), "%s must be inside a function or method", what_is_it)
                fail(self.tokens.location, msg)

    def eat_keyword(self, word: byte*, use_fail_expected_got: bool, error_msg: byte*) -> Token*:
        if not self.tokens.is_keyword(word):
            assert error_msg != NULL
            if use_fail_expected_got:
                self.tokens.fail_expected_got(error_msg)
            else:
                fail(self.tokens.location, error_msg)
        return self.tokens++

    def eat_operator(self, op: byte*, use_fail_expected_got: bool, error_msg: byte*) -> Token*:
        if not self.tokens.is_operator(op):
            assert error_msg != NULL
            if use_fail_expected_got:
                self.tokens.fail_expected_got(error_msg)
            else:
                fail(self.tokens.location, error_msg)
        return self.tokens++

    def eat_by_kind(self, kind: TokenKind, use_fail_expected_got: bool, error_msg: byte*) -> Token*:
        if self.tokens.kind != kind:
            assert error_msg != NULL
            if use_fail_expected_got:
                self.tokens.fail_expected_got(error_msg)
            else:
                fail(self.tokens.location, error_msg)
        return self.tokens++

    def eat_newline(self) -> None:
        self.eat_by_kind(TokenKind.Newline, True, "end of line")

    def parse_import(self) -> AstImport:
        import_keyword = self.eat_keyword("import", False, NULL)
        if self.what_are_we_parsing != WhatAreWeParsing.TopLevel:
            fail(import_keyword.location, "imports must be in the beginning of the file")

        path_token = self.eat_by_kind(TokenKind.String, True, "a string to specify the file name")
        self.eat_newline()

        path: byte*
        if starts_with(path_token.long_string, "stdlib/"):
            # Starts with stdlib --> import from where stdlib actually is
            assert global_compiler_state.stdlib_path != NULL
            asprintf(&path, "%s/%s", global_compiler_state.stdlib_path, &path_token.long_string[7])
        elif starts_with(path_token.long_string, "."):
            # Relative to directory where the file is
            tmp = strdup(path_token.location.path)
            asprintf(&path, "%s/%s", dirname(tmp), path_token.long_string)
            free(tmp)
        else:
            fail(
                path_token.location,
                "import path must start with 'stdlib/' (standard-library import) or a dot (relative import)"
            )

        simplify_path(path)
        return AstImport{
            specified_path = strdup(path_token.long_string),
            resolved_path = path,
        }

    def parse_link(self) -> AstLink:
        self.check_top_level("'link' statement")
        self.eat_keyword("link", False, NULL)
        flags_token = self.eat_by_kind(TokenKind.String, True, "a string of linker flags after the 'link' keyword")
        self.eat_newline()
        return AstLink{
            specified_flags = strdup(flags_token.long_string),
            resolved_flags = handle_relative_paths_in_linker_flags(flags_token.long_string, flags_token.location.path),
        }

    def parse_funcptr_type(self) -> AstType:
        location = self.eat_keyword("funcptr", False, NULL).location
        self.eat_operator("(", True, "a '(' to denote the start of funcptr argument types")

        takes_varargs = False
        argtypes = List[AstType]{}

        while not self.tokens.is_operator(")"):
            if takes_varargs:
                fail(self.tokens.location, "if '...' is used, it must be the last parameter")

            if self.tokens.is_operator("..."):
                takes_varargs = True
                self.tokens++
            else:
                if argtypes.len == MAX_ARGS:
                    fail(self.tokens.location, "too many arguments")
                argtypes.append(self.parse_type())

            if not self.tokens.is_operator(","):
                break
            self.tokens++

        if self.tokens.is_operator(":") and self.tokens[-1].kind == TokenKind.Name:
            # It looks like "foo: int"
            fail(self.tokens.location, "funcptr parameters cannot be named")

        self.eat_operator(")", True, "a ')'")
        self.eat_operator("->", False, "return type of funcptr must be specified with '->'")

        ret: AstType* = malloc(sizeof(*ret))
        assert ret != NULL
        *ret = self.parse_type()

        return AstType{
            kind = AstTypeKind.FuncPtr,
            location = location,
            func_ptr = AstFuncPtrType{argtypes=argtypes, takes_varargs=takes_varargs, return_type=ret},
        }

    def parse_type(self) -> AstType:
        result: AstType
        ret = self.parse_type_advanced(&result, False)
        assert ret
        return result

    # If could_be_an_expression is True, this returns False and leaves the
    # tokens ptr pointing into some random spot when the thing is actually
    # an expression and not a type.
    #
    # Some things are valid as both types and expressions, e.g. Name1[Name2] is
    # either an array with length Name2 or a generic class Name1 with parameter
    # type Name2. In this case we parse it as a generic class. It will be
    # corrected later by the type checking code.
    def parse_type_advanced(self, result: AstType*, could_be_an_expression: bool) -> bool:
        if self.tokens.is_operator("("):
            self.tokens++
            if could_be_an_expression:
                if not self.parse_type_advanced(result, True):
                    return False
                if not self.tokens.is_operator(")"):
                    return False
                self.tokens++
            else:
                *result = self.parse_type()
                self.eat_operator(")", True, "a ')'")
        elif self.tokens.kind == TokenKind.Name:
            t = self.tokens++
            *result = AstType{kind = AstTypeKind.Named, location = t.location, name = t.short_string}
        elif (
            self.tokens.is_keyword("None")           # only valid as a return type
            or self.tokens.is_keyword("void")        # only valid as a pointer (void*)
            or self.tokens.is_keyword("noreturn")    # only valid as a return type
            or self.tokens.is_keyword("int")
            or self.tokens.is_keyword("int8")
            or self.tokens.is_keyword("int16")
            or self.tokens.is_keyword("int32")
            or self.tokens.is_keyword("int64")
            or self.tokens.is_keyword("uint8")
            or self.tokens.is_keyword("uint16")
            or self.tokens.is_keyword("uint32")
            or self.tokens.is_keyword("uint64")
            or self.tokens.is_keyword("byte")
            or self.tokens.is_keyword("float")
            or self.tokens.is_keyword("double")
            or self.tokens.is_keyword("bool")
        ):
            t = self.tokens++
            *result = AstType{kind = AstTypeKind.BuiltIn, location = t.location, name = t.short_string}
            could_be_an_expression = False
        elif self.tokens.is_keyword("funcptr"):
            *result = self.parse_funcptr_type()
            could_be_an_expression = False
        else:
            if could_be_an_expression:
                return False
            elif self.tokens.is_operator("*"):
                fail(self.tokens.location, "a type cannot start with '*', use e.g. int* instead of *int for pointers")
            elif self.tokens.is_operator("["):
                fail(self.tokens.location, "a type cannot start with '[', use e.g. int[10] instead of [10]int for arrays")
            else:
                self.tokens.fail_expected_got("a type")

        while self.tokens.is_operator("*") or self.tokens.is_operator("["):
            temp_ptr: AstType*
            if self.tokens.is_operator("*"):
                star = self.tokens++
                temp_ptr = malloc(sizeof(*temp_ptr))
                assert temp_ptr != NULL
                *temp_ptr = *result
                *result = AstType{location = star.location, kind = AstTypeKind.Pointer, value_type = temp_ptr}
                continue

            open_bracket = self.eat_operator("[", False, NULL)
            if self.tokens.is_operator("]"):
                fail(self.tokens.location, "array length must be specified, e.g. int[10] instead of int[]")

            old_tokens_ptr = self.tokens
            if result.kind == AstTypeKind.Named:
                # Could be a generic or an array
                first_type_inside_brackets: AstType
                if (
                    self.parse_type_advanced(&first_type_inside_brackets, True)
                    and (self.tokens.is_operator(",") or self.tokens.is_operator("]"))
                ):
                    # It is a generic :)
                    params = List[AstType]{}
                    params.append(first_type_inside_brackets)
                    if self.tokens.is_operator(","):
                        self.tokens++
                        while not self.tokens.is_operator("]"):
                            params.append(self.parse_type())
                            if not self.tokens.is_operator(","):
                                break
                            self.tokens++
                    self.eat_operator("]", True, "a ']'")
                    assert result.kind == AstTypeKind.Named
                    *result = AstType{
                        location = result.location,
                        kind = AstTypeKind.Generic,
                        generic = AstGenericType{
                            class_name = result.name,
                            param_types = params,
                        }
                    }
                    continue

            # Now let's just assume it's an array, e.g. int[10]
            self.tokens = old_tokens_ptr
            len_expression: AstExpression* = malloc(sizeof *len_expression)
            *len_expression = self.parse_expression()
            self.eat_operator("]", True, "a ']' to end the array size")
            temp_ptr = malloc(sizeof(*temp_ptr))
            assert temp_ptr != NULL
            *temp_ptr = *result
            *result = AstType{
                location = open_bracket.location,
                kind = AstTypeKind.Array,
                array = AstArrayType{
                    member_type = temp_ptr,
                    length = len_expression,
                }
            }

        return True

    def parse_typedef(self) -> AstTypeDef:
        self.eat_keyword("typedef", False, NULL)
        name = self.eat_by_kind(TokenKind.Name, True, "the name for a type").short_string
        self.eat_operator("=", True, "'=' between name and type")

        symbol = GlobalSymbol{kind = GlobalSymbolKind.Type}
        assert array_count(symbol.name) >= array_count(name)
        strcpy(symbol.name, name)

        return AstTypeDef{symbol = symbol, ast_type = self.parse_type()}

    def parse_name_type_value(self, expected_what_for_name: byte*) -> AstNameTypeValue:
        name = self.eat_by_kind(TokenKind.Name, True, expected_what_for_name)
        self.eat_operator(":", True, "':' and a type after it (example: \"foo: int\")")
        type = self.parse_type()
        value: AstExpression* = NULL
        if self.tokens.is_operator("="):
            self.eat_operator("=", False, NULL)
            value = malloc(sizeof *value)
            *value = self.parse_expression()

        return AstNameTypeValue{name = name.short_string, name_location = name.location, type = type, value = value}

    def parse_function_or_method_signature(self, is_method: bool) -> AstSignature:
        message: byte[300]

        name = self.eat_by_kind(TokenKind.Name, True, "a method name" if is_method else "a function name")
        result = AstSignature{
            name_location = name.location,
            name = name.short_string,
        }

        self.eat_operator("(", True, "a '(' to denote the start of arguments")

        used_self = False
        while not self.tokens.is_operator(")"):
            if result.takes_varargs:
                fail(self.tokens.location, "if '...' is used, it must be the last parameter")

            if self.tokens.is_operator("..."):
                result.takes_varargs = True
                self.tokens++

            elif self.tokens.is_keyword("self"):
                self_keyword = self.tokens++
                if not is_method:
                    fail(self_keyword.location, "'self' cannot be used here")
                if result.args.len != 0:
                    fail(self_keyword.location, "'self' must be the first argument")

                self_arg = AstNameTypeValue{name = "self", name_location = self_keyword.location}
                if self.tokens.is_operator(":"):
                    self.tokens++
                    self_arg.type = self.parse_type()

                result.args.append(self_arg)
                used_self = True

            else:
                arg = self.parse_name_type_value("an argument name")
                if arg.value != NULL:
                    fail(arg.value.location, "arguments cannot have default values")

                for p = result.args.ptr; p < result.args.end(); p++:
                    if strcmp(p.name, arg.name) == 0:
                        snprintf(
                            message, sizeof message,
                            "there are multiple arguments named '%s'", arg.name)
                        fail(arg.name_location, message)

                if result.args.len == MAX_ARGS:
                    fail(self.tokens.location, "too many arguments")
                result.args.append(arg)

            if not self.tokens.is_operator(","):
                break
            self.tokens++

        self.eat_operator(")", True, "a ')'")

        # Special case for common typo:   def foo():
        if self.tokens.is_operator(":"):
            if is_method:
                fail(self.tokens.location, "return type must be specified with '->', or with '-> None' if the method doesn't return anything")
            else:
                fail(self.tokens.location, "return type must be specified with '->', or with '-> None' if the function doesn't return anything")
        self.eat_operator("->", True, "a '->'")

        if not used_self and is_method:
            snprintf(message, sizeof message, "missing self, should be 'def %s(self, ...)'", result.name)
            fail(self.tokens.location, message)

        result.return_type = self.parse_type()
        return result

    def parse_instantiation(self) -> AstInstantiation:
        result = AstInstantiation{type = self.parse_type()}
        self.eat_operator("{", False, NULL)

        while not self.tokens.is_operator("}"):
            fname = self.eat_by_kind(TokenKind.Name, True, "a field name")
            for f = result.fields.ptr; f < result.fields.end(); f++:
                if strcmp(f.name, fname.short_string) == 0:
                    error: byte[500]
                    snprintf(error, sizeof error, "multiple values were given for field '%s'", fname.short_string)
                    fail(fname.location, error)

            msg: byte[300]
            snprintf(msg, sizeof msg, "'=' followed by a value for field '%s'", fname.short_string)
            self.eat_operator("=", True, msg)

            result.fields.append(AstInstantiationField{name = fname.short_string, value = self.parse_expression()})

            if not self.tokens.is_operator(","):
                break
            self.tokens++

        self.eat_operator("}", True, "a '}'")
        return result

    def parse_array(self) -> List[AstExpression]:
        self.eat_operator("[", False, NULL)

        result = List[AstExpression]{}
        while not self.tokens.is_operator("]"):
            result.append(self.parse_expression())
            if not self.tokens.is_operator(","):
                break
            self.tokens++

        close_bracket = self.eat_operator("]", True, "a ']' to end the array")
        if result.len == 0:
            fail(close_bracket.location, "arrays cannot be empty")

        return result

    def parse_elementary_expression(self) -> AstExpression:
        expr = AstExpression{location = self.tokens.location}

        match self.tokens.kind:
            case TokenKind.Integer:
                expr.kind = AstExpressionKind.IntegerConstant
                expr.integer_value = (self.tokens++).integer_value
            case TokenKind.Byte:
                expr.kind = AstExpressionKind.Constant
                expr.constant = int_constant(uint_type(8), (self.tokens++).integer_value as int64)
            case TokenKind.Float:
                expr.kind = AstExpressionKind.Constant
                expr.constant = Constant{kind = ConstantKind.Float, float_or_double_text = (self.tokens++).short_string}
            case TokenKind.Double:
                expr.kind = AstExpressionKind.Constant
                expr.constant = Constant{kind = ConstantKind.Double, float_or_double_text = (self.tokens++).short_string}
            case TokenKind.String:
                expr.kind = AstExpressionKind.Constant
                expr.constant = Constant{kind = ConstantKind.PointerString, pointer_string = strdup((self.tokens++).long_string)}
            case TokenKind.Name:
                if looks_like_instantiate(self.tokens):
                    expr.kind = AstExpressionKind.Instantiate
                    expr.instantiation = self.parse_instantiation()
                else:
                    expr.kind = AstExpressionKind.GetVariable
                    expr.varname = (self.tokens++).short_string
            case _:
                if self.tokens.is_keyword("True"):
                    expr.kind = AstExpressionKind.Constant
                    expr.constant = Constant{kind = ConstantKind.Bool, boolean = True}
                    self.tokens++
                elif self.tokens.is_keyword("False"):
                    expr.kind = AstExpressionKind.Constant
                    expr.constant = Constant{kind = ConstantKind.Bool, boolean = False}
                    self.tokens++
                elif self.tokens.is_keyword("NULL"):
                    expr.kind = AstExpressionKind.Constant
                    expr.constant = Constant{kind = ConstantKind.Null}
                    self.tokens++
                elif self.tokens.is_keyword("None"):
                    fail(self.tokens.location, "None is not a value in Jou, use e.g. -1 for numbers or NULL for pointers")
                elif self.tokens.is_keyword("self"):
                    if self.what_are_we_parsing != WhatAreWeParsing.MethodBody:
                        fail(self.tokens.location, "'self' cannot be used here")
                    expr.kind = AstExpressionKind.Self
                    self.tokens++
                elif self.tokens.is_operator("("):
                    self.tokens++
                    expr = self.parse_expression()
                    self.eat_operator(")", True, "a ')'")
                elif self.tokens.is_operator("["):
                    expr.kind = AstExpressionKind.Array
                    expr.array = self.parse_array()
                elif self.tokens.is_keyword("enum_count"):
                    expr.kind = AstExpressionKind.EnumCount
                    self.tokens++
                    expr.enumcount.enum_type_ast = self.parse_type()
                else:
                    # Special error message for e.g. int(x)
                    msg: byte[300]
                    if self.tokens.kind == TokenKind.Keyword and self.tokens[1].is_operator("("):
                        keyword = self.tokens.short_string
                        match keyword with strcmp:
                            case "byte" | "int" | "int8" | "uint8" | "int16" | "uint16" | "int32" | "uint32":
                                snprintf(
                                    msg,
                                    sizeof(msg),
                                    "%s is not a function, use 'as %s' to convert between numbers or e.g. atoi() from \"stdlib/str.jou\" to convert a string to int",
                                    keyword,
                                    keyword,
                                )
                                fail(self.tokens.location, msg)
                            case "int64" | "uint64":
                                snprintf(
                                    msg,
                                    sizeof(msg),
                                    "%s is not a function, use 'as %s' to convert between numbers or e.g. atoll() from \"stdlib/str.jou\" to convert a string to int64",
                                    keyword,
                                    keyword,
                                )
                                fail(self.tokens.location, msg)

                    self.tokens.fail_expected_got("an expression")

        return expr

    def parse_indexing(self, obj: AstExpression) -> AstExpression:
        open_bracket = self.eat_operator("[", False, NULL)
        operands = [obj, self.parse_expression()]
        self.eat_operator("]", True, "a ']'")
        return build_operator_expression(open_bracket, 2, operands)

    def parse_dot_operator(self, obj: AstExpression) -> AstExpression:
        self.eat_operator(".", False, NULL)
        field_name_token = self.eat_by_kind(TokenKind.Name, True, "a field or method name")

        instance: AstExpression* = malloc(sizeof *instance)
        *instance = obj
        return AstExpression{
            location = field_name_token.location,
            kind = AstExpressionKind.DotOperator,
            class_field = AstClassField{
                instance = instance,
                field_name = field_name_token.short_string,
            },
        }

    def parse_call(self, obj: AstExpression) -> AstExpression:
        func: AstExpression* = malloc(sizeof(obj))
        *func = obj
        call = AstCall{function = func}

        location = self.eat_operator("(", False, NULL).location

        while not self.tokens.is_operator(")"):
            # Do not allow going all the way to MAX_ARGS so that we can add
            # the `self` argument for method calls later.
            #
            # There's no easy way to know whether we are calling a method. Even
            # though `foo.bar()` is usually a method call, it can also call a
            # function pointer stored in field `bar`.
            if call.args.len == MAX_ARGS - 1:
                fail(self.tokens.location, "too many arguments")
            call.args.append(self.parse_expression())
            if not self.tokens.is_operator(","):
                break
            self.tokens++

        self.eat_operator(")", True, "a ')'")
        return AstExpression{
            location = location,
            kind = AstExpressionKind.Call,
            call = call,
        }

    def parse_expression_with_members_and_indexing_and_calls(self) -> AstExpression:
        result = self.parse_elementary_expression()
        while True:
            if self.tokens.is_operator("["):
                result = self.parse_indexing(result)
            elif self.tokens.is_operator("."):
                result = self.parse_dot_operator(result)
            elif self.tokens.is_operator("("):
                result = self.parse_call(result)
            elif self.tokens.is_operator("->"):
                fail(self.tokens.location, "use . instead of ->")
            else:
                return result

    def parse_expression_with_unary_operators(self) -> AstExpression:
        # prefix = sequence of 0 or more unary operator tokens: start,start+1,...,end-1
        prefix_start = self.tokens
        while (
            self.tokens.is_operator("++")
            or self.tokens.is_operator("--")
            or self.tokens.is_operator("&")
            or self.tokens.is_operator("*")
            or self.tokens.is_operator("~")
            or self.tokens.is_keyword("sizeof")
            or self.tokens.is_keyword("embed_file")
            or self.tokens.is_keyword("array_count")
        ):
            self.tokens++
        prefix_end = self.tokens

        result = self.parse_expression_with_members_and_indexing_and_calls()

        suffix_start = self.tokens
        while self.tokens.is_operator("++") or self.tokens.is_operator("--"):
            self.tokens++
        suffix_end = self.tokens

        while prefix_start != prefix_end or suffix_start != suffix_end:
            # ++ and -- "bind tighter", so *foo++ is equivalent to *(foo++)
            # It is implemented by always consuming ++/-- prefixes and suffixes when they exist.
            if prefix_start != prefix_end and prefix_end[-1].is_operator("++"):
                token = --prefix_end
                kind = AstExpressionKind.PreIncr
            elif prefix_start != prefix_end and prefix_end[-1].is_operator("--"):
                token = --prefix_end
                kind = AstExpressionKind.PreDecr
            elif suffix_start != suffix_end and suffix_start[0].is_operator("++"):
                token = suffix_start++
                kind = AstExpressionKind.PostIncr
            elif suffix_start != suffix_end and suffix_start[0].is_operator("--"):
                token = suffix_start++
                kind = AstExpressionKind.PostDecr
            else:
                # We don't have ++ or --, so it must be something in the prefix
                assert prefix_start != prefix_end and suffix_start == suffix_end
                token = --prefix_end
                if token.is_operator("*"):
                    kind = AstExpressionKind.Dereference
                elif token.is_operator("&"):
                    kind = AstExpressionKind.AddressOf
                elif token.is_operator("~"):
                    kind = AstExpressionKind.BitNot
                elif token.is_keyword("sizeof"):
                    kind = AstExpressionKind.SizeOf
                elif token.is_keyword("embed_file"):
                    kind = AstExpressionKind.EmbedFile
                elif token.is_keyword("array_count"):
                    kind = AstExpressionKind.ArrayCount
                else:
                    assert False

            p: AstExpression* = malloc(sizeof(*p))
            *p = result
            result = AstExpression{location = token.location, kind = kind, operands = p}

        return result

    def parse_expression_with_mul_and_div(self) -> AstExpression:
        result = self.parse_expression_with_unary_operators()
        while self.tokens.is_operator("*") or self.tokens.is_operator("/") or self.tokens.is_operator("%"):
            t = self.tokens++
            lhs_rhs = [result, self.parse_expression_with_unary_operators()]
            result = build_operator_expression(t, 2, lhs_rhs)
        return result

    def parse_expression_with_add(self) -> AstExpression:
        if self.tokens.is_operator("-"):
            minus = self.tokens++
        else:
            minus = NULL

        result = self.parse_expression_with_mul_and_div()
        if minus != NULL:
            result = build_operator_expression(minus, 1, &result)

        while self.tokens.is_operator("+") or self.tokens.is_operator("-"):
            t = self.tokens++
            lhs_rhs = [result, self.parse_expression_with_mul_and_div()]
            result = build_operator_expression(t, 2, lhs_rhs)

        return result

    # TODO: ban chaining bitwise operations with arithmetic operations
    # TODO: ban chaining different bitwise operations e.g. a ^ b & c
    def parse_expression_with_bitwise_ops(self) -> AstExpression:
        result = self.parse_expression_with_add()
        while (
            self.tokens.is_operator("&")
            or self.tokens.is_operator("|")
            or self.tokens.is_operator("^")
            or self.tokens.is_operator("<<")
            or self.tokens.is_operator(">>")
        ):
            t = self.tokens++
            lhs_rhs = [result, self.parse_expression_with_add()]
            result = build_operator_expression(t, 2, lhs_rhs)
        return result

    # "as" operator has somewhat low precedence, so that "1+2 as float" works as expected
    # TODO: would be better to ban chaining "as" with anything
    def parse_expression_with_as(self) -> AstExpression:
        result = self.parse_expression_with_bitwise_ops()
        while self.tokens.is_keyword("as"):
            as_keyword = self.tokens++
            p: AstAs* = malloc(sizeof(*p))
            *p = AstAs{type = self.parse_type(), value = result}
            result = AstExpression{location = as_keyword.location, kind = AstExpressionKind.As, as_ = p}
        return result

    def parse_expression_with_comparisons(self) -> AstExpression:
        result = self.parse_expression_with_as()
        if self.tokens.is_comparison():
            t = self.tokens++
            lhs_rhs = [result, self.parse_expression_with_as()]
            result = build_operator_expression(t, 2, lhs_rhs)
        if self.tokens.is_comparison():
            fail(self.tokens.location, "comparisons cannot be chained")
        return result

    def parse_expression_with_not(self) -> AstExpression:
        not_token: Token* = NULL
        if self.tokens.is_keyword("not"):
            not_token = self.tokens++
            if self.tokens.is_keyword("not"):
                fail(self.tokens.location, "'not' cannot be repeated")

        result = self.parse_expression_with_comparisons()
        if not_token != NULL:
            match result.kind:
                case AstExpressionKind.Eq:
                    show_warning(result.location, "use 'foo != bar' instead of 'not foo == bar'")
                case AstExpressionKind.Ne:
                    show_warning(result.location, "use 'foo == bar' instead of 'not foo != bar'")
                case _:
                    pass
            result = build_operator_expression(not_token, 1, &result)
        return result

    def parse_expression_with_and_or(self) -> AstExpression:
        result = self.parse_expression_with_not()
        got_and = False
        got_or = False

        while True:
            if self.tokens.is_keyword("and"):
                got_and = True
            elif self.tokens.is_keyword("or"):
                got_or = True
            else:
                break
            if got_and and got_or:
                fail(self.tokens.location, "'and' cannot be chained with 'or', you need more parentheses")

            t = self.tokens++
            lhs_rhs = [result, self.parse_expression_with_not()]
            result = build_operator_expression(t, 2, lhs_rhs)

        return result

    def parse_expression_with_ternary(self) -> AstExpression:
        result = self.parse_expression_with_and_or()
        if not self.tokens.is_keyword("if"):
            return result

        then = result
        if_token = self.tokens++
        condition = self.parse_expression_with_and_or()
        self.eat_keyword("else", True, "'else'")
        otherwise = self.parse_expression_with_and_or()
        parts = [then, condition, otherwise]
        return build_operator_expression(if_token, 3, parts)

    def parse_expression(self) -> AstExpression:
        return self.parse_expression_with_ternary()

    def parse_expression_with_unnecessary_parens_warning(self, description_of_expr: byte*) -> AstExpression:
        start = self.tokens
        result = self.parse_expression_with_and_or()
        end = &self.tokens[-1]

        if (
            start.is_operator("(")
            and end.is_operator(")")
            and start.location.lineno == end.location.lineno
        ):
            # Check if starting '(' is closed with a ')' before the end
            depth = 1
            closed_early = False
            for p = &start[1]; p < end; p++:
                if p.is_operator("("):
                    depth++
                if p.is_operator(")"):
                    depth--
                    if depth == 0:
                        closed_early = True
                        break
            if not closed_early:
                msg: byte[500]
                snprintf(msg, sizeof(msg), "parentheses around %s are unnecessary", description_of_expr)
                show_warning(start.location, msg)

        return result

    # does not eat a trailing newline
    def parse_oneline_statement(self) -> AstStatement:
        result = AstStatement{ location = self.tokens.location }
        if self.tokens.is_keyword("return"):
            self.check_function_or_method("'return'")
            self.tokens++
            result.kind = AstStatementKind.Return
            if self.tokens.kind != TokenKind.Newline:
                result.return_value = malloc(sizeof *result.return_value)
                *result.return_value = self.parse_expression()
        elif self.tokens.is_keyword("assert"):
            assert_keyword = self.tokens++
            match self.what_are_we_parsing:
                case WhatAreWeParsing.FunctionBody | WhatAreWeParsing.MethodBody | WhatAreWeParsing.TopLevel:
                    pass
                case WhatAreWeParsing.ClassBody:
                    fail(assert_keyword.location, "'assert' cannot be placed inside a class unless it is inside a method")
            result.kind = AstStatementKind.Assert
            start = self.tokens
            result.assertion.condition = self.parse_expression_with_unnecessary_parens_warning("assert statement condition")
            end = self.tokens
            result.assertion.condition_str = get_assertion_code_as_string(start, end)
        elif self.tokens.is_keyword("pass"):
            self.tokens++
            result.kind = AstStatementKind.Pass
        elif self.tokens.is_keyword("break"):
            break_keyword = self.tokens++
            if self.loop_vars.len == 0:
                fail(break_keyword.location, "'break' can only be used inside a loop")
            result.kind = AstStatementKind.Break
        elif self.tokens.is_keyword("continue"):
            continue_keyword = self.tokens++
            if self.loop_vars.len == 0:
                fail(continue_keyword.location, "'continue' can only be used inside a loop")
            result.kind = AstStatementKind.Continue
        elif self.tokens.is_keyword("const"):
            self.check_top_level("const definitions")
            location = (self.tokens++).location
            ntv = self.parse_name_type_value("a constant name")
            if ntv.value == NULL:
                fail(location, "constants must have an initial value")
            result.kind = AstStatementKind.Const
            symbol = GlobalSymbol{kind = GlobalSymbolKind.Const}
            assert array_count(symbol.name) >= array_count(ntv.name)
            strcpy(symbol.name, ntv.name)
            result.const_statement = AstConstStatement{symbol = symbol, type = ntv.type, value = *ntv.value}
            free(ntv.value)
        elif self.tokens.is_keyword("typedef"):
            self.check_top_level("typedef statement")
            result.kind = AstStatementKind.TypeDef
            result.typedef_statement = self.parse_typedef()
        elif self.tokens.kind == TokenKind.Name and self.tokens[1].is_operator(":"):
            # e.g. "foo: int"
            match self.what_are_we_parsing:
                case WhatAreWeParsing.TopLevel:
                    fail(self.tokens.location, "missing 'global' or 'const' keyword when defining global variable")
                case WhatAreWeParsing.ClassBody:
                    result.kind = AstStatementKind.ClassField
                    result.class_field = self.parse_name_type_value(NULL)
                    if result.class_field.value != NULL:
                        fail(result.class_field.value.location, "class fields cannot have default values")
                case WhatAreWeParsing.FunctionBody | WhatAreWeParsing.MethodBody:
                    result.kind = AstStatementKind.DeclareLocalVar
                    result.local_var_declare = self.parse_name_type_value(NULL)
        elif (
            self.tokens.kind == TokenKind.Name
            and (
                strcmp(self.tokens.short_string, "let") == 0
                or strcmp(self.tokens.short_string, "var") == 0
            )
            and self.tokens[1].kind == TokenKind.Name
        ):
            msg: byte[200]
            snprintf(msg, sizeof(msg), "there is no '%s' keyword in Jou", self.tokens.short_string)
            fail(self.tokens.location, msg)
        else:
            expr = self.parse_expression()
            result.kind = determine_the_kind_of_a_statement_that_starts_with_an_expression(self.tokens)
            if (
                result.kind == AstStatementKind.Assign
                and self.what_are_we_parsing == WhatAreWeParsing.TopLevel
            ):
                fail(expr.location, "missing 'global' or 'const' keyword when defining global variable")
            if result.kind == AstStatementKind.ExpressionStatement:
                if not expr.is_valid_as_a_statement():
                    fail(expr.location, "not a valid statement")
                result.expression = expr
                self.check_function_or_method("this line of code")
            else:
                self.tokens++
                result.assignment = AstAssignment{target = expr, value = self.parse_expression()}
                if self.tokens.is_operator("="):
                    # Would fail elsewhere anyway, but let's make the error message clear
                    fail(self.tokens.location, "only one variable can be assigned at a time")
                self.check_function_or_method("assignments")

        return result

    def parse_if_statement(self) -> AstIfStatement:
        ifs_and_elifs = List[AstConditionAndBody]{}

        assert self.tokens.is_keyword("if")
        while True:
            self.tokens++
            cond = self.parse_expression_with_unnecessary_parens_warning("if statement condition")
            body = self.parse_body()
            ifs_and_elifs.append(AstConditionAndBody{condition = cond, body = body})
            if not self.tokens.is_keyword("elif"):
                break

        if self.tokens.is_keyword("else"):
            self.tokens++
            if self.tokens.is_keyword("if"):
                fail(self.tokens.location, "use 'elif' instead of 'else if'")
            else_body = self.parse_body()
        else:
            else_body = List[AstStatement]{}

        return AstIfStatement{if_and_elifs = ifs_and_elifs, else_body = else_body}

    def enter_loop_body(self, varname: byte*, location: Location) -> None:
        if varname != NULL:
            for p = self.loop_vars.ptr; p < self.loop_vars.end(); p++:
                if *p != NULL and strcmp(*p, varname) == 0:
                    msg: byte[500]
                    snprintf(msg, sizeof(msg), "this loop is inside another loop that also uses variable '%s'", varname)
                    show_warning(location, msg)
                    break
        self.loop_vars.append(varname)

    def exit_loop_body(self) -> None:
        self.loop_vars.pop()

    def parse_while_loop(self) -> AstConditionAndBody:
        assert self.tokens.is_keyword("while")
        self.check_function_or_method("while loop")
        self.tokens++
        cond = self.parse_expression_with_unnecessary_parens_warning("while loop condition")
        self.enter_loop_body(NULL, Location{})
        body = self.parse_body()
        self.exit_loop_body()
        return AstConditionAndBody{condition = cond, body = body}

    def parse_for_loop(self) -> AstForLoop:
        assert self.tokens.is_keyword("for")
        self.check_function_or_method("for loop")
        self.tokens++

        # Check if it's "for i in ..." loop, those are not supported
        if (
            self.tokens[0].kind == TokenKind.Name
            and self.tokens[1].kind == TokenKind.Name
            and strcmp(self.tokens[1].short_string, "in") == 0
        ):
            fail(self.tokens[1].location, "Python-style for loops aren't supported. Use e.g. 'for i = 0; i < 10; i++'")

        init: AstStatement*
        if self.tokens.is_operator(";"):
            init = NULL
        else:
            init = malloc(sizeof *init)
            *init = self.parse_oneline_statement()

        self.eat_operator(";", True, "a ';'")

        cond: AstExpression*
        if self.tokens.is_operator(";"):
            cond = NULL
        else:
            cond = malloc(sizeof *cond)
            *cond = self.parse_expression()

        self.eat_operator(";", True, "a ';'")

        incr: AstStatement*
        if self.tokens.is_operator(":"):
            incr = NULL
        else:
            incr = malloc(sizeof *incr)
            *incr = self.parse_oneline_statement()

        if (
            init != NULL
            and init.kind == AstStatementKind.Assign
            and init.assignment.target.kind == AstExpressionKind.GetVariable
        ):
            # for varname = value; ...
            self.enter_loop_body(init.assignment.target.varname, init.location)
        else:
            self.enter_loop_body(NULL, Location{})
        body = self.parse_body()
        self.exit_loop_body()

        return AstForLoop{init = init, cond = cond, incr = incr, body = body}

    def parse_match_statement(self) -> AstMatchStatement:
        assert self.tokens.is_keyword("match")
        self.check_function_or_method("match statement")
        self.tokens++

        result = AstMatchStatement{match_obj = self.parse_expression()}

        if self.tokens.is_keyword("with"):
            self.tokens++
            result.func_name = self.eat_by_kind(TokenKind.Name, True, "function name").short_string

        self.parse_start_of_body()

        while self.tokens.kind != TokenKind.Dedent:
            case_keyword = self.eat_keyword("case", True, "the 'case' keyword")
            if result.case_underscore != NULL:
                fail(
                    case_keyword.location,
                    "this case will never run, because 'case _:' above matches anything",
                )

            if (
                self.tokens.kind == TokenKind.Name
                and strcmp(self.tokens.short_string, "_") == 0
                and self.tokens[1].is_operator(":")
            ):
                # case _:
                result.case_underscore_location = (self.tokens++).location
                result.case_underscore = malloc(sizeof(*result.case_underscore))
                assert result.case_underscore != NULL
                *result.case_underscore = self.parse_body()
            else:
                case_objs = flatten_bitwise_ors(self.parse_expression())
                result.cases.append(AstCase{case_objs = case_objs, body = self.parse_body()})
        self.tokens++

        return result

    # Parses the "x: int" part of "x, y, z: int", leaving "y, z: int" to be parsed later.
    def parse_first_of_multiple_local_var_declares(self) -> AstNameTypeValue:
        name_token = self.eat_by_kind(TokenKind.Name, False, NULL)
        ntv = AstNameTypeValue{
            name = name_token.short_string,
            name_location = name_token.location,
        }

        # This skips first variable name and its comma
        skipped_tokens = &self.tokens[1]

        # Skip variables and commas so we can parse the type that comes after it
        while self.tokens.is_operator(",") and self.tokens[1].kind == TokenKind.Name:
            self.tokens = &self.tokens[2]

        # Error for "x, y = 0"
        if self.tokens.is_operator("="):
            fail(self.tokens.location, "only one variable can be assigned at a time")

        self.eat_operator(":", True, "':' and a type after it (example: \"foo, bar: int\")")
        ntv.type = self.parse_type()

        # Error for "x, y: int = 0"
        if self.tokens.is_operator("="):
            fail(self.tokens.location, "only one variable can be assigned at a time")

        self.tokens = skipped_tokens
        return ntv

    def parse_statement(self) -> AstStatement:
        decors_start = self.tokens
        while self.tokens.kind == TokenKind.Decorator:
            self.tokens++
            self.eat_newline()
        decors_end = self.tokens

        if self.tokens.is_keyword("import"):
            result = AstStatement{
                location = self.tokens.location,
                kind = AstStatementKind.Import,
                import_statement = self.parse_import(),
            }
        elif self.tokens.is_keyword("link"):
            result = AstStatement{
                location = self.tokens.location,
                kind = AstStatementKind.Link,
                link_statement = self.parse_link(),
            }
        elif self.tokens.is_keyword("def"):
            match self.what_are_we_parsing:
                case WhatAreWeParsing.TopLevel:
                    result = AstStatement{
                        location = self.tokens.location,
                        kind = AstStatementKind.FunctionDef,
                        function = self.parse_function_or_method(False),
                    }
                case WhatAreWeParsing.ClassBody:
                    result = AstStatement{
                        location = self.tokens.location,
                        kind = AstStatementKind.MethodDef,
                        method = self.parse_function_or_method(True),
                    }
                case WhatAreWeParsing.FunctionBody | WhatAreWeParsing.MethodBody:
                    fail(self.tokens.location, "nested functions are not supported")
        elif self.tokens.is_keyword("declare"):
            self.check_top_level("'declare'")
            location = (self.tokens++).location
            if self.tokens.is_keyword("global"):
                self.tokens++
                ntv = self.parse_name_type_value("a variable name")
                if ntv.value != NULL:
                    fail(
                        ntv.value.location,
                        "a value cannot be given when declaring a global variable",
                    )
                symbol = GlobalSymbol{kind = GlobalSymbolKind.GlobalVar}
                assert array_count(symbol.name) >= array_count(ntv.name)
                strcpy(symbol.name, ntv.name)
                result = AstStatement{
                    location = location,
                    kind = AstStatementKind.GlobalVariableDeclare,
                    global_var_declare = AstGlobalVarDeclare{symbol = symbol, type = ntv.type},
                }
            else:
                astsig = self.parse_function_or_method_signature(False)
                symbol = GlobalSymbol{kind = GlobalSymbolKind.Function}
                assert array_count(symbol.name) >= array_count(astsig.name)
                strcpy(symbol.name, astsig.name)
                result = AstStatement{
                    location = location,
                    kind = AstStatementKind.FunctionDeclare,
                    function = AstFunctionOrMethod{symbol = symbol, ast_signature = astsig},
                }
            self.eat_newline()
        elif self.tokens.is_keyword("global"):
            # Special case for placing "global foo" inside a function or method,
            # like you would need to do in Python
            if (
                (
                    self.what_are_we_parsing == WhatAreWeParsing.FunctionBody
                    or self.what_are_we_parsing == WhatAreWeParsing.MethodBody
                )
                and self.tokens[1].kind == TokenKind.Name
                and self.tokens[2].kind == TokenKind.Newline
            ):
                fail(
                    self.tokens.location,
                    "you don't need 'global' inside a function or method to use a global variable",
                )

            self.check_top_level("global variables")
            location = (self.tokens++).location
            varname = self.eat_by_kind(TokenKind.Name, True, "a variable name").short_string

            if not self.tokens.is_operator(":") and not self.tokens.is_operator("="):
                msg: byte[500]
                snprintf(msg, sizeof(msg), "':' and a type after it (global %s: int) or '=' and a value after it (global %s = 123)", varname, varname)
                self.tokens.fail_expected_got(msg)

            type: AstType* = NULL
            if self.tokens.is_operator(":"):
                self.eat_operator(":", False, NULL)
                type = malloc(sizeof(*type))
                assert type != NULL
                *type = self.parse_type()

            value: AstExpression* = NULL
            if self.tokens.is_operator("="):
                self.eat_operator("=", False, NULL)
                value = malloc(sizeof(*value))
                assert value != NULL
                *value = self.parse_expression()

            symbol = GlobalSymbol{kind = GlobalSymbolKind.GlobalVar}
            assert array_count(symbol.name) >= array_count(varname)
            strcpy(symbol.name, varname)

            result = AstStatement{
                location = location,
                kind = AstStatementKind.GlobalVariableDef,
                global_var_def = AstGlobalVarDef{symbol = symbol, type = type, initial_value = value},
            }
            self.eat_newline()
        elif self.tokens.is_keyword("class"):
            result = AstStatement{
                location = self.tokens.location,
                kind = AstStatementKind.Class,
                classdef = self.parse_class(),
            }
        elif self.tokens.is_keyword("union"):
            result = AstStatement{
                location = self.tokens.location,
                kind = AstStatementKind.ClassUnion,
                union_fields = self.parse_union(),
            }
        elif self.tokens.is_keyword("enum"):
            result = AstStatement{
                location = self.tokens.location,
                kind = AstStatementKind.Enum,
                enumdef = self.parse_enum(),
            }
        elif self.tokens.is_keyword("if"):
            result = AstStatement{
                location = self.tokens.location,
                kind = AstStatementKind.If,
                if_statement = self.parse_if_statement(),
            }
        elif self.tokens.is_keyword("for"):
            result = AstStatement{
                location = self.tokens.location,
                kind = AstStatementKind.ForLoop,
                for_loop = self.parse_for_loop(),
            }
        elif self.tokens.is_keyword("while"):
            result = AstStatement{
                location = self.tokens.location,
                kind = AstStatementKind.WhileLoop,
                while_loop = self.parse_while_loop(),
            }
        elif self.tokens.is_keyword("match"):
            result = AstStatement{
                location = self.tokens.location,
                kind = AstStatementKind.Match,
                match_statement = self.parse_match_statement(),
            }
        elif (
            self.tokens[0].kind == TokenKind.Name
            and self.tokens[1].is_operator(",")
            and self.tokens[2].kind == TokenKind.Name
        ):
            result = AstStatement{
                location = self.tokens.location,
                kind = AstStatementKind.DeclareLocalVar,
                local_var_declare = self.parse_first_of_multiple_local_var_declares(),
            }
        else:
            result = self.parse_oneline_statement()
            self.eat_newline()

        for t = decors_start; t < decors_end; t++:
            if t.kind == TokenKind.Decorator:
                decorate(&result, t.short_string, t.location)

        return result

    def parse_start_of_body(self) -> None:
        self.eat_operator(":", True, "':' followed by a new line with more indentation")
        self.eat_by_kind(TokenKind.Newline, True, "a new line with more indentation after ':'")
        self.eat_by_kind(TokenKind.Indent, True, "more indentation after ':'")

    def parse_body(self) -> List[AstStatement]:
        self.parse_start_of_body()

        result = List[AstStatement]{}
        while self.tokens.kind != TokenKind.Dedent:
            result.append(self.parse_statement())
        self.tokens++
        return result

    def parse_function_or_method(self, is_method: bool) -> AstFunctionOrMethod:
        assert self.tokens.is_keyword("def")
        self.tokens++

        signature = self.parse_function_or_method_signature(is_method)
        if strcmp(signature.name, "__init__") == 0 and is_method:
            fail(signature.name_location, "Jou does not have a special __init__ method like Python")
        if signature.takes_varargs:
            # TODO: Should perhaps be the location of "...", it is kind of hard to access here.
            fail(self.tokens.location, "functions with variadic arguments cannot be defined yet")

        old = self.what_are_we_parsing
        if is_method:
            self.what_are_we_parsing = WhatAreWeParsing.MethodBody
        else:
            self.what_are_we_parsing = WhatAreWeParsing.FunctionBody
        body = self.parse_body()
        self.what_are_we_parsing = old

        symbol = GlobalSymbol{kind = GlobalSymbolKind.Method if is_method else GlobalSymbolKind.Function}
        if is_method:
            assert self.containing_class_name[0] != '\0'
            # Name the symbol e.g. "List.append"
            snprintf(symbol.name, sizeof(symbol.name), "%s.%s", self.containing_class_name, signature.name)
        else:
            assert array_count(symbol.name) >= array_count(signature.name)
            strcpy(symbol.name, signature.name)
            if self.is_main_file and strcmp(symbol.name, "main") == 0:
                # Implicitly public main function
                symbol.public = True

        return AstFunctionOrMethod{symbol = symbol, ast_signature = signature, body = body}

    def parse_class(self) -> AstClassDef:
        assert self.tokens.is_keyword("class")
        self.check_top_level("classes")
        self.tokens++

        name = self.eat_by_kind(TokenKind.Name, True, "a name for the class").short_string
        generics = List[byte[100]]{}

        if self.tokens.is_operator("["):
            self.tokens++
            while not self.tokens.is_operator("]"):
                typevar_token = self.eat_by_kind(TokenKind.Name, True, "name of a generic type variable (typically 'T')")
                generics.append(typevar_token.short_string)
                if not self.tokens.is_operator(","):
                    break
                self.tokens++

            close_bracket = self.eat_operator("]", True, "a ']'")
            if generics.len == 0:
                msg: byte[500]
                snprintf(msg, sizeof(msg), "at least one generic type parameter is needed, e.g. 'class %s[T]:'", name, name)
                fail(close_bracket.location, msg)

        assert self.containing_class_name[0] == '\0'
        self.containing_class_name = name
        old_what_are_we_parsing = self.what_are_we_parsing
        self.what_are_we_parsing = WhatAreWeParsing.ClassBody

        body = self.parse_body()

        self.what_are_we_parsing = old_what_are_we_parsing
        self.containing_class_name = ""

        symbol = GlobalSymbol{kind = (GlobalSymbolKind.GenericClass if generics.len > 0 else GlobalSymbolKind.Type)}
        assert array_count(symbol.name) >= array_count(name)
        strcpy(symbol.name, name)

        return AstClassDef{symbol = symbol, generic_typevar_names = generics, body = body}

    def parse_union(self) -> List[AstNameTypeValue]:
        union_keyword = self.eat_keyword("union", False, NULL)
        if self.what_are_we_parsing != WhatAreWeParsing.ClassBody:
            fail(union_keyword.location, "'union' can only be used inside a class")
        self.parse_start_of_body()

        result = List[AstNameTypeValue]{}
        while self.tokens.kind != TokenKind.Dedent:
            field = self.parse_name_type_value("a union member")
            if field.value != NULL:
                fail(field.value.location, "union members cannot have default values")

            result.append(field)
            self.eat_newline()
        self.tokens++

        if result.len < 2:
            fail(union_keyword.location, "unions must have at least 2 members")
        return result

    def parse_enum(self) -> AstEnumDef:
        assert self.tokens.is_keyword("enum")
        self.check_top_level("enums")
        self.tokens++

        enum_name = self.eat_by_kind(TokenKind.Name, True, "a name for the enum")

        symbol = GlobalSymbol{kind = GlobalSymbolKind.Type}
        assert array_count(symbol.name) >= array_count(enum_name.short_string)
        strcpy(symbol.name, enum_name.short_string)

        result = AstEnumDef{symbol = symbol, name_location = enum_name.location}

        self.parse_start_of_body()
        while self.tokens.kind != TokenKind.Dedent:
            member_name = self.eat_by_kind(TokenKind.Name, True, "a name for an enum member")

            for p = result.members.ptr; p < result.members.end(); p++:
                if strcmp(*p, member_name.short_string) == 0:
                    assert sizeof member_name.short_string == 100
                    error: byte[200]
                    sprintf(error, "the enum has two members named '%s'", member_name.short_string)
                    fail(member_name.location, error)

            result.members.append(member_name.short_string)
            self.eat_newline()

        self.tokens++
        return result

@public
def parse(tokens: Token*, is_main_file: bool) -> List[AstStatement]:
    parser = Parser{tokens = tokens, is_main_file = is_main_file}
    result = List[AstStatement]{}

    while parser.tokens.kind != TokenKind.EndOfFile:
        result.append(parser.parse_statement())

    assert parser.loop_vars.len == 0
    free(parser.loop_vars.ptr)
    return result
