import "stdlib/str.jou"
import "stdlib/mem.jou"

import "./ast.jou"
import "./errors_and_warnings.jou"
import "./constants.jou"
import "./types.jou"


@public
def evaluate_array_length(expr: AstExpression*) -> int:
    if expr->kind == AstExpressionKind.Int:
        return expr->int_value
    fail(expr->location, "cannot evaluate array length at compile time")


@public
def get_special_constant(name: byte*) -> int:
    match name with strcmp:
        case "WINDOWS":
            return WINDOWS as int
        case "MACOS":
            return MACOS as int
        case "NETBSD":
            return NETBSD as int
        case _:
            return -1


@public
def evaluate_constant_expression(expr: AstExpression*, result: Constant*) -> bool:
    msg: byte[500]
    left: Constant
    right: Constant

    match expr->kind:
        case AstExpressionKind.Int:
            *result = int_constant(intType, expr->int_value)
            return True

        case AstExpressionKind.Bool:
            result->kind = ConstantKind.Bool
            result->boolean = expr->bool_value
            return True

        case AstExpressionKind.GetVariable:
            # Handle special constants like WINDOWS, MACOS, etc.
            val = get_special_constant(expr->varname)
            if val == -1:
                return False
            result->kind = ConstantKind.Bool
            result->boolean = val != 0
            return True

        case AstExpressionKind.And:
            if not evaluate_constant_expression(&expr->operands[0], &left):
                return False
            if left.kind != ConstantKind.Bool:
                fail(expr->location, "left side of 'and' must be a bool")
            
            # Short circuit if left is false
            if not left.boolean:
                result->kind = ConstantKind.Bool
                result->boolean = False
                return True

            if not evaluate_constant_expression(&expr->operands[1], &right):
                return False
            if right.kind != ConstantKind.Bool:
                fail(expr->location, "right side of 'and' must be a bool")

            result->kind = ConstantKind.Bool
            result->boolean = right.boolean
            return True

        case AstExpressionKind.Or:
            if not evaluate_constant_expression(&expr->operands[0], &left):
                return False
            if left.kind != ConstantKind.Bool:
                fail(expr->location, "left side of 'or' must be a bool")
            
            # Short circuit if left is true
            if left.boolean:
                result->kind = ConstantKind.Bool
                result->boolean = True
                return True

            if not evaluate_constant_expression(&expr->operands[1], &right):
                return False
            if right.kind != ConstantKind.Bool:
                fail(expr->location, "right side of 'or' must be a bool")

            result->kind = ConstantKind.Bool
            result->boolean = right.boolean
            return True

        case AstExpressionKind.Not:
            if not evaluate_constant_expression(&expr->operands[0], &left):
                return False
            if left.kind != ConstantKind.Bool:
                fail(expr->location, "operand of 'not' must be a bool")

            result->kind = ConstantKind.Bool
            result->boolean = not left.boolean
            return True

        case _:
            snprintf(msg, sizeof(msg), "expression cannot be evaluated at compile time")
            fail(expr->location, msg)
            return False


def evaluate_condition(expr: AstExpression*) -> int:  # 1=true 0=false -1=error
    result: Constant
    if not evaluate_constant_expression(expr, &result):
        return -1
    
    if result.kind != ConstantKind.Bool:
        return -1
    
    return result.boolean as int


# returns the statements to replace if statement with, as a pointer inside if_stmt
def choose_if_elif_branch(if_stmt: AstIfStatement*) -> AstBody*:
    for i = 0; i < if_stmt->n_if_and_elifs; i++:
        match evaluate_condition(&if_stmt->if_and_elifs[i].condition):
            case -1:
                # don't know how to evaluate it
                return NULL
            case 0:
                # try the next elif or else
                pass
            case 1:
                # condition is true, let's use this if or elif
                return &if_stmt->if_and_elifs[i].body
            case _:
                assert False
    return &if_stmt->else_body


# Replace body->statements[i] with zero or more statements from another body.
def replace(body: AstBody*, i: int, new: AstBody) -> None:
    body->statements[i].free()

    item_size = sizeof(body->statements[0])
    body->statements = realloc(body->statements, (body->nstatements + new.nstatements) * item_size)
    memmove(&body->statements[i + new.nstatements], &body->statements[i+1], (body->nstatements - (i+1)) * item_size)
    memcpy(&body->statements[i], new.statements, new.nstatements * item_size)

    free(new.statements)
    body->nstatements--
    body->nstatements += new.nstatements


def evaluate_if_statements_in_body(body: AstBody*, must_succeed: bool) -> None:
    for i = 0; i < body->nstatements; i++:
        match body->statements[i].kind:
            case AstStatementKind.If:
                if_stmt = &body->statements[i].if_statement

                ptr = choose_if_elif_branch(if_stmt)
                if ptr == NULL and must_succeed:
                    fail(body->statements[i].location, "cannot evaluate condition at compile time")

                if ptr != NULL:
                    replacement = *ptr
                    *ptr = AstBody{}  # avoid double-free
                    replace(body, i, replacement)
                    i--  # cancels i++ to do same index again, so that we handle nested if statements
                    continue

                # Recurse into inner if statements. Needed when compile-time if
                # statement is inside a runtime if statement.
                for k = 0; k < if_stmt->n_if_and_elifs; k++:
                    evaluate_if_statements_in_body(&if_stmt->if_and_elifs[k].body, False)
                evaluate_if_statements_in_body(&if_stmt->else_body, False)

            case AstStatementKind.WhileLoop:
                evaluate_if_statements_in_body(&body->statements[i].while_loop.body, False)
            case AstStatementKind.ForLoop:
                evaluate_if_statements_in_body(&body->statements[i].for_loop.body, False)
            case AstStatementKind.Class:
                evaluate_if_statements_in_body(body->statements[i].classdef.body, True)
            case AstStatementKind.FunctionDef:
                evaluate_if_statements_in_body(&body->statements[i].function.body, False)
            case AstStatementKind.MethodDef:
                evaluate_if_statements_in_body(&body->statements[i].method.body, False)
            case (
                AstStatementKind.ExpressionStatement
                | AstStatementKind.Link
                | AstStatementKind.Assert
                | AstStatementKind.Pass
                | AstStatementKind.Return
                | AstStatementKind.Match
                | AstStatementKind.Break
                | AstStatementKind.Continue
                | AstStatementKind.DeclareLocalVar
                | AstStatementKind.Assign
                | AstStatementKind.InPlaceAdd
                | AstStatementKind.InPlaceSub
                | AstStatementKind.InPlaceMul
                | AstStatementKind.InPlaceDiv
                | AstStatementKind.InPlaceMod
                | AstStatementKind.FunctionDeclare
                | AstStatementKind.Enum
                | AstStatementKind.GlobalVariableDeclare
                | AstStatementKind.GlobalVariableDef
                | AstStatementKind.Import
                | AstStatementKind.ClassField
                | AstStatementKind.ClassUnion
                | AstStatementKind.ConstDecl
            ):
                # these statements cannot contain if statements, no need to recurse inside
                pass


@public
def evaluate_compile_time_if_statements(file: AstFile*) -> None:
    evaluate_if_statements_in_body(&file->body, True)
