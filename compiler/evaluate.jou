import "stdlib/assert.jou"
import "stdlib/io.jou"
import "stdlib/str.jou"
import "stdlib/list.jou"
import "stdlib/mem.jou"

import "./ast.jou"
import "./typecheck/common.jou"
import "./typecheck/step1_global_symbols.jou"
import "./state.jou"
import "./errors_and_warnings.jou"
import "./constants.jou"
import "./types.jou"


@public
def get_special_constant(name: byte*) -> Constant*:
    if global_compiler_state.special_constants[0].name == NULL:
        # called for the first time, initialize special constants
        global_compiler_state.special_constants = [
            SpecialConstant{name = "WINDOWS", constant = Constant{kind = ConstantKind.Bool, boolean = WINDOWS}},
            SpecialConstant{name = "MACOS", constant = Constant{kind = ConstantKind.Bool, boolean = MACOS}},
            SpecialConstant{name = "NETBSD", constant = Constant{kind = ConstantKind.Bool, boolean = NETBSD}},
        ]

    n = sizeof(global_compiler_state.special_constants) / sizeof(global_compiler_state.special_constants[0])
    for i = 0; i < n; i++:
        if strcmp(global_compiler_state.special_constants[i].name, name) == 0:
            return &global_compiler_state.special_constants[i].constant
    return NULL


# Return values: 1=true 0=false -1=error
def evaluate_boolean_and_or(jou_file: JouFile*, expr: AstExpression*, and_or: byte*) -> int:
    assert strcmp(and_or, "and") == 0 or strcmp(and_or, "or") == 0

    value: Constant
    if not evaluate_constant_expression(jou_file, expr, &value, bool_type()):
        return -1

    if value.kind != ConstantKind.Bool:
        # Use the same error message as typecheck
        msg: byte[500]
        snprintf(msg, sizeof(msg), "'%s' only works with bools, not %s", and_or, value.get_type().name)
        fail(expr.location, msg)

    return value.boolean as int


# Returns False if the expression is not a simple compile-time constant.
#
# As the naming suggests, the type hint is only a hint and result type may differ.
# Set the type hint to NULL if you don't care about it.
@public
def evaluate_constant_expression(jou_file: JouFile*, expr: AstExpression*, result: Constant*, type_hint: Type*) -> bool:
    msg: byte[500]

    match expr.kind:
        case AstExpressionKind.IntegerConstant:
            if type_hint != NULL and type_hint.is_integer_type():
                t = type_hint
            else:
                t = int_type(32)

            if expr.integer_value > t.max_value():
                snprintf(msg, sizeof(msg), "value does not fit into %s", t.name)
                fail(expr.location, msg)

            *result = int_constant(t, expr.integer_value as int64)
            return True

        case AstExpressionKind.Constant:
            *result = expr.constant.copy()
            return True

        case AstExpressionKind.EnumCount:
            enum_type = type_from_ast(jou_file, NULL, &expr.enumcount.enum_type_ast)
            if enum_type.kind != TypeKind.Enum:
                snprintf(msg, sizeof(msg), "enum_count must be called on an enum type, not %s", enum_type.short_description())
                fail(expr.location, msg)
            expr.enumcount.enum_type = enum_type
            *result = int_constant(int_type(32), enum_type.enum_members.len)
            return True

        case AstExpressionKind.GetVariable:
            if jou_file == NULL:
                # Only special constants are supported here
                c = get_special_constant(expr.varname)
            else:
                # Can e.g. refer to values of `const` constants
                c = find_and_typecheck_constant(jou_file, expr.varname)

            if c == NULL:
                return False
            *result = c.copy()
            return True

        case AstExpressionKind.And:
            lhs = evaluate_boolean_and_or(jou_file, &expr.operands[0], "and")
            rhs = evaluate_boolean_and_or(jou_file, &expr.operands[1], "and")
            if lhs == -1 or rhs == -1:
                return False
            *result = Constant{kind = ConstantKind.Bool, boolean = (lhs == 1 and rhs == 1)}
            return True

        case AstExpressionKind.Or:
            lhs = evaluate_boolean_and_or(jou_file, &expr.operands[0], "or")
            rhs = evaluate_boolean_and_or(jou_file, &expr.operands[1], "or")
            if lhs == -1 or rhs == -1:
                return False
            *result = Constant{kind = ConstantKind.Bool, boolean = (lhs == 1 or rhs == 1)}
            return True

        case AstExpressionKind.Not:
            if not evaluate_constant_expression(jou_file, &expr.operands[0], result, bool_type()):
                return False

            if result.kind != ConstantKind.Bool:
                # Error message is same as during type checking
                snprintf(msg, sizeof(msg), "value after 'not' must be a bool, not %s", result.get_type().name)
                fail(expr.location, msg)

            result.boolean = not result.boolean
            return True

        case AstExpressionKind.Negate:
            # Special-case e.g. "const foo: int8 = -128" because 128 is not a
            # valid int8 but -128 is, so can't just evaluate 128 and add minus.
            if (
                type_hint != NULL
                and type_hint.is_integer_type()
                and expr.operands[0].kind == AstExpressionKind.IntegerConstant
                and expr.operands[0].integer_value == (-type_hint.min_value()) as uint64
            ):
                *result = int_constant(type_hint, type_hint.min_value())
                return True

            if not evaluate_constant_expression(jou_file, &expr.operands[0], result, type_hint):
                return False

            match result.get_type().kind:
                case TypeKind.SignedInteger:
                    # Negating the smallest signed integer would overflow.
                    # For example, int8 goes from -128 to +127.
                    # TODO: test this when possible
                    if result.integer.value == result.get_type().min_value():
                        return False
                    result.integer.value *= -1
                    return True
                case TypeKind.FloatingPoint:
                    old_string: byte[100] = result.float_or_double_text
                    if old_string[0] == '-':
                        # Remove minus sign in beginning: -(-1.0) becomes 1.0
                        strcpy(result.float_or_double_text, &old_string[1])
                        return True
                    elif strlen(old_string) + 1 < sizeof(result.float_or_double_text):
                        # Add minus to beginning
                        sprintf(result.float_or_double_text, "-%s", old_string)
                        return True
                    else:
                        return False
                case _:
                    return False

        case _:
            return False


@public
def evaluate_array_length(expr: AstExpression*) -> int:
    # TODO: this should probably support int64
    c: Constant
    if evaluate_constant_expression(NULL, expr, &c, int_type(32)) and c.get_type() == int_type(32):
        return c.integer.value as int
    fail(expr.location, "cannot evaluate array length at compile time")


def choose_if_elif_branch(if_stmt: AstIfStatement*) -> List[AstStatement]*:
    cond: Constant

    # Return the first branch whose condition is true.
    # Return NULL if we fail to evaluate a condition and it must be checked at runtime.
    for p = if_stmt.if_and_elifs.ptr; p < if_stmt.if_and_elifs.end(); p++:
        if (not evaluate_constant_expression(NULL, &p.condition, &cond, bool_type())) or cond.kind != ConstantKind.Bool:
            return NULL

        if cond.boolean:
            return &p.body

    # All conditions are known to be false.
    return &if_stmt.else_body


# Replaces the statement body.ptr[i] with statements from a given list.
def replace(body: List[AstStatement]*, i: int, new: List[AstStatement]) -> None:
    body.ptr[i].free()
    body.grow(body.len + new.len)

    # How many statements after index i we want to preserve
    nkeep = body.len - (i+1)

    # Delete body.ptr[i] and shift everything after it to their new place
    memmove(&body.ptr[i + new.len], &body.ptr[i+1], nkeep * sizeof(body.ptr[0]))

    # Put the new statements to their place.
    memcpy(&body.ptr[i], new.ptr, new.len * sizeof(new.ptr[0]))

    body.len += new.len - 1  # -1 for index i which was removed


def evaluate_if_statements_in_body(body: List[AstStatement]*, must_succeed: bool) -> None:
    # Must use indexes, because mutating the body may reallocate it to different memory location.
    for i = 0; i < body.len; i++:
        match body.ptr[i].kind:
            case AstStatementKind.If:
                if_stmt = &body.ptr[i].if_statement

                branch = choose_if_elif_branch(if_stmt)
                if branch == NULL and must_succeed:
                    fail(body.ptr[i].location, "cannot evaluate condition at compile time")

                if branch != NULL:
                    # The if/elif statement always takes the same branch.
                    # Replace the whole if/elif with that branch.
                    replacement = *branch
                    *branch = List[AstStatement]{}  # avoid double-free
                    replace(body, i, replacement)
                    free(replacement.ptr)
                    i--  # cancels i++ to do same index again, so that we handle nested if statements
                    continue

                # Recurse into inner if statements. Needed when compile-time if
                # statement is inside a runtime if statement.
                for p = if_stmt.if_and_elifs.ptr; p < if_stmt.if_and_elifs.end(); p++:
                    evaluate_if_statements_in_body(&p.body, False)
                evaluate_if_statements_in_body(&if_stmt.else_body, False)

            case AstStatementKind.WhileLoop:
                evaluate_if_statements_in_body(&body.ptr[i].while_loop.body, False)
            case AstStatementKind.ForLoop:
                evaluate_if_statements_in_body(&body.ptr[i].for_loop.body, False)
            case AstStatementKind.Class:
                evaluate_if_statements_in_body(&body.ptr[i].classdef.body, True)
            case AstStatementKind.FunctionDef:
                evaluate_if_statements_in_body(&body.ptr[i].function.body, False)
            case AstStatementKind.MethodDef:
                evaluate_if_statements_in_body(&body.ptr[i].method.body, False)
            case (
                AstStatementKind.ExpressionStatement
                | AstStatementKind.Link
                | AstStatementKind.Assert
                | AstStatementKind.Pass
                | AstStatementKind.Return
                | AstStatementKind.Match
                | AstStatementKind.Break
                | AstStatementKind.Continue
                | AstStatementKind.DeclareLocalVar
                | AstStatementKind.Assign
                | AstStatementKind.InPlaceAdd
                | AstStatementKind.InPlaceSub
                | AstStatementKind.InPlaceMul
                | AstStatementKind.InPlaceDiv
                | AstStatementKind.InPlaceMod
                | AstStatementKind.InPlaceBitAnd
                | AstStatementKind.InPlaceBitOr
                | AstStatementKind.InPlaceBitXor
                | AstStatementKind.InPlaceBitShiftLeft
                | AstStatementKind.InPlaceBitShiftRight
                | AstStatementKind.FunctionDeclare
                | AstStatementKind.Enum
                | AstStatementKind.GlobalVariableDeclare
                | AstStatementKind.GlobalVariableDef
                | AstStatementKind.Import
                | AstStatementKind.ClassField
                | AstStatementKind.ClassUnion
                | AstStatementKind.Const
                | AstStatementKind.TypeDef
            ):
                # these statements cannot contain if statements, no need to recurse inside
                pass


@public
def evaluate_compile_time_if_statements(jou_file: JouFile*) -> None:
    evaluate_if_statements_in_body(&jou_file.ast, True)
