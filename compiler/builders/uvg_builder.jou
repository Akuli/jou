import "stdlib/str.jou"
import "stdlib/mem.jou"

import "../ast.jou"
import "../errors_and_warnings.jou"
import "../types.jou"
import "../uvg.jou"
import "./either_builder.jou"
import "./ast_to_builder.jou"


# Within this class, UVG variable ID -1 denotes a value that is not a pointer,
# or is some pointer that we don't keep track of. Any other ID represents a
# pointer to the corresponding UVG variable.
class UBuilder:
    uvg: Uvg
    current_block: UvgBlock*
    returns_a_value: bool
    location: Location

    def begin_function(self, sig: Signature*, public: bool) -> None:
        self->returns_a_value = sig->returntype != NULL
        self_class = sig->get_self_class()
        if self_class == NULL:
            # function
            assert sizeof(self->uvg.name) >= sizeof(sig->name)
            strcpy(self->uvg.name, sig->name)
        else:
            # method
            snprintf(self->uvg.name, sizeof self->uvg.name, "%s.%s", self_class->name, sig->name)

        self->current_block = self->uvg.add_block()

    def end_function(self) -> None:
        pass

    def set_location(self, location: Location) -> None:
        self->location = location

    def add_instruction(self, ins: UvgInstruction) -> None:
        assert ins.x >= 0

        assert self->location.path != NULL
        assert self->location.lineno != 0
        ins.location = self->location

        b = self->current_block
        assert b != NULL

        b->instructions = realloc(b->instructions, sizeof(b->instructions[0]) * (b->ninstructions + 1))
        assert b->instructions != NULL
        b->instructions[b->ninstructions++] = ins

    def use_deref(self, x: int) -> None:
        if x != -1:
            self->add_instruction(UvgInstruction{kind = UvgInstructionKind.UseDerefX, x = x})

    def set_deref(self, x: int) -> None:
        if x != -1:
            self->add_instruction(UvgInstruction{kind = UvgInstructionKind.SetDerefX, x = x})

    def dont_analyze(self, x: int) -> None:
        if x != -1:
            self->add_instruction(UvgInstruction{kind = UvgInstructionKind.DontAnalyzeX, x = x})

    def stack_alloc(self, t: Type*, varname: byte*) -> int:
        if varname != NULL:
            # Currently the UVG does not support multiple variables with the same name.
            assert not self->uvg.has_local_var(varname)
        return self->uvg.get_local_var_ptr(varname)

    def set_ptr(self, ptr: int, value: int) -> None:
        self->set_deref(ptr)

    def dereference(self, ptr: int) -> int:
        # TODO: this causes the compiler to give up on "x = &y"
        self->use_deref(ptr)
        return -1

    def indexed_pointer(self, ptr: int, index: int) -> int:
        self->dont_analyze(ptr)
        return -1

    def class_field_pointer(self, ptr: int, field_name: byte*) -> int:
        self->dont_analyze(ptr)
        return -1

    def global_var_ptr(self, name: byte*, var_type: Type*) -> int:
        return -1

    def get_argument(self, i: int, argtype: Type*) -> int:
        return -1

    def call(self, sig: Signature*, args: int*, nargs: int) -> int:
        for i = 0; i < nargs; i++:
            self->dont_analyze(args[i])
        return -1

    def string_array(self, s: byte*, array_size: int) -> int:
        return -1

    def string(self, s: byte*) -> int:
        return -1

    def boolean(self, b: bool) -> int:
        return -1

    def integer(self, t: Type*, value: long) -> int:
        return -1

    def float_or_double(self, t: Type*, string: byte*) -> int:
        return -1

    def zero_of_type(self, t: Type*) -> int:
        return -1

    def enum_member(self, t: Type*, name: byte*) -> int:
        return -1

    # a + b
    def add(self, a: int, b: int) -> int:
        return -1

    # a - b
    def sub(self, a: int, b: int) -> int:
        return -1

    # a * b
    def mul(self, a: int, b: int) -> int:
        return -1

    # a / b
    def div(self, a: int, b: int) -> int:
        return -1

    # a % b
    def mod(self, a: int, b: int) -> int:
        return -1

    # a == b
    def eq(self, a: int, b: int) -> int:
        return -1

    # a < b
    def lt(self, a: int, b: int) -> int:
        return -1

    # not value
    def not_(self, value: int) -> int:
        return -1

    # sizeof(any value of given type)
    def size_of(self, t: Type*) -> int:
        return -1

    # memset(ptr, 0, sizeof(*ptr))
    def memset_to_zero(self, ptr: int) -> None:
        self->set_deref(ptr)

    # value as to
    def cast(self, value: int, to: Type*) -> int:
        if to->is_pointer_type():
            return value
        else:
            # e.g. cast pointer to long
            self->dont_analyze(value)
            return -1

    # Blocks are used to implement e.g. if statements and loops.
    def add_block(self) -> UvgBlock*:
        return self->uvg.add_block()

    # Decide which block will contain the resulting instructions.
    def set_current_block(self, block: UvgBlock*) -> None:
        self->current_block = block

    def branch(self, cond: int, then: UvgBlock*, otherwise: UvgBlock*) -> None:
        # TODO: do something with cond?
        assert self->current_block != NULL
        assert self->current_block->terminator.kind == UvgTerminatorKind.NotSet
        self->current_block->terminator = UvgTerminator{
            kind = UvgTerminatorKind.Branch,
            branch = UvgBranch{then = then, otherwise = otherwise},
        }
        self->current_block = NULL

    def jump(self, next_block: UvgBlock*) -> None:
        assert self->current_block != NULL
        assert self->current_block->terminator.kind == UvgTerminatorKind.NotSet
        self->current_block->terminator = UvgTerminator{
            kind = UvgTerminatorKind.Jump,
            jump_block = next_block,
        }
        self->current_block = NULL

    def unreachable(self) -> None:
        assert self->current_block != NULL
        assert self->current_block->terminator.kind == UvgTerminatorKind.NotSet
        self->current_block->terminator = UvgTerminator{kind = UvgTerminatorKind.Unreachable}
        self->current_block = NULL

    def ret(self, value: int*) -> None:
        if value != NULL:
            self->set_deref(self->uvg.get_local_var_ptr("return"))

        if self->returns_a_value:
            self->use_deref(self->uvg.get_local_var_ptr("return"))

        assert self->current_block != NULL
        assert self->current_block->terminator.kind == UvgTerminatorKind.NotSet
        self->current_block->terminator = UvgTerminator{kind = UvgTerminatorKind.Return}


@public
def build_uvg(func_ast: AstFunctionOrMethod*, func_location: Location) -> Uvg:
    builder = UBuilder{}
    builder_wrapper = EitherBuilder{ubuilder = &builder}
    feed_ast_to_builder(func_ast, func_location, &builder_wrapper)
    return builder.uvg
