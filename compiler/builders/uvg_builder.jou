import "stdlib/str.jou"
import "stdlib/mem.jou"

import "../ast.jou"
import "../types.jou"
import "../uvg.jou"
import "./either_builder.jou"
import "./ast_to_builder.jou"


# Within this class, UVG value id -1 denotes an anonymous value that is not undefined.
# This "optimization" makes the resulting UVGs much smaller and simpler.
class UBuilder:
    uvg: Uvg
    current_block: UvgBlock*

    def begin_function(self, sig: Signature*, public: bool) -> None:
        self_class = sig->get_self_class()
        if self_class == NULL:
            # function
            assert sizeof(self->uvg.name) >= sizeof(sig->name)
            strcpy(self->uvg.name, sig->name)
        else:
            # method
            snprintf(self->uvg.name, sizeof self->uvg.name, "%s.%s", self_class->name, sig->name)

        self->current_block = self->uvg.add_block()

    def end_function(self) -> None:
        pass

    def add_instruction(self, ins: UvgInstruction) -> None:
        assert ins.x >= 0
        assert ins.y >= 0  # 0 if not used

        b = self->current_block
        assert b != NULL

        b->instructions = realloc(b->instructions, sizeof(b->instructions[0]) * (b->ninstructions + 1))
        assert b->instructions != NULL
        b->instructions[b->ninstructions++] = ins

    def use(self, x: int) -> None:
        if x != -1:
            self->add_instruction(UvgInstruction{kind = UvgInstructionKind.UseX, x = x})

    def set(self, x: int) -> None:
        if x != -1:
            self->add_instruction(UvgInstruction{kind = UvgInstructionKind.SetX, x = x})

    def use_deref(self, x: int) -> None:
        if x != -1:
            self->add_instruction(UvgInstruction{kind = UvgInstructionKind.UseDerefX, x = x})

    def set_deref(self, x: int) -> None:
        if x != -1:
            self->add_instruction(UvgInstruction{kind = UvgInstructionKind.SetDerefX, x = x})

    def set_x_to_address_of_y(self, x: int, y: int) -> None:
        # The case "set -1 to address of some_actual_variable" is difficult. It
        # should be preserved, because it might mean that we cannot analyze
        # whether the variable is undefined. Can be added later if needed.
        assert not (x == -1 and y != -1)
        if x != -1 and y != -1:
            self->add_instruction(UvgInstruction{kind = UvgInstructionKind.SetXToAddressOfY, x = x, y = y})

    def stack_alloc(self, t: Type*, varname: byte*) -> int:
        underlying_value = self->uvg.add_value(varname)
        ptr = self->uvg.add_value(NULL)
        self->set_x_to_address_of_y(ptr, underlying_value)
        return ptr

    def set_ptr(self, ptr: int, value: int) -> None:
        self->use(value)
        self->set_deref(ptr)

    def dereference(self, ptr: int) -> int:
        self->use_deref(ptr)
        return -1

    def indexed_pointer(self, ptr: int, index: int) -> int:
        self->use(ptr)
        self->use(index)
        return -1

    def class_field_pointer(self, ptr: int, field_name: byte*) -> int:
        self->use(ptr)
        return -1

    def global_var_ptr(self, name: byte*, var_type: Type*) -> int:
        return -1

    def get_argument(self, i: int, argtype: Type*) -> int:
        return -1

    def call(self, sig: Signature*, args: int*, nargs: int) -> int:
        for i = 0; i < nargs; i++:
            self->use(args[i])
        return -1

    def string_array(self, s: byte*, array_size: int) -> int:
        return -1

    def string(self, s: byte*) -> int:
        return -1

    def boolean(self, b: bool) -> int:
        return -1

    def integer(self, t: Type*, value: long) -> int:
        return -1

    def float_or_double(self, t: Type*, string: byte*) -> int:
        return -1

    def zero_of_type(self, t: Type*) -> int:
        return -1

    def enum_member(self, t: Type*, name: byte*) -> int:
        return -1

    # a + b
    def add(self, a: int, b: int) -> int:
        self->use(a)
        self->use(b)
        return -1

    # a - b
    def sub(self, a: int, b: int) -> int:
        self->use(a)
        self->use(b)
        return -1

    # a * b
    def mul(self, a: int, b: int) -> int:
        self->use(a)
        self->use(b)
        return -1

    # a / b
    def div(self, a: int, b: int) -> int:
        self->use(a)
        self->use(b)
        return -1

    # a % b
    def mod(self, a: int, b: int) -> int:
        self->use(a)
        self->use(b)
        return -1

    # a == b
    def eq(self, a: int, b: int) -> int:
        self->use(a)
        self->use(b)
        return -1

    # a < b
    def lt(self, a: int, b: int) -> int:
        self->use(a)
        self->use(b)
        return -1

    # not value
    def not_(self, value: int) -> int:
        self->use(value)
        return -1

    # sizeof(any value of given type)
    def size_of(self, t: Type*) -> int:
        return -1

    # memset(ptr, 0, sizeof(*ptr))
    def memset_to_zero(self, ptr: int) -> None:
        self->use(ptr)
        self->set_deref(ptr)

    # value as to
    def cast(self, value: int, to: Type*) -> int:
        self->use(value)
        return -1

    # Blocks are used to implement e.g. if statements and loops.
    def add_block(self) -> UvgBlock*:
        return self->uvg.add_block()

    # Decide which block will contain the resulting instructions.
    def set_current_block(self, block: UvgBlock*) -> None:
        self->current_block = block

    def branch(self, cond: int, then: UvgBlock*, otherwise: UvgBlock*) -> None:
        assert False  # TODO

    def jump(self, next_block: UvgBlock*) -> None:
        assert False  # TODO

    def unreachable(self) -> None:
        # TODO: figure out what to do here
        self->current_block->terminator = UvgTerminator{kind = UvgTerminatorKind.ExitProgram}

    def ret(self, value: int*) -> None:
        if value != NULL:
            self->use(*value)
            self->set(self->uvg.value_id_for_varname("return"))
        assert self->current_block != NULL
        assert self->current_block->terminator.kind == UvgTerminatorKind.NotSet
        self->current_block->terminator = UvgTerminator{kind = UvgTerminatorKind.Return}


@public
def build_uvg(ast: AstFunctionOrMethod*) -> Uvg:
    builder = UBuilder{}
    builder_wrapper = EitherBuilder{ubuilder = &builder}
    feed_ast_to_builder(ast, &builder_wrapper)
    return builder.uvg
