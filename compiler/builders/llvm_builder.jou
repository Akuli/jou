# This file abstracts away all LLVM things needed to build the LLVM IR for a
# function or method.
#
# The idea is that instead of building just LLVM IR, we can also build other
# useful data structures by modifying only the IR builder, such as UVG. This
# means we don't walk through the AST in multiple different places that could
# handle some corner cases differently.
#
# !!!!!!!!!!!!!!!!!!!!!!!!!!
# !! Thread Safety Notice !!
# !!!!!!!!!!!!!!!!!!!!!!!!!!
# LLVM IR is built using multiple threads, so be careful when you access global
# state from here. Any kind of mutation of global state (e.g. getting a type
# that may or may not exist yet) is almost certainly wrong and will cause bugs
# that are difficult to reproduce and debug. Note that if the hash builder gets
# a type, then that type will surely exist when we build LLVM IR, because we
# need hashes to check whether the object file needs to be rebuilt.

import "stdlib/assert.jou"
import "stdlib/limits.jou"
import "stdlib/math.jou"
import "stdlib/mem.jou"
import "stdlib/str.jou"
import "stdlib/io.jou"
import "stdlib/list.jou"

import "../ast.jou"
import "../global_symbols.jou"
import "../errors_and_warnings.jou"
import "../llvm.jou"
import "../state.jou"
import "../types.jou"
import "./any_builder.jou"
import "./ast_to_builder.jou"


# LLVM doesn't have a built-in union type, and you're supposed to abuse other types for that:
# https://mapping-high-level-constructs-to-llvm-ir.readthedocs.io/en/latest/basic-constructs/unions.html
#
# My first idea was to use an array of bytes that is big enough to fit anything.
# However, that might not be aligned properly.
#
# Then I tried choosing the member type that has the biggest align, and making a large enough array of it.
# Because the align is always a power of two, the memory will be suitably aligned for all member types.
# But it didn't work for some reason I still don't understand.
#
# Then I figured out how clang does it and did it the same way.
# We make a struct that contains:
# - the most aligned type as chosen before
# - array of i8 as padding to make it the right size.
# But for some reason that didn't work either.
#
# As a "last resort" I just use an array of i64 large enough and hope it's aligned as needed.
def union_type_to_llvm(state: ThreadLocalCompilerState*, types: LLVMType**, ntypes: int) -> LLVMType*:
    if ntypes == 1:
        return types[0]

    sizeneeded = 0 as int64
    for i = 0; i < ntypes; i++:
        size1 = LLVMABISizeOfType(state.target.data, types[i])
        size2 = LLVMStoreSizeOfType(state.target.data, types[i])

        # If this assert fails, you need to figure out which of the size functions should be used.
        # I don't know what their difference is.
        # And if you need the alignment, there's 3 different functions for that...
        assert size1 == size2
        sizeneeded = llmax(sizeneeded, size1)

    return LLVMArrayType(type_to_llvm(state, int_type(64)), ((sizeneeded+7)/8) as int)


def class_type_to_llvm(state: ThreadLocalCompilerState*, type: Type*) -> LLVMType*:
    assert type.kind == TypeKind.Class

    n = type.classdata.fields.len

    flat_elems: LLVMType** = malloc(sizeof(flat_elems[0]) * n)
    for i = 0; i < n; i++:
        flat_elems[i] = type_to_llvm(state, type.classdata.fields.ptr[i].type)

    # Combine together fields of the same union.
    combined: LLVMType** = malloc(sizeof(combined[0]) * n)
    combinedlen = 0
    for start = 0; start < n; start = end:
        end = start + 1
        while end < n and type.classdata.fields.ptr[start].union_id == type.classdata.fields.ptr[end].union_id:
            end++
        combined[combinedlen++] = union_type_to_llvm(state, &flat_elems[start], end-start)

    result = LLVMStructTypeInContext(state.llvm_context, combined, combinedlen, False as int)
    free(flat_elems)
    free(combined)
    return result


def type_to_llvm(state: ThreadLocalCompilerState*, type: Type*) -> LLVMType*:
    if type == NULL:
        # This is only for noreturn and None return types of functions.
        # TODO: tell llvm, if we know a function is noreturn ?
        return LLVMVoidTypeInContext(state.llvm_context)

    match type.kind:
        case TypeKind.Array:
            return LLVMArrayType(type_to_llvm(state, type.array.item_type), type.array.count)
        case TypeKind.Pointer | TypeKind.VoidPointer | TypeKind.FuncPtr:
            return LLVMPointerTypeInContext(state.llvm_context, 0)
        case TypeKind.FloatingPoint:
            if type.size_in_bits == 32:
                return LLVMFloatTypeInContext(state.llvm_context)
            if type.size_in_bits == 64:
                return LLVMDoubleTypeInContext(state.llvm_context)
            assert False
        case TypeKind.SignedInteger | TypeKind.UnsignedInteger:
            return LLVMIntTypeInContext(state.llvm_context, type.size_in_bits)
        case TypeKind.Bool:
            return LLVMInt1TypeInContext(state.llvm_context)
        case TypeKind.TypeVar:
            # This is compiler internal/temporary thing and should never end up here.
            assert False  # please create an issue on GitHub if this errors
        case TypeKind.Class:
            return class_type_to_llvm(state, type)
        case TypeKind.Enum:
            return type_to_llvm(state, int_type(32))


# This is not handled by type_to_llvm() because funcptr maps to a pointer in LLVM.
# This function returns an LLVM type representing the underlying function.
def funcptr_type_to_llvm(state: ThreadLocalCompilerState*, t: Type*) -> LLVMType*:
    assert t.kind == TypeKind.FuncPtr

    assert t.func_ptr.argtypes.len <= MAX_ARGS
    argtypes: LLVMType*[MAX_ARGS]
    for i = 0; i < t.func_ptr.argtypes.len; i++:
        argtypes[i] = type_to_llvm(state, t.func_ptr.argtypes.ptr[i])

    return LLVMFunctionType(
        type_to_llvm(state, t.func_ptr.return_type),
        argtypes,
        t.func_ptr.argtypes.len as int,
        t.func_ptr.takes_varargs as int,
    )


def signature_to_llvm(state: ThreadLocalCompilerState*, sig: Signature*) -> LLVMType*:
    # We cannot simply convert the signature into a funcptr type because of
    # thread safety. The new funcptr type might not exist yet, and creating it
    # would cause race conditions.
    assert sig.args.len <= MAX_ARGS
    argtypes: LLVMType*[MAX_ARGS]
    for i = 0; i < sig.args.len; i++:
        argtypes[i] = type_to_llvm(state, sig.args.ptr[i].type)

    return LLVMFunctionType(
        type_to_llvm(state, sig.return_type),
        argtypes,
        sig.args.len as int,
        sig.takes_varargs as int,
    )


def declare_in_llvm(state: ThreadLocalCompilerState*, sig: Signature*, mod: LLVMModule*) -> LLVMValue*:
    fullname: byte[500]
    self_class = sig.get_self_class()
    if self_class == NULL:
        # function
        snprintf(fullname, sizeof(fullname), "%s", sig.name)
    else:
        # method bark() in class Dog becomes Dog.bark()
        # method append() in generic class List[int] becomes List.append(), not List[int].append()
        n = strcspn(self_class.name, "[")
        snprintf(fullname, sizeof(fullname), "%.*s.%s", n as int, self_class.name, sig.name)

    # Make it so that this can be called many times without issue
    llvm_func = LLVMGetNamedFunction(mod, fullname)
    if llvm_func == NULL:
        llvm_func = LLVMAddFunction(mod, fullname, signature_to_llvm(state, sig))

    assert llvm_func != NULL
    return llvm_func


def build_llvm_signed_mod(builder: LLVMBuilder*, lhs: LLVMValue*, rhs: LLVMValue*) -> LLVMValue*:
    # Jou's % operator ensures that a%b has same sign as b:
    # jou_mod(a, b) = llvm_mod(llvm_mod(a, b) + b, b)
    llmod = LLVMBuildSRem(builder, lhs, rhs, "smod_tmp")
    sum = LLVMBuildAdd(builder, llmod, rhs, "smod_tmp")
    return LLVMBuildSRem(builder, sum, rhs, "smod")


def build_llvm_signed_div(builder: LLVMBuilder*, lhs: LLVMValue*, rhs: LLVMValue*) -> LLVMValue*:
    # LLVM's provides two divisions. One truncates, the other is an "exact div"
    # that requires there is no remainder. Jou uses floor division which is
    # neither of the two, but is quite easy to implement:
    #
    #    floordiv(a, b) = exact_div(a - jou_mod(a, b), b)
    #
    top = LLVMBuildSub(builder, lhs, build_llvm_signed_mod(builder, lhs, rhs), "sdiv_tmp")
    return LLVMBuildExactSDiv(builder, top, rhs, "sdiv")


# Clamps out-of-range values to min or max. Returns 0 for NaN.
#
# Doing this in LLVM without invoking UB is surprisingly difficult. The
# following pseudo-code roughly describes what this does:
#
#    if float_value is NaN:
#        result = 0
#    elif float_value > max:
#        result = max
#    elif float_value < min:
#        result = min
#    else:
#        result = normal LLVM conversion
#
def cast_floating_point_to_integer(state: ThreadLocalCompilerState*, builder: LLVMBuilder*, obj: LLVMValue*, from: Type*, to: Type*) -> LLVMValue*:
    assert from.kind == TypeKind.FloatingPoint
    assert to.is_integer_type()

    is_signed = (to.kind == TypeKind.SignedInteger)

    if is_signed:
        int_min = LLVMConstInt(type_to_llvm(state, to), to.min_value(), 1)
        int_max = LLVMConstInt(type_to_llvm(state, to), to.max_value() as int64, 1)
        floating_min = LLVMBuildSIToFP(builder, int_min, type_to_llvm(state, from), "floating_min")
        floating_max = LLVMBuildSIToFP(builder, int_max, type_to_llvm(state, from), "floating_max")
    else:
        int_min = LLVMConstInt(type_to_llvm(state, to), to.min_value(), 0)
        int_max = LLVMConstInt(type_to_llvm(state, to), to.max_value() as int64, 0)
        floating_min = LLVMBuildUIToFP(builder, int_min, type_to_llvm(state, from), "floating_min")
        floating_max = LLVMBuildUIToFP(builder, int_max, type_to_llvm(state, from), "floating_max")

    return LLVMBuildSelect(
        builder,
        # If NaN:
        LLVMBuildFCmp(builder, LLVMRealPredicate.UNO, obj, obj, "is_nan"),
        # then return 0
        LLVMConstInt(type_to_llvm(state, to), 0, 0),
        # If not NaN:
        LLVMBuildSelect(
            builder,
            # If value > max:
            LLVMBuildFCmp(builder, LLVMRealPredicate.OGT, obj, floating_max, "greater_than_max"),
            # then return max
            int_max,
            # If value <= max:
            LLVMBuildSelect(
                builder,
                # If value < min:
                LLVMBuildFCmp(builder, LLVMRealPredicate.OLT, obj, floating_min, "less_than_min"),
                # then return min
                int_min,
                # If value is between min and max, use LLVM's normal conversion.
                #
                # If value is not between min and max, LLVM returns a poison
                # value. It is fine to construct a poison value if it is not
                # used. Using a poison value invokes UB.
                (
                    LLVMBuildFPToSI(builder, obj, type_to_llvm(state, to), "normal_cast_signed")
                    if is_signed else
                    LLVMBuildFPToUI(builder, obj, type_to_llvm(state, to), "normal_cast_unsigned")
                ),
                "min_check",
            ),
            "max_check",
        ),
        "nan_check",
    )


# Builds the result of "a << b" or "a >> b". Avoids LLVM's undefined behaviors.
def bitshift(
    state: ThreadLocalCompilerState*,
    builder: LLVMBuilder*,
    a: LLVMValue*,
    b: LLVMValue*,
    shift_type: Type*,
    left: bool,
) -> LLVMValue*:
    assert LLVMTypeOf(a) == type_to_llvm(state, shift_type)

    # Shift amount must be converted to a's type because LLVM wants it that
    # way. This is fine: when the result is used, the shift amount is 0 to 63
    # so it surely fits.
    llvm_shift_amount = LLVMBuildIntCast2(builder, b, LLVMTypeOf(a), False as int, "shift_amount")

    # Compute a normal LLVM bitshift. It is a poison value for shifting beyond
    # the width. This is fine because creating a poison value is not UB if you
    # don't use the poison value.
    if left:
        bitshift_or_poison = LLVMBuildShl(builder, a, llvm_shift_amount, "bitshift_or_poison")
    else:
        bitshift_or_poison = LLVMBuildLShr(builder, a, llvm_shift_amount, "bitshift_or_poison")

    return LLVMBuildSelect(
        builder,
        # If we shift beyond the width of the type
        LLVMBuildICmp(
            builder,
            # Check if shift amount >= width
            LLVMIntPredicate.UGE,
            b,
            # Width of the data type (max 64, so surely fits into b's type)
            LLVMConstInt(LLVMTypeOf(b), shift_type.size_in_bits, False as int),
            "shifts_beyond_width",
        ),
        # Then return zero
        LLVMConstInt(LLVMTypeOf(a), 0, False as int),
        # Otherwise, return the result of a normal LLVM bitshift, which is not
        # a poison value when it is chosen.
        bitshift_or_poison,
        "bitshift",
    )


def build_llvm_cast(
    state: ThreadLocalCompilerState*,
    builder: LLVMBuilder*,
    obj: LLVMValue*,
    from: Type*,
    to: Type*,
) -> LLVMValue*:
    assert from != NULL
    assert to != NULL

    # Always treat enums as ints
    if from.kind == TypeKind.Enum:
        from = int_type(32)
    if to.kind == TypeKind.Enum:
        to = int_type(32)

    if from == to:
        return obj

    if from.is_pointer_type() and to.is_pointer_type():
        # All pointers are the same type in LLVM
        return obj

    if from.is_number_type() and to.is_number_type():
        if from.is_integer_type() and to.is_integer_type():
            # Examples:
            #  signed 8-bit 0xFF (-1) --> 16-bit 0xFFFF (-1 or max value)
            #  unsigned 8-bit 0xFF (255) --> 16-bit 0x00FF (255)
            return LLVMBuildIntCast2(builder, obj, type_to_llvm(state, to), (from.kind == TypeKind.SignedInteger) as int, "cast")
        if from.is_integer_type() and to.kind == TypeKind.FloatingPoint:
            # integer --> double/float
            if from.kind == TypeKind.SignedInteger:
                return LLVMBuildSIToFP(builder, obj, type_to_llvm(state, to), "cast")
            else:
                return LLVMBuildUIToFP(builder, obj, type_to_llvm(state, to), "cast")
        if from.kind == TypeKind.FloatingPoint and to.is_integer_type():
            # double/float --> integer
            return cast_floating_point_to_integer(state, builder, obj, from, to)
        if from.kind == TypeKind.FloatingPoint and to.kind == TypeKind.FloatingPoint:
            # double/float --> double/float
            return LLVMBuildFPCast(builder, obj, type_to_llvm(state, to), "cast")
        assert False

    if from.is_integer_type() and to.is_pointer_type():
        return LLVMBuildIntToPtr(builder, obj, type_to_llvm(state, to), "cast")
    if from.is_pointer_type() and to.is_integer_type():
        return LLVMBuildPtrToInt(builder, obj, type_to_llvm(state, to), "cast")

    if from == bool_type() and to.is_integer_type():
        return LLVMBuildIntCast2(builder, obj, type_to_llvm(state, to), False as int, "cast")

    printf("cast failed: %s -> %s\n", from.name, to.name)
    assert False


@public
class LBuilderValue:
    type: Type*
    llvm_value: LLVMValue*


# Not named LLVMBuilder because that is the name of LLVM's thing.
@public
class LBuilder:
    state: ThreadLocalCompilerState*
    llvm_module: LLVMModule*
    llvm_builder: LLVMBuilder*
    llvm_func: LLVMValue*
    alloca_block: LLVMBasicBlock*  # local variables created here before code of function runs
    code_start_block: LLVMBasicBlock*
    current_block: LLVMBasicBlock*
    returns_a_value: bool

    @public
    def begin_function(self, sig: Signature*, public: bool) -> None:
        self.llvm_func = declare_in_llvm(self.state, sig, self.llvm_module)
        self.returns_a_value = sig.return_type != NULL

        self.alloca_block = LLVMAppendBasicBlockInContext(self.state.llvm_context, self.llvm_func, "alloca")
        self.code_start_block = LLVMAppendBasicBlockInContext(self.state.llvm_context, self.llvm_func, "code_start")
        LLVMPositionBuilderAtEnd(self.llvm_builder, self.code_start_block)
        self.current_block = self.code_start_block

        if not public:
            LLVMSetLinkage(self.llvm_func, LLVMLinkage.Private)

    @public
    def end_function(self) -> None:
        if self.returns_a_value:
            # Implicit "return" at the end of a function that should return a value
            LLVMBuildUnreachable(self.llvm_builder)
        else:
            LLVMBuildRetVoid(self.llvm_builder)

        LLVMPositionBuilderAtEnd(self.llvm_builder, self.alloca_block)
        LLVMBuildBr(self.llvm_builder, self.code_start_block)

    @public
    def begin_statement_in_a_body(self) -> None:
        pass

    # TODO: use the location for debug info
    @public
    def set_location(self, location: Location) -> None:
        pass

    @public
    def stack_alloc(self, t: Type*, varname: byte*) -> LBuilderValue:
        if varname == NULL:
            debug_name = "stack_alloc"
        else:
            debug_name = varname

        # Place all allocations to the same block at start of function, so that
        # we don't overflow the stack when the part of code that creates local
        # var runs many times.
        LLVMPositionBuilderAtEnd(self.llvm_builder, self.alloca_block)
        llvm_ptr = LLVMBuildAlloca(self.llvm_builder, type_to_llvm(self.state, t), debug_name)
        LLVMPositionBuilderAtEnd(self.llvm_builder, self.current_block)
        return LBuilderValue{type = t.pointer_type(), llvm_value = llvm_ptr}

    # *ptr = value
    @public
    def set_ptr(self, ptr: LBuilderValue, value: LBuilderValue) -> None:
        # TODO: fix how typedef statement works and re-enable this!
        #if ptr.type != value.type.pointer_type():
        #    printf("Cannot set value of %s to %s\n", ptr.type.name, value.type.name)
        #assert ptr.type == value.type.pointer_type()
        ptr_type = LLVMPointerTypeInContext(self.state.llvm_context, 0)
        LLVMBuildStore(self.llvm_builder, value.llvm_value, ptr.llvm_value)

    # *ptr
    @public
    def dereference(self, ptr: LBuilderValue) -> LBuilderValue:
        assert ptr.type.kind == TypeKind.Pointer
        llvm_result = LLVMBuildLoad2(self.llvm_builder, type_to_llvm(self.state, ptr.type.value_type), ptr.llvm_value, "dereference")
        return LBuilderValue{type = ptr.type.value_type, llvm_value = llvm_result}

    # Returns &ptr[index]
    @public
    def indexed_pointer(self, ptr: LBuilderValue, index: LBuilderValue) -> LBuilderValue:
        assert ptr.type.kind == TypeKind.Pointer
        assert index.type == int_type(64)  # doesn't work right if it's other type
        llvm_result = LLVMBuildGEP2(
            self.llvm_builder,
            type_to_llvm(self.state, ptr.type.value_type),
            ptr.llvm_value,
            &index.llvm_value,
            1,
            "indexed_pointer",
        )
        return LBuilderValue{type = ptr.type, llvm_value = llvm_result}

    # Returns &ptr.field
    @public
    def class_field_pointer(self, ptr: LBuilderValue, field_name: byte*) -> LBuilderValue:
        assert ptr.type.kind == TypeKind.Pointer
        classtype = ptr.type.value_type
        assert classtype.kind == TypeKind.Class

        field = classtype.find_class_field(field_name)
        assert field != NULL

        llvm_struct_type = type_to_llvm(self.state, classtype)
        llvm_result = LLVMBuildStructGEP2(self.llvm_builder, llvm_struct_type, ptr.llvm_value, field.union_id, field.name)
        return LBuilderValue{type = field.type.pointer_type(), llvm_value = llvm_result}

    # &global_variable
    @public
    def global_var_ptr(self, name: byte*, var_type: Type*) -> LBuilderValue:
        llvm_result = LLVMGetNamedGlobal(self.llvm_module, name)
        assert llvm_result != NULL
        return LBuilderValue{type = var_type.pointer_type(), llvm_value = llvm_result}

    # some_function
    @public
    def get_funcptr(self, sig: Signature*) -> LBuilderValue:
        llvm_result = declare_in_llvm(self.state, sig, self.llvm_module)
        assert llvm_result != NULL
        return LBuilderValue{type = sig.to_funcptr_type(), llvm_value = llvm_result}

    # i'th argument given to this function
    @public
    def get_argument(self, i: int, argtype: Type*) -> LBuilderValue:
        llvm_result = LLVMGetParam(self.llvm_func, i)
        return LBuilderValue{type = argtype, llvm_value = llvm_result}

    @public
    def call_function(self, funcptr_type: Type*, func: LBuilderValue, args: LBuilderValue*, nargs: int) -> LBuilderValue:
        assert nargs <= MAX_ARGS
        llvm_args: LLVMValue*[MAX_ARGS]
        for i = 0; i < nargs; i++:
            llvm_args[i] = args[i].llvm_value

        assert funcptr_type.kind == TypeKind.FuncPtr
        debug_name = ""
        if funcptr_type.func_ptr.return_type != NULL:
            debug_name = "func_return_value"

        llvm_return_value = LLVMBuildCall2(
            self.llvm_builder,
            funcptr_type_to_llvm(self.state, funcptr_type),
            func.llvm_value,
            llvm_args,
            nargs,
            debug_name,
        )

        if funcptr_type.func_ptr.return_type == NULL:
            return LBuilderValue{}
        else:
            assert llvm_return_value != NULL
            return LBuilderValue{type = funcptr_type.func_ptr.return_type, llvm_value = llvm_return_value}

    # self must be included in args
    @public
    def call_method(self, sig: Signature*, args: LBuilderValue*, nargs: int) -> LBuilderValue:
        assert nargs >= sig.args.len
        if nargs > sig.args.len:
            assert sig.takes_varargs

        assert nargs <= MAX_ARGS
        llvm_args: LLVMValue*[MAX_ARGS]
        for i = 0; i < nargs; i++:
            llvm_args[i] = args[i].llvm_value

        debug_name: byte[100] = ""
        if sig.return_type != NULL:
            snprintf(debug_name, sizeof(debug_name), "%s_return_value", sig.name)

        llvm_func = declare_in_llvm(self.state, sig, self.llvm_module)
        llvm_return_value = LLVMBuildCall2(
            self.llvm_builder,
            signature_to_llvm(self.state, sig),
            llvm_func,
            llvm_args,
            nargs,
            debug_name,
        )

        if sig.return_type == NULL:
            return LBuilderValue{}
        else:
            assert llvm_return_value != NULL
            return LBuilderValue{type = sig.return_type, llvm_value = llvm_return_value}

    @public
    def array_of_bytes(self, bytes: List[byte]) -> LBuilderValue:
        assert bytes.len <= UINT32_MAX
        llvm_array = LLVMConstStringInContext(self.state.llvm_context, bytes.ptr, bytes.len as uint32, True as int)
        assert bytes.len <= INT32_MAX
        return LBuilderValue{type = uint_type(8).array_type(bytes.len as int), llvm_value = llvm_array}

    # string as '\0' terminated pointer
    @public
    def pointer_string(self, s: byte*) -> LBuilderValue:
        llvm_array = LLVMConstStringInContext(self.state.llvm_context, s, strlen(s) as uint32, False as int)
        llvm_string = LLVMAddGlobal(self.llvm_module, LLVMTypeOf(llvm_array), "string_literal")
        LLVMSetLinkage(llvm_string, LLVMLinkage.Private)  # This makes it a static global variable
        LLVMSetInitializer(llvm_string, llvm_array)
        return LBuilderValue{type = uint_type(8).pointer_type(), llvm_value = llvm_string}

    @public
    def boolean(self, b: bool) -> LBuilderValue:
        return LBuilderValue{
            type = bool_type(),
            llvm_value = LLVMConstInt(LLVMInt1TypeInContext(self.state.llvm_context), b as int64, False as int),
        }

    @public
    def integer(self, t: Type*, value: int64) -> LBuilderValue:
        assert t.is_integer_type()
        return LBuilderValue{
            type = t,
            llvm_value = LLVMConstInt(type_to_llvm(self.state, t), value, (t.kind == TypeKind.SignedInteger) as int),
        }

    @public
    def float_or_double(self, t: Type*, string: byte*) -> LBuilderValue:
        assert t.kind == TypeKind.FloatingPoint
        return LBuilderValue{
            type = t,
            llvm_value = LLVMConstRealOfString(type_to_llvm(self.state, t), string)
        }

    @public
    def zero_of_type(self, t: Type*) -> LBuilderValue:
        return LBuilderValue{
            type = t,
            llvm_value = LLVMConstNull(type_to_llvm(self.state, t)),
        }

    @public
    def enum_member(self, t: Type*, name: byte*) -> LBuilderValue:
        int_value = t.find_enum_member(name)
        assert int_value != -1
        return LBuilderValue{
            type = t,
            llvm_value = LLVMConstInt(LLVMInt32TypeInContext(self.state.llvm_context), int_value, False as int),
        }

    # a + b
    @public
    def add(self, a: LBuilderValue, b: LBuilderValue) -> LBuilderValue:
        assert a.type == b.type
        match a.type.kind:
            case TypeKind.FloatingPoint:
                llvm_sum = LLVMBuildFAdd(self.llvm_builder, a.llvm_value, b.llvm_value, "float_sum")
            case TypeKind.SignedInteger | TypeKind.UnsignedInteger:
                llvm_sum = LLVMBuildAdd(self.llvm_builder, a.llvm_value, b.llvm_value, "int_sum")
            case _:
                assert False
        return LBuilderValue{type = a.type, llvm_value = llvm_sum}

    # a - b
    @public
    def sub(self, a: LBuilderValue, b: LBuilderValue) -> LBuilderValue:
        assert a.type == b.type
        match a.type.kind:
            case TypeKind.FloatingPoint:
                llvm_diff = LLVMBuildFSub(self.llvm_builder, a.llvm_value, b.llvm_value, "float_diff")
            case TypeKind.SignedInteger | TypeKind.UnsignedInteger:
                llvm_diff = LLVMBuildSub(self.llvm_builder, a.llvm_value, b.llvm_value, "int_diff")
            case _:
                assert False
        return LBuilderValue{type = a.type, llvm_value = llvm_diff}

    # a * b
    @public
    def mul(self, a: LBuilderValue, b: LBuilderValue) -> LBuilderValue:
        assert a.type == b.type
        match a.type.kind:
            case TypeKind.FloatingPoint:
                llvm_prod = LLVMBuildFMul(self.llvm_builder, a.llvm_value, b.llvm_value, "float_prod")
            case TypeKind.SignedInteger | TypeKind.UnsignedInteger:
                llvm_prod = LLVMBuildMul(self.llvm_builder, a.llvm_value, b.llvm_value, "int_prod")
            case _:
                assert False
        return LBuilderValue{type = a.type, llvm_value = llvm_prod}

    # a / b
    @public
    def div(self, a: LBuilderValue, b: LBuilderValue) -> LBuilderValue:
        assert a.type == b.type
        match a.type.kind:
            case TypeKind.FloatingPoint:
                llvm_quot = LLVMBuildFDiv(self.llvm_builder, a.llvm_value, b.llvm_value, "float_quot")
            case TypeKind.SignedInteger:
                llvm_quot = build_llvm_signed_div(self.llvm_builder, a.llvm_value, b.llvm_value)
            case TypeKind.UnsignedInteger:
                llvm_quot = LLVMBuildUDiv(self.llvm_builder, a.llvm_value, b.llvm_value, "uint_quot")
            case _:
                assert False
        return LBuilderValue{type = a.type, llvm_value = llvm_quot}

    # a % b
    @public
    def mod(self, a: LBuilderValue, b: LBuilderValue) -> LBuilderValue:
        assert a.type == b.type
        match a.type.kind:
            case TypeKind.FloatingPoint:
                llvm_mod = LLVMBuildFRem(self.llvm_builder, a.llvm_value, b.llvm_value, "float_mod")
            case TypeKind.SignedInteger:
                llvm_mod = build_llvm_signed_mod(self.llvm_builder, a.llvm_value, b.llvm_value)
            case TypeKind.UnsignedInteger:
                llvm_mod = LLVMBuildURem(self.llvm_builder, a.llvm_value, b.llvm_value, "uint_mod")
            case _:
                assert False
        return LBuilderValue{type = a.type, llvm_value = llvm_mod}

    # a & b
    @public
    def bit_and(self, a: LBuilderValue, b: LBuilderValue) -> LBuilderValue:
        assert a.type == b.type
        llvm_and = LLVMBuildAnd(self.llvm_builder, a.llvm_value, b.llvm_value, "bit_and")
        return LBuilderValue{type = a.type, llvm_value = llvm_and}

    # a | b
    @public
    def bit_or(self, a: LBuilderValue, b: LBuilderValue) -> LBuilderValue:
        assert a.type == b.type
        llvm_or = LLVMBuildOr(self.llvm_builder, a.llvm_value, b.llvm_value, "bit_or")
        return LBuilderValue{type = a.type, llvm_value = llvm_or}

    # a ^ b
    @public
    def bit_xor(self, a: LBuilderValue, b: LBuilderValue) -> LBuilderValue:
        assert a.type == b.type
        llvm_xor = LLVMBuildXor(self.llvm_builder, a.llvm_value, b.llvm_value, "bit_xor")
        return LBuilderValue{type = a.type, llvm_value = llvm_xor}

    # a << b
    @public
    def bit_shift_left(self, a: LBuilderValue, b: LBuilderValue) -> LBuilderValue:
        return LBuilderValue{
            type = a.type,
            llvm_value = bitshift(self.state, self.llvm_builder, a.llvm_value, b.llvm_value, a.type, True),
        }

    # a >> b
    @public
    def bit_shift_right(self, a: LBuilderValue, b: LBuilderValue) -> LBuilderValue:
        return LBuilderValue{
            type = a.type,
            llvm_value = bitshift(self.state, self.llvm_builder, a.llvm_value, b.llvm_value, a.type, False),
        }

    # a == b
    @public
    def eq(self, a: LBuilderValue, b: LBuilderValue) -> LBuilderValue:
        assert a.type == b.type
        match a.type.kind:
            case TypeKind.SignedInteger | TypeKind.UnsignedInteger | TypeKind.Enum | TypeKind.Bool:
                llvm_result = LLVMBuildICmp(self.llvm_builder, LLVMIntPredicate.EQ, a.llvm_value, b.llvm_value, "eq")
            case TypeKind.FloatingPoint:
                llvm_result = LLVMBuildFCmp(self.llvm_builder, LLVMRealPredicate.OEQ, a.llvm_value, b.llvm_value, "eq")
            case _:
                assert False
        return LBuilderValue{type = bool_type(), llvm_value = llvm_result}

    # a < b
    @public
    def lt(self, a: LBuilderValue, b: LBuilderValue) -> LBuilderValue:
        assert a.type == b.type
        match a.type.kind:
            case TypeKind.SignedInteger:
                llvm_result = LLVMBuildICmp(self.llvm_builder, LLVMIntPredicate.SLT, a.llvm_value, b.llvm_value, "lt")
            case TypeKind.UnsignedInteger:
                llvm_result = LLVMBuildICmp(self.llvm_builder, LLVMIntPredicate.ULT, a.llvm_value, b.llvm_value, "lt")
            case TypeKind.FloatingPoint:
                llvm_result = LLVMBuildFCmp(self.llvm_builder, LLVMRealPredicate.OLT, a.llvm_value, b.llvm_value, "lt")
            case _:
                assert False
        return LBuilderValue{type = bool_type(), llvm_value = llvm_result}

    # not value
    @public
    def not_(self, value: LBuilderValue) -> LBuilderValue:
        llvm_true = LLVMConstInt(LLVMInt1TypeInContext(self.state.llvm_context), 1, False as int)
        llvm_result = LLVMBuildXor(self.llvm_builder, value.llvm_value, llvm_true, "not")
        return LBuilderValue{type = bool_type(), llvm_value = llvm_result}

    # ~value
    @public
    def bit_not(self, value: LBuilderValue) -> LBuilderValue:
        all_bits = uint_type(value.type.size_in_bits).max_value()
        llvm_result = LLVMBuildXor(self.llvm_builder, value.llvm_value, LLVMConstInt(type_to_llvm(self.state, value.type), all_bits as int64, False as int), "bit_not")
        return LBuilderValue{type = value.type, llvm_value = llvm_result}

    # sizeof(any value of given type)
    @public
    def size_of(self, t: Type*) -> LBuilderValue:
        # LLVMSizeOf() returns a 64-bit value. Jou's sizeof(x) is 32-bit.
        size64 = LLVMSizeOf(type_to_llvm(self.state, t))
        size32 = LLVMBuildTrunc(self.llvm_builder, size64, LLVMInt32TypeInContext(self.state.llvm_context), "sizeof")
        return LBuilderValue{type = int_type(32), llvm_value = size32}

    # memset(ptr, 0, sizeof(*ptr))
    @public
    def memset_to_zero(self, ptr: LBuilderValue) -> None:
        assert ptr.type.kind == TypeKind.Pointer
        size = self.size_of(ptr.type.value_type).llvm_value
        zero_byte = LLVMConstInt(LLVMInt8TypeInContext(self.state.llvm_context), 0, False as int)
        LLVMBuildMemSet(self.llvm_builder, ptr.llvm_value, zero_byte, size, 0)

    # value as to
    @public
    def cast(self, value: LBuilderValue, to: Type*) -> LBuilderValue:
        llvm_result = build_llvm_cast(self.state, self.llvm_builder, value.llvm_value, value.type, to)
        return LBuilderValue{type = to, llvm_value = llvm_result}

    # Blocks are used to implement e.g. if statements and loops.
    @public
    def add_block(self) -> LLVMBasicBlock*:
        return LLVMAppendBasicBlockInContext(self.state.llvm_context, self.llvm_func, "block")

    # Decide which block will contain the resulting instructions.
    @public
    def set_current_block(self, block: LLVMBasicBlock*) -> None:
        LLVMPositionBuilderAtEnd(self.llvm_builder, block)
        self.current_block = block

    @public
    def branch(self, cond: LBuilderValue, then: LLVMBasicBlock*, otherwise: LLVMBasicBlock*) -> None:
        LLVMBuildCondBr(self.llvm_builder, cond.llvm_value, then, otherwise)

    @public
    def jump(self, next_block: LLVMBasicBlock*) -> None:
        LLVMBuildBr(self.llvm_builder, next_block)

    @public
    def unreachable(self) -> None:
        LLVMBuildUnreachable(self.llvm_builder)

    @public
    def ret(self, value: LBuilderValue*) -> None:
        if value == NULL:
            LLVMBuildRetVoid(self.llvm_builder)
        else:
            LLVMBuildRet(self.llvm_builder, value.llvm_value)


@public
def build_llvm_ir(state: ThreadLocalCompilerState*, jou_file: JouFile*) -> LLVMModule*:
    module = LLVMModuleCreateWithNameInContext(jou_file.path, state.llvm_context)

    assert global_compiler_state.target.ready
    LLVMSetTarget(module, global_compiler_state.target.triple)
    LLVMSetDataLayout(module, global_compiler_state.target.data_layout)

    builder = LBuilder{
        state = state,
        llvm_module = module,
        llvm_builder = LLVMCreateBuilderInContext(state.llvm_context),
    }
    builder_wrapper = AnyBuilder{lbuilder = &builder}

    for avail = jou_file.available_symbols.ptr; avail < jou_file.available_symbols.end(); avail++:
        if avail.the_import != NULL:
            symbol = avail.statement.symbol()
            if symbol.kind == GlobalSymbolKind.GlobalVar:
                assert symbol.type != NULL
                LLVMAddGlobal(module, type_to_llvm(state, symbol.type), symbol.name)

    # Add global variables first, so we can refer to them later.
    for stmt = jou_file.ast.ptr; stmt < jou_file.ast.end(); stmt++:
        match stmt.kind:
            case AstStatementKind.GlobalVariableDef:
                assert stmt.symbol().type != NULL
                gtype = type_to_llvm(state, stmt.symbol().type)
                globalptr = LLVMAddGlobal(module, gtype, stmt.symbol().name)
                assert globalptr != NULL
                if stmt.global_var_def.initial_value == NULL:
                    LLVMSetInitializer(globalptr, LLVMConstNull(gtype))
                else:
                    value = feed_constant_to_builder(&stmt.global_var_def.initial_value_constant, &builder_wrapper)
                    LLVMSetInitializer(globalptr, value.lvalue.llvm_value)
                if not stmt.symbol().public:
                    LLVMSetLinkage(globalptr, LLVMLinkage.Private)  # This makes it a static global variable
            case AstStatementKind.GlobalVariableDeclare:
                assert stmt.symbol().type != NULL
                LLVMAddGlobal(module, type_to_llvm(state, stmt.symbol().type), stmt.symbol().name)
            case _:
                pass

    for stmt = jou_file.ast.ptr; stmt < jou_file.ast.end(); stmt++:
        match stmt.kind:
            case AstStatementKind.FunctionDef:
                feed_ast_to_builder(&stmt.function, stmt.location, jou_file.is_main_file, &builder_wrapper)
            case AstStatementKind.Class:
                for inner = stmt.classdef.body.ptr; inner < stmt.classdef.body.end(); inner++:
                    if inner.kind == AstStatementKind.MethodDef:
                        feed_ast_to_builder(&inner.method, inner.location, jou_file.is_main_file, &builder_wrapper)
            case _:
                pass

    LLVMDisposeBuilder(builder.llvm_builder)
    return module
