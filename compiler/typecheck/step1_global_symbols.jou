# First step of type checking is to check all global symbols; that is, global
# variables, `const`, classes etc.
#
# Class and function bodies are not checked yet. For classes, we create the
# types but we don't fill them with members and methods. This is how classes
# that refer to themselves are handled. This may need to change later to
# support e.g. sizeof(some_class) in a const.

import "stdlib/assert.jou"
import "stdlib/io.jou"
import "stdlib/str.jou"
import "stdlib/list.jou"

import "../state.jou"
import "../global_symbols.jou"
import "../types.jou"
import "../errors_and_warnings.jou"
import "../ast.jou"
import "../constants.jou"
import "../evaluate.jou"
import "./common.jou"


def check_const(jou_file: JouFile*, const_stmt: AstConstStatement*, location: Location) -> None:
    expected_type = type_from_ast(jou_file, NULL, &const_stmt.type)

    value: Constant
    if not evaluate_constant_expression(jou_file, &const_stmt.value, &value, expected_type):
        fail(location, "cannot evaluate value of constant at compile time")

    # TODO: allow implicit casts?
    if value.get_type() != expected_type:
        msg: byte[500]
        snprintf(
            msg, sizeof(msg),
            "constant of type %s cannot have a value of type %s",
            expected_type.name,
            value.get_type().name
        )
        fail(location, msg)

    const_stmt.symbol.constant = value


def check_global_var_def(jou_file: JouFile*, global_stmt: AstGlobalVarDef*, location: Location) -> None:
    if global_stmt.type != NULL:
        expected_type = type_from_ast(jou_file, NULL, global_stmt.type)
        assert expected_type != NULL
        global_stmt.symbol.type = expected_type
    else:
        expected_type = NULL

    if global_stmt.initial_value != NULL:
        value: Constant
        if not evaluate_constant_expression(jou_file, global_stmt.initial_value, &value, expected_type):
            fail(location, "cannot evaluate initial value of global variable at compile time")
        global_stmt.initial_value_constant = value

        if expected_type == NULL:
            global_stmt.symbol.type = value.get_type()
        else:
            # TODO: allow implicit casts?
            if value.get_type() != expected_type:
                msg: byte[500]
                snprintf(
                    msg, sizeof(msg),
                    "global variable of type %s cannot have an initial value of type %s",
                    expected_type.name,
                    value.get_type().name
                )
                fail(location, msg)

    assert global_stmt.symbol.type != NULL


# To support various cyclic things, this may also type-check other things than
# the one statement we tell it to check.
def typecheck_statement_with_symbol(stmt: AstStatement*) -> None:
    msg: byte[500]

    # Find the Jou file where the statement is defined
    finding = stmt.method.containing_class_def if stmt.kind == AstStatementKind.MethodDef else stmt
    jou_file: JouFile* = NULL
    for j = global_compiler_state.jou_files.ptr; j < global_compiler_state.jou_files.end(); j++:
        if j.ast.ptr <= finding and finding < j.ast.end():
            assert jou_file == NULL
            jou_file = j
    assert jou_file != NULL

    assert stmt.symbol() != NULL
    match stmt.symbol().status:
        case GlobalSymbolStatus.NotTypeChecked:
            pass
        case GlobalSymbolStatus.TypeChecking:
            snprintf(msg, sizeof(msg), "%s '%s' depends on itself", stmt.symbol().short_description(), stmt.symbol().name)
            fail(stmt.location, msg)
        case GlobalSymbolStatus.Ready:
            return

    stmt.symbol().status = GlobalSymbolStatus.TypeChecking
    if global_compiler_state.args.verbosity >= 2:
        printf("    %s (%s in %s)\n", stmt.symbol().name, stmt.symbol().short_description(), jou_file.path)

    match stmt.kind:
        case AstStatementKind.Const:
            check_const(jou_file, &stmt.const_statement, stmt.location)
        case AstStatementKind.GlobalVariableDeclare:
            stmt.symbol().type = type_from_ast(jou_file, NULL, &stmt.global_var_declare.type)
        case AstStatementKind.GlobalVariableDef:
            check_global_var_def(jou_file, &stmt.global_var_def, stmt.location)
        case AstStatementKind.Enum:
            stmt.symbol().type = create_enum(stmt.symbol().name, stmt.enumdef.members)
        case AstStatementKind.TypeDef:
            actual_type = type_from_ast(jou_file, NULL, &stmt.typedef_statement.ast_type)
            stmt.symbol().type = actual_type
        case AstStatementKind.FunctionDeclare | AstStatementKind.FunctionDef:
            stmt.symbol().signature = typecheck_signature(jou_file, &stmt.function, NULL)
        case AstStatementKind.MethodDef:
            classdef = stmt.method.containing_class_def
            assert classdef != NULL
            assert classdef.kind == AstStatementKind.Class
            typecheck_statement_with_symbol(classdef)
            self_class = classdef.symbol().type  # works for generic and non-generic classes
            assert self_class != NULL
            stmt.symbol().signature = typecheck_signature(jou_file, &stmt.method, self_class)
        case AstStatementKind.Class:
            t = create_empty_class(stmt.symbol().name)
            if stmt.classdef.is_generic():
                for nameptr = stmt.classdef.generic_typevar_names.ptr; nameptr < stmt.classdef.generic_typevar_names.end(); nameptr++:
                    t.classdata.generic_params.append(create_typevar(*nameptr))
                old_name: byte[500] = t.name
                t.name = create_type_name_with_params(old_name, t.classdata.generic_params)
            stmt.symbol().type = t
        case _:
            assert False

    assert stmt.symbol().status == GlobalSymbolStatus.TypeChecking
    stmt.symbol().status = GlobalSymbolStatus.Ready


# Returns True for found, False for not found. If found, constant is placed
# into the given pointer without copying.
#
# This cannot simply return a pointer to the constant, because WINDOWS and
# other such special constants are not in memory.
@public
def find_and_typecheck_constant(jou_file: JouFile*, name: byte*) -> Constant*:
    special_constant = get_special_constant(name)
    if special_constant != NULL:
        return special_constant

    stmt = find_global_symbol_statement(jou_file, name, GlobalSymbolKind.Const)
    if stmt == NULL:
        return NULL
    typecheck_statement_with_symbol(stmt)
    return &stmt.symbol().constant


# Returns type of global variable for found, NULL for not found.
@public
def find_and_typecheck_global_var(jou_file: JouFile*, name: byte*) -> Type*:
    stmt = find_global_symbol_statement(jou_file, name, GlobalSymbolKind.GlobalVar)
    if stmt == NULL:
        return NULL
    typecheck_statement_with_symbol(stmt)
    return stmt.symbol().type


# Returns signature of function if found, NULL for not found.
@public
def find_and_typecheck_function(jou_file: JouFile*, name: byte*) -> Signature*:
    stmt = find_global_symbol_statement(jou_file, name, GlobalSymbolKind.Function)
    if stmt == NULL:
        return NULL
    typecheck_statement_with_symbol(stmt)
    return &stmt.symbol().signature


# Returns signature of method if found, NULL for not found.
@public
def find_and_typecheck_method(jou_file: JouFile*, class_type: Type*, method_name: byte*) -> Signature*:
    assert class_type != NULL
    assert class_type.kind == TypeKind.Class

    # The "append" method in List[int] is named "List.append"
    n = strcspn(class_type.name, "[")
    symbol_name: byte[200]
    snprintf(symbol_name, sizeof(symbol_name), "%.*s.%s", n as int, class_type.name, method_name)

    stmt = find_global_symbol_statement(jou_file, symbol_name, GlobalSymbolKind.Method)
    if stmt == NULL:
        return NULL
    typecheck_statement_with_symbol(stmt)
    return &stmt.symbol().signature


# Returns type if found, NULL if not found.
@public
def find_and_typecheck_type(jou_file: JouFile*, name: byte*) -> Type*:
    stmt = find_global_symbol_statement(jou_file, name, GlobalSymbolKind.Type)
    if stmt == NULL:
        return NULL
    typecheck_statement_with_symbol(stmt)
    return stmt.symbol().type


# Returns type representing List[T] or similar (with dummy typevars) if found, NULL if not found.
@public
def find_and_typecheck_generic_class(jou_file: JouFile*, name: byte*) -> Type*:
    stmt = find_global_symbol_statement(jou_file, name, GlobalSymbolKind.GenericClass)
    if stmt == NULL:
        return NULL
    typecheck_statement_with_symbol(stmt)
    return stmt.symbol().type


def check_compile_time_assert(jou_file: JouFile*, location: Location, condition: AstExpression*) -> None:
    c: Constant
    if not evaluate_constant_expression(jou_file, condition, &c, bool_type()):
        fail(location, "cannot evaluate assertion at compile time")
    if c.get_type() != bool_type():
        msg: byte[500]
        snprintf(msg, sizeof(msg), "assertion must be a bool, not %s", c.get_type().name)
        fail(location, msg)
    if not c.boolean:
        fail(location, "assertion is False")


@public
def typecheck_step1_global_symbols() -> None:
    if global_compiler_state.args.verbosity >= 1:
        printf("Typecheck: global symbols (step 1/3)\n")

    for jou_file = global_compiler_state.jou_files.ptr; jou_file < global_compiler_state.jou_files.end(); jou_file++:
        if global_compiler_state.args.verbosity >= 1:
            printf("  %s\n", jou_file.path)

        for sym_stmt = jou_file.symbol_statements.ptr; sym_stmt < jou_file.symbol_statements.end(); sym_stmt++:
            typecheck_statement_with_symbol(*sym_stmt)

        for stmt = jou_file.ast.ptr; stmt < jou_file.ast.end(); stmt++:
            if stmt.kind == AstStatementKind.Assert:
                check_compile_time_assert(jou_file, stmt.location, &stmt.assertion.condition)
