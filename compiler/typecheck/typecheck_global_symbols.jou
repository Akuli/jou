import "stdlib/assert.jou"
import "stdlib/str.jou"

import "../global_symbols.jou"
import "../types.jou"
import "../errors_and_warnings.jou"
import "../ast.jou"
import "../constants.jou"
import "../state.jou"
import "../evaluate.jou"
import "./common.jou"


@public
def typecheck_statement_with_symbol(jou_file: JouFile*, stmt: AstStatement*) -> None:
    assert stmt.symbol() != NULL

    match stmt.symbol().status:
        case GlobalSymbolStatus.NotTypeChecked:
            pass
        case GlobalSymbolStatus.TypeChecking:
            match stmt.symbol().kind:
                case GlobalSymbolKind.Const:
                    fail(stmt.location, "value of constant depends on itself")
                case _:
                    # TODO: do the rest
                    assert False
        case GlobalSymbolStatus.Ready:
            return

    stmt.symbol().status = GlobalSymbolStatus.TypeChecking

    match stmt.kind:
        case AstStatementKind.Const:
            expected_type = type_from_ast(&jou_file.types, NULL, &stmt.const_statement.type)

            value: Constant
            if not evaluate_constant_expression(jou_file, &stmt.const_statement.value, &value, expected_type):
                fail(stmt.location, "cannot evaluate value of constant at compile time")

            # TODO: allow implicit casts?
            if value.get_type().unwrap_typedef(&stmt.location) != expected_type.unwrap_typedef(&stmt.location):
                msg: byte[500]
                snprintf(
                    msg, sizeof(msg),
                    "constant of type %s cannot have a value of type %s",
                    expected_type.name,
                    value.get_type().name
                )
                fail(stmt.location, msg)

            stmt.symbol().constant = value

        case AstStatementKind.GlobalVariableDeclare:
            stmt.symbol().type = type_from_ast(&jou_file.types, NULL, &stmt.global_var_declare.type)
        case AstStatementKind.GlobalVariableDef:
            stmt.symbol().type = type_from_ast(&jou_file.types, NULL, &stmt.global_var_def.type)
        case _:
            assert False

    assert stmt.symbol().status == GlobalSymbolStatus.TypeChecking
    stmt.symbol().status = GlobalSymbolStatus.Ready


# If you have a Jou file that has access to printf() function from stdlib/io.jou,
# then this function returns the `declare` statement in stdlib/io.jou when you
# call this with the file and the string "printf".
#
# This also finds things defined in the same file.
#
# Note: For special constants like "WINDOWS" this returns NULL, be aware!!!
def find_global_symbol_statement(jou_file: JouFile*, name: byte*, mark_used: bool) -> AstStatement*:
    # Defined in this file?
    for stmt = jou_file.ast.ptr; stmt < jou_file.ast.end(); stmt++:
        if stmt.symbol() != NULL and strcmp(stmt.symbol().name, name) == 0:
            if mark_used:
                stmt.symbol().used = True
            return stmt

    # Imported?
    for imported = jou_file.imported_from_other_files.ptr; imported < jou_file.imported_from_other_files.end(); imported++:
        stmt = imported.statement_in_other_file
        assert stmt.symbol() != NULL
        if strcmp(stmt.symbol().name, name) == 0:
            if mark_used:
                stmt.symbol().used = True
                imported.the_import.used = True
            return stmt

    return NULL


# Returns True for found, False for not found. If found, constant is placed
# into the given pointer without copying.
#
# This cannot simply return a pointer to the constant, because WINDOWS and
# other such special constants are not in memory.
#
# TODO: just return pointer to constant, use global compiler state...
@public
def find_and_typecheck_constant(jou_file: JouFile*, name: byte*, out_ptr: Constant*, mark_used: bool) -> bool:
    match get_special_constant(name):
        case 1:
            *out_ptr = Constant{kind = ConstantKind.Bool, boolean = True}
            return True
        case 0:
            *out_ptr = Constant{kind = ConstantKind.Bool, boolean = False}
            return True
        case -1:
            pass  # not a special constant, proceed to normal lookup below
        case _:
            assert False

    stmt = find_global_symbol_statement(jou_file, name, mark_used)
    if stmt == NULL or stmt.kind != AstStatementKind.Const:
        return False

    typecheck_statement_with_symbol(jou_file, stmt)

    assert stmt.symbol().status == GlobalSymbolStatus.Ready
    if mark_used:
        stmt.symbol().used = True
    *out_ptr = stmt.symbol().constant
    return True


# Returns type of global variable for found, NULL for not found.
# TODO: refactor copy/pasta
@public
def find_and_typecheck_global_var(jou_file: JouFile*, name: byte*, mark_used: bool) -> Type*:
    stmt = find_global_symbol_statement(jou_file, name, mark_used)
    if stmt == NULL or stmt.symbol().kind != GlobalSymbolKind.GlobalVar:
        return NULL

    typecheck_statement_with_symbol(jou_file, stmt)
    return stmt.symbol().type
