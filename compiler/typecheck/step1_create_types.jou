# First step of type checking is to create types, so that they exist when later
# stages reference the types.
#
# After the first step, classes defined in Jou exist, but they are all opaque
# and contain no members. This way, when step 2 checks function signatures,
# they can refer to classes that are defined anywhere in the project, e.g.
# later in the same file.
#
# Enums are simple. The first step creates them and also fills in their members,
# although it doesn't really matter whether that's done in step 1 or 2.

import "stdlib/list.jou"

import "../ast.jou"
import "../global_symbols.jou"
import "../state.jou"
import "../errors_and_warnings.jou"
import "../types.jou"


@public
def typecheck_step1_create_types(jou_file: JouFile*) -> List[GlobalSymbol*]:
    exports = List[GlobalSymbol*]{}

    for stmt = jou_file.ast.ptr; stmt < jou_file.ast.end(); stmt++:
        match stmt.kind:
            case AstStatementKind.Class:
                t = create_empty_class(stmt.symbol().name)
                if stmt.classdef.is_generic():
                    for nameptr = stmt.classdef.generic_typevar_names.ptr; nameptr < stmt.classdef.generic_typevar_names.end(); nameptr++:
                        t.classdata.generic_params.append(create_typevar(*nameptr))
                    old_name: byte[500] = t.name
                    t.name = create_type_name_with_params(old_name, t.classdata.generic_params)
            case AstStatementKind.Enum:
                t = create_enum(stmt.symbol().name, stmt.enumdef.members)
            case AstStatementKind.TypeDef:
                t = create_typedef_type(stmt.symbol().name)
            case _:
                continue

        stmt.symbol().type = t

        existing = jou_file.types.find_type(stmt.symbol().name)
        if existing != NULL:
            fail(stmt.location, "blub")

        if stmt.kind == AstStatementKind.Class and stmt.classdef.is_generic():
            jou_file.types.add_generic_class(t, &stmt.symbol().used)
        else:
            jou_file.types.add_type(t, &stmt.symbol().used)

        if stmt.symbol().public:
            exports.append(stmt.symbol())

    return exports
