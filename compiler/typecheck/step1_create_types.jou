# First step of type checking is to create types, so that they exist when later
# stages reference the types.
#
# After the first step, classes defined in Jou exist, but they are all opaque
# and contain no members. This way, when step 2 checks function signatures,
# they can refer to classes that are defined anywhere in the project, e.g.
# later in the same file.
#
# Enums are simple. The first step creates them and also fills in their members,
# although it doesn't really matter whether that's done in step 1 or 2.

import "stdlib/str.jou"
import "stdlib/list.jou"

import "../ast.jou"
import "../global_symbols.jou"
import "../state.jou"
import "../errors_and_warnings.jou"
import "../types.jou"


# When defining a generic class Foo[T], this function creates the T and
# attaches it to the Foo type. It also renames the type from "Foo" to "Foo[T]".
def handle_generics(t: Type*, classdef: AstClassDef*) -> None:
    assert t.kind == TypeKind.Class
    assert classdef.is_generic()
    for nameptr = classdef.generic_typevar_names.ptr; nameptr < classdef.generic_typevar_names.end(); nameptr++:
        t.classdata.generic_params.append(create_typevar(*nameptr))

    old_name: byte[500] = t.name
    t.name = create_type_name_with_params(old_name, t.classdata.generic_params)


@public
def typecheck_step1_create_types(jou_file: JouFile*) -> List[GlobalSymbol*]:
    exports = List[GlobalSymbol*]{}

    for stmt = jou_file.ast.ptr; stmt < jou_file.ast.end(); stmt++:
        match stmt.kind:
            case AstStatementKind.Class:
                # TODO: clean up!! lots of spaghetti
                name = stmt.symbol().name
                public = stmt.symbol().public
                usedptr = &stmt.symbol().used
                t = create_empty_class(name)
                if stmt.classdef.is_generic():
                    handle_generics(t, &stmt.classdef)
                stmt.symbol().type = t
            case AstStatementKind.Enum:
                name = stmt.symbol().name
                public = stmt.symbol().public
                usedptr = &stmt.symbol().used
                t = create_enum(name, stmt.enumdef.members)
                stmt.symbol().type = t
            case AstStatementKind.TypeDef:
                name = stmt.symbol().name
                public = stmt.symbol().public
                usedptr = &stmt.symbol().used
                t = create_typedef_type(name)
                stmt.symbol().type = t
            case _:
                continue

        existing = jou_file.types.find_type(name)
        if existing != NULL:
            msg: byte[500]
            snprintf(msg, sizeof(msg), "%s named '%s' already exists", existing.short_description(), name)
            fail(stmt.location, msg)

        if stmt.kind == AstStatementKind.Class and stmt.classdef.is_generic():
            jou_file.types.add_generic_class(t, usedptr)
        else:
            jou_file.types.add_type(t, usedptr)

        if public:
            if stmt.kind == AstStatementKind.Class and stmt.classdef.is_generic():
                k = GlobalSymbolKind.GenericClass
            else:
                k = GlobalSymbolKind.Type
            assert stmt.symbol().kind == k
            assert stmt.symbol().type == t
            assert strcmp(stmt.symbol().name, name) == 0
            exports.append(stmt.symbol())

    return exports
