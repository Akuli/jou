# Contains data structures and functions that are shared among multiple type
# checking steps.

import "stdlib/assert.jou"
import "stdlib/io.jou"
import "stdlib/str.jou"
import "stdlib/mem.jou"

import "../ast.jou"
import "../state.jou"
import "../evaluate.jou"
import "../errors_and_warnings.jou"
import "../types.jou"
import "./step1_global_symbols.jou"


@public
def plural_s(n: int64) -> byte*:
    if n == 1:
        # e.g. "1 argument"
        return ""
    else:
        # e.g. "0 arguments", "2 arguments"
        return "s"


def array_type_from_ast(jou_file: JouFile*, item_type: Type*, length_ast: AstExpression*) -> Type*:
    length = evaluate_array_length(jou_file, length_ast)
    if length <= 0:
        fail(length_ast.location, "array length must be positive")
    return item_type.array_type(length)


def convert_array_length_given_as_type_to_an_expression(type: AstType*) -> AstExpression:
    match type.kind:
        case AstTypeKind.Named:
            return AstExpression{
                location = type.location,
                kind = AstExpressionKind.GetVariable,
                varname = type.name,
            }
        case AstTypeKind.Array:
            # TODO: implement this
            fail(type.location, "cannot evaluate array length at compile time")
        case AstTypeKind.Generic:
            # TODO: implement this
            fail(type.location, "cannot evaluate array length at compile time")
        case AstTypeKind.Pointer | AstTypeKind.FuncPtr | AstTypeKind.BuiltIn:
            # "Foo*" or "funcptr(...) -> ..." or "int" is not a valid expression
            fail(type.location, "invalid array length")


# This is called when we cannot find a generic class Foo when doing Foo[Bar].
# The most common reason is that it is actually an array type, not a generic:
#
#   x: Thing[NUM_THINGS]    # this is an array
#   y: List[Thing]          # this is a generic
#
# The syntax is ambiguous, and the parser assumes generic rather than array.
# This function tries to interpret the type Foo[Bar] as an array.
def handle_bad_generic(jou_file: JouFile*, generic: AstGenericType*, location: Location) -> Type*:
    assert generic != NULL
    name: byte* = generic.class_name
    msg: byte[500]

    item_type = find_and_typecheck_type(jou_file, name)
    if item_type == NULL:
        # TODO: make sure both error messages are tested
        if generic.param_types.len == 1:
            # User could be attempting generic or array, we don't know. Let's
            # make an error message that is perfectly correct for both arrays
            # and generics.
            if strcmp(name, "char") == 0:
                msg = "there is no type named 'char', use 'byte' instead"
            else:
                snprintf(msg, sizeof(msg), "there is no type named '%s'", name)
        else:
            snprintf(msg, sizeof(msg), "there is no generic class named '%s'", name)
        fail(location, msg)

    if generic.param_types.len != 1:
        # TODO: make sure this is still tested
        snprintf(msg, sizeof(msg), "%s is not generic, use just %s instead of %s[something]", name, name, name)
        fail(location, msg)

    length_expr = convert_array_length_given_as_type_to_an_expression(&generic.param_types.ptr[0])
    return array_type_from_ast(jou_file, item_type, &length_expr)


@public
def type_from_ast(jou_file: JouFile*, containing_class: Type*, asttype: AstType*) -> Type*:
    if containing_class != NULL:
        assert containing_class.kind == TypeKind.Class
        for p = containing_class.classdata.generic_params.ptr; p < containing_class.classdata.generic_params.end(); p++:
            # Should be e.g. List[T], where T is a typevar
            assert (*p).kind == TypeKind.TypeVar

    msg: byte[500]

    match asttype.kind:
        case AstTypeKind.BuiltIn:
            match asttype.name with strcmp:
                case "int":
                    return int_type(32)
                case "byte":
                    return uint_type(8)
                case "int8" | "int16" | "int32" | "int64":
                    return int_type(atoi(&asttype.name[3]))
                case "uint8" | "uint16" | "uint32" | "uint64":
                    return uint_type(atoi(&asttype.name[4]))
                case "bool":
                    return bool_type()
                case "float":
                    return float_type()
                case "double":
                    return double_type()
                case "void" | "noreturn" | "None":
                    snprintf(msg, sizeof(msg), "'%s' cannot be used here because it is not a type", asttype.name)
                    fail(asttype.location, msg)
                case _:
                    puts(asttype.name)
                    assert False

        case AstTypeKind.Named:
            # Are we inside a generic class? When defining List[T], we want to find the T.
            if containing_class != NULL:
                assert containing_class.kind == TypeKind.Class
                cdata = &containing_class.classdata
                for p = cdata.generic_params.ptr; p < cdata.generic_params.end(); p++:
                    if strcmp((*p).name, asttype.name) == 0:
                        return *p

            found = find_and_typecheck_type(jou_file, asttype.name)
            if found != NULL:
                return found

            # At this point we will show an error for sure.
            generic = find_and_typecheck_generic_class(jou_file, asttype.name)
            if generic == NULL:
                if strcmp(asttype.name, "char") == 0:
                    msg = "there is no type named 'char', use 'byte' instead"
                else:
                    snprintf(msg, sizeof(msg), "there is no type named '%s'", asttype.name)
            else:
                # Suggest int for all params of the generic class, e.g. List[int]
                assert generic.classdata.is_generic()
                ints = malloc(10 * generic.classdata.generic_params.len)
                assert ints != NULL
                strcpy(ints, "int")
                for i = 1; i < generic.classdata.generic_params.len; i++:
                    strcat(ints, ", int")
                snprintf(
                    msg, sizeof(msg),
                    "%s is a generic class, use e.g. %s[%s] instead of just %s",
                    generic.name, asttype.name, ints, asttype.name,
                )
            fail(asttype.location, msg)

        case AstTypeKind.Pointer:
            if asttype.value_type.is_void():
                return void_ptr_type()
            return type_from_ast(jou_file, containing_class, asttype.value_type).pointer_type()

        case AstTypeKind.Array:
            item_type = type_from_ast(jou_file, containing_class, asttype.array.member_type)
            return array_type_from_ast(jou_file, item_type, asttype.array.length)

        case AstTypeKind.Generic:
            name = asttype.generic.class_name
            gclass = find_and_typecheck_generic_class(jou_file, name)
            if gclass == NULL:
                return handle_bad_generic(jou_file, &asttype.generic, asttype.location)

            assert gclass.kind == TypeKind.Class
            assert gclass.classdata.is_generic()

            # Check number of parameters
            expected = gclass.classdata.generic_params.len
            got = asttype.generic.param_types.len
            if expected != got:
                snprintf(
                    msg, sizeof(msg), "generic class %s takes %zd type parameter%s, but it is used with %zd type parameter%s",
                    gclass.name, expected, plural_s(expected), got, plural_s(got),
                )
                fail(asttype.location, msg)

            assert expected == got
            n = got as int

            from = gclass.classdata.generic_params.ptr
            to: Type** = malloc(sizeof(to[0]) * n)
            assert to != NULL
            for i = 0; i < n; i++:
                to[i] = type_from_ast(jou_file, containing_class, &asttype.generic.param_types.ptr[i])

            result = gclass.substitute_generic_params(from, to, n)
            free(to)
            return result

        case AstTypeKind.FuncPtr:
            fp = asttype.func_ptr

            nargs = fp.argtypes.len
            assert nargs <= MAX_ARGS
            argtypes: Type*[MAX_ARGS]

            for i = 0; i < nargs; i++:
                argtypes[i] = type_from_ast(jou_file, containing_class, &fp.argtypes.ptr[i])

            if fp.return_type.is_none() or fp.return_type.is_noreturn():
                return_type = NULL
            else:
                return_type = type_from_ast(jou_file, containing_class, fp.return_type)

            return funcptr_type(argtypes, nargs, fp.takes_varargs, return_type, fp.return_type.is_noreturn())


@public
def typecheck_signature(jou_file: JouFile*, ast: AstFunctionOrMethod*, self_class: Type*) -> Signature:
    msg: byte[500]

    astsig = &ast.ast_signature
    sig = Signature{name = astsig.name, takes_varargs = astsig.takes_varargs}
    if ast.inline:
        sig.ast_to_inline = ast

    for astarg = astsig.args.ptr; astarg < astsig.args.end(); astarg++:
        arg = NameAndType{name = astarg.name}
        if (
            strcmp(astarg.name, "self") == 0
            and astarg.type.kind == AstTypeKind.BuiltIn
            and astarg.type.name[0] == '\0'
        ):
            # just "self" without a type after it --> default to "self: Foo*" in class Foo
            assert self_class != NULL
            arg.type = self_class.pointer_type()
        else:
            arg.type = type_from_ast(jou_file, self_class, &astarg.type)

        if strcmp(arg.name, "self") == 0 and arg.type != self_class and arg.type != self_class.pointer_type():
            snprintf(msg, sizeof(msg), "type of self must be %s* (default) or %s", self_class.name, self_class.name)
            fail(astarg.type.location, msg)

        sig.args.append(arg)

    sig.is_noreturn = astsig.return_type.is_noreturn()
    if astsig.return_type.is_none() or astsig.return_type.is_noreturn():
        sig.return_type = NULL
    elif astsig.return_type.is_void():
        snprintf(
            msg, sizeof(msg),
            "void is not a valid return type, use '-> None' if the %s does not return a value",
            "function" if self_class == NULL else "method",
        )
        fail(astsig.return_type.location, msg)
    else:
        sig.return_type = type_from_ast(jou_file, self_class, &astsig.return_type)

    if sig.is_main_function():
        if sig.return_type == NULL or sig.return_type != int_type(32):
            fail(astsig.return_type.location, "the main() function must return int")
        if (
            sig.args.len != 0
            and not (
                sig.args.len == 2
                and sig.args.ptr[0].type == int_type(32)
                and sig.args.ptr[1].type == uint_type(8).pointer_type().pointer_type()
            )
        ):
            fail(
                astsig.args.ptr[0].type.location,
                "if the main() function takes parameters, it should be defined like this: def main(argc: int, argv: byte**) -> int"
            )

    return sig
