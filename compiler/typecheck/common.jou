# Contains data structures and functions that are shared among multiple type
# checking steps.

import "stdlib/io.jou"
import "stdlib/math.jou"
import "stdlib/str.jou"
import "stdlib/mem.jou"

import "../ast.jou"
import "../evaluate.jou"
import "../errors_and_warnings.jou"
import "../types.jou"
import "../types_in_ast.jou"


# Type checking steps 1 and 2 return export symbols to be passed on to the next
# step. That's how the next step accesses the results of the previous step.
enum ExportSymbolKind:
    Function
    Type
    GlobalVar

class ExportSymbol:
    kind: ExportSymbolKind
    name: byte[100]  # TODO: maybe this should be 200 because it can be ClassName.method_name? or something else?
    union:
        funcsignature: Signature
        type: Type*  # ExportSymbolKind.Type and ExportSymbolKind.GlobalVar

    def free(self) -> None:
        if self->kind == ExportSymbolKind.Function:
            self->funcsignature.free()


@public
def type_from_ast(ft: FileTypes*, asttype: AstType*) -> Type*:
    msg: byte[500]

    if asttype->is_void() or asttype->is_none() or asttype->is_noreturn():
        snprintf(msg, sizeof(msg), "'%s' cannot be used here because it is not a type", asttype->name)
        fail(asttype->location, msg)

    match asttype->kind:
        case AstTypeKind.Named:
            if strcmp(asttype->name, "short") == 0:
                return shortType
            if strcmp(asttype->name, "int") == 0:
                return intType
            if strcmp(asttype->name, "long") == 0:
                return longType
            if strcmp(asttype->name, "byte") == 0:
                return byteType
            if strcmp(asttype->name, "bool") == 0:
                return boolType
            if strcmp(asttype->name, "float") == 0:
                return floatType
            if strcmp(asttype->name, "double") == 0:
                return doubleType

            found = ft->find_type(asttype->name)
            if found != NULL:
                return found

            snprintf(msg, sizeof(msg), "there is no type named '%s'", asttype->name)
            fail(asttype->location, msg)

        case AstTypeKind.Pointer:
            if asttype->value_type->is_void():
                return voidPtrType
            return type_from_ast(ft, asttype->value_type)->pointer_type()

        case AstTypeKind.Array:
            tmp = type_from_ast(ft, asttype->value_type)
            len = evaluate_array_length(asttype->array.length)
            if len <= 0:
                fail(asttype->array.length->location, "array length must be positive")
            return tmp->array_type(len)
