# Second step of type checking is to check function/method signatures, global
# variables, and bodies of classes. However, we don't look into function or
# method bodies yet, because they reference other functions and methods which
# might not exist.
#
# After the second step, all types, functions, and global variables are ready.
#
# This step assumes that all types exist, but doesn't need to know what fields
# and methods each class has.

import "stdlib/assert.jou"
import "stdlib/str.jou"

import "../ast.jou"
import "../state.jou"
import "../types.jou"
import "../errors_and_warnings.jou"
import "./common.jou"
import "./typecheck_global_symbols.jou"


def check_class_member_not_exist(t: Type*, name: byte*, location: Location) -> None:
    msg: byte[500]
    assert t.kind == TypeKind.Class

    field = t.find_class_field(name)
    if field != NULL:
        # TODO: this is complicated, should just use same error message for fields and union members
        assert t.classdata.fields.ptr <= field and field < t.classdata.fields.end()

        belongs_to_a_union = (
            (field > t.classdata.fields.ptr and field[-1].union_id == field.union_id)
            or (&field[1] < t.classdata.fields.end() and field[1].union_id == field.union_id)
        )

        if belongs_to_a_union:
            snprintf(msg, sizeof(msg), "class %s already has a union member named '%s'", t.name, name)
        else:
            snprintf(msg, sizeof(msg), "class %s already has a field named '%s'", t.name, name)
        fail(location, msg)

    if t.find_method(name) != NULL:
        snprintf(msg, sizeof(msg), "class %s already has a method named '%s'", t.name, name)
        fail(location, msg)


def handle_class_members(jou_file: JouFile*, classdef: AstClassDef*) -> None:
    # Previous type-checking step created an empty class.
    t = classdef.symbol.type
    assert t != NULL
    assert t.kind == TypeKind.Class

    union_id = 0
    for stmt = classdef.body.ptr; stmt < classdef.body.end(); stmt++:
        match stmt.kind:
            case AstStatementKind.ClassField:
                f = ClassField{
                    name = stmt.class_field.name,
                    type = type_from_ast(jou_file, t, &stmt.class_field.type),
                    union_id = union_id++,
                }
                check_class_member_not_exist(t, f.name, stmt.location)
                t.classdata.fields.append(f)

            case AstStatementKind.ClassUnion:
                uid = union_id++
                for ntv = stmt.union_fields.ptr; ntv < stmt.union_fields.end(); ntv++:
                    for ntv2 = &ntv[1]; ntv2 < stmt.union_fields.end(); ntv2++:
                        if strcmp(ntv.name, ntv2.name) == 0:
                            msg: byte[500]
                            snprintf(msg, sizeof(msg), "duplicate union member '%s'", ntv.name)
                            fail(ntv2.name_location, msg)

                    f = ClassField{
                        name = ntv.name,
                        type = type_from_ast(jou_file, t, &ntv.type),
                        union_id = uid,
                    }
                    check_class_member_not_exist(t, f.name, ntv.name_location)
                    t.classdata.fields.append(f)

            case AstStatementKind.MethodDef:
                # Don't handle the method body yet: that is a part of step 3, not step 2
                sig = typecheck_signature(jou_file, &stmt.method, t)
                stmt.method.symbol.signature = sig

                check_class_member_not_exist(t, sig.name, stmt.location)
                t.classdata.methods.append(sig.copy())

            case AstStatementKind.Pass:
                pass

            case _:
                assert False

    if t.classdata.is_generic():
        t.update_fields_and_methods_to_generic_instances()


@public
def typecheck_step2_populate_types(jou_file: JouFile*) -> None:
    for stmt = jou_file.ast.ptr; stmt < jou_file.ast.end(); stmt++:
        match stmt.kind:
            case (
                AstStatementKind.GlobalVariableDeclare
                | AstStatementKind.GlobalVariableDef
                | AstStatementKind.Const
                | AstStatementKind.TypeDef
                | AstStatementKind.FunctionDeclare
                | AstStatementKind.FunctionDef
            ):
                typecheck_statement_with_symbol(stmt)
            case AstStatementKind.Class:
                handle_class_members(jou_file, &stmt.classdef)
            case _:
                pass
