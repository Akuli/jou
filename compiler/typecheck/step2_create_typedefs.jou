# Second step of type checking is to handle `typedef` statements, which create
# more names for existing types.
#
# After the first two steps, all types defined in Jou exist, but may not be
# ready, e.g. classes don't contain any members yet. This way, when later steps
# check function signatures, they can refer to classes that are defined
# anywhere in the project, e.g. later in the same file.

import "stdlib/list.jou"

import "../ast.jou"
import "./common.jou"


@public
def typecheck_step2_create_typedefs(ast: AstFile*) -> List[ExportSymbol]:
    exports = List[ExportSymbol]{}

    for stmt = ast.body.ptr; stmt < ast.body.end(); stmt++:
        if stmt.kind != AstStatementKind.TypeDef:
            continue
        tdef = &stmt.typedef_statement

        t = type_from_ast(&ast.types, NULL, &tdef.ast_type)
        tdef.type = t
        ast.types.add_type_with_name(t, tdef.name, &tdef.used)
        if tdef.public:
            exports.append(ExportSymbol{kind = ExportSymbolKind.Type, type = t, name = tdef.name})

    return exports
