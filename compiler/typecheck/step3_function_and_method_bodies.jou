# The third and final step of type checking. Checks the code inside functions
# and methods.
#
# After the third step, local variables exist, and the types of all values in
# the program are known.
#
# This step assumes that all types, global variables, functions etc. already
# exist and are fully populated, so that we e.g. know what methods each class
# has and what parameter types they take.

import "stdlib/assert.jou"
import "stdlib/intnative.jou"
import "stdlib/io.jou"
import "stdlib/list.jou"
import "stdlib/str.jou"
import "stdlib/math.jou"
import "stdlib/mem.jou"

import "../ast.jou"
import "../state.jou"
import "../constants.jou"
import "../errors_and_warnings.jou"
import "../evaluate.jou"
import "../types.jou"
import "./common.jou"
import "./step1_global_symbols.jou"


class State:
    jou_file: JouFile*
    fom: AstFunctionOrMethod*

    def find_any_var(self, name: byte*) -> Type*:
        for local = self.fom.locals.ptr; local < self.fom.locals.end(); local++:
            if strcmp(local.name, name) == 0:
                return local.type
        return find_and_typecheck_global_var(self.jou_file, name)

    def find_any_var_or_constant(self, name: byte*) -> Type*:
        vartype = self.find_any_var(name)
        if vartype != NULL:
            return vartype
        c = find_and_typecheck_constant(self.jou_file, name)
        if c != NULL:
            return c.get_type()
        return NULL


# Intended for errors. Returned string can be overwritten in next call.
# Imagine "cannot assign to" in front of these, e.g. "cannot assign to a constant"
def short_expression_description(expr: AstExpression*) -> byte[200]:
    result: byte[200]

    match expr.kind:
        case AstExpressionKind.IntegerConstant | AstExpressionKind.Constant:
            return "a constant"
        case AstExpressionKind.GetEnumMember:
            return "an enum member"
        case AstExpressionKind.SizeOf:
            return "a sizeof expression"
        case AstExpressionKind.ArrayCount:
            return "an array_count expression"
        case AstExpressionKind.EmbedFile:
            return "an embed_file expression"
        case AstExpressionKind.EnumCount:
            return "an enum_count expression"
        case AstExpressionKind.Instantiate:
            return "a newly created instance"
        case AstExpressionKind.Array:
            return "an array literal"
        case AstExpressionKind.Indexing:
            return "an indexed value"
        case AstExpressionKind.As:
            return "the result of a cast"
        case AstExpressionKind.Dereference:
            return "the value of a pointer"
        case AstExpressionKind.And:
            return "the result of 'and'"
        case AstExpressionKind.Or:
            return "the result of 'or'"
        case AstExpressionKind.Not:
            return "the result of 'not'"
        case AstExpressionKind.Self:
            return "self"

        case AstExpressionKind.Call:
            if expr.call.method_call_self == NULL:
                return "a function call"
            else:
                return "a method call"

        case AstExpressionKind.GetVariable:
            return "a variable"
        case AstExpressionKind.GetFuncPtr:
            return "a function"

        case (
            AstExpressionKind.Negate
            | AstExpressionKind.Add
            | AstExpressionKind.Sub
            | AstExpressionKind.Mul
            | AstExpressionKind.Div
            | AstExpressionKind.Mod
            | AstExpressionKind.BitAnd
            | AstExpressionKind.BitOr
            | AstExpressionKind.BitXor
            | AstExpressionKind.BitShiftLeft
            | AstExpressionKind.BitShiftRight
            | AstExpressionKind.BitNot
        ):
            return "the result of a calculation"

        case (
            AstExpressionKind.Eq
            | AstExpressionKind.Ne
            | AstExpressionKind.Gt
            | AstExpressionKind.Ge
            | AstExpressionKind.Lt
            | AstExpressionKind.Le
        ):
            return "the result of a comparison"

        case AstExpressionKind.TernaryIf:
            return "a ternary expression"

        case AstExpressionKind.PreIncr | AstExpressionKind.PostIncr:
            return "the result of incrementing a value"
        case AstExpressionKind.PreDecr | AstExpressionKind.PostDecr:
            return "the result of decrementing a value"

        case AstExpressionKind.AddressOf:
            inner = short_expression_description(&expr.operands[0])
            snprintf(result, sizeof result, "address of %s", inner)
            return result

        case AstExpressionKind.GetClassField | AstExpressionKind.GetClassFieldPtr | AstExpressionKind.DotOperator:
            snprintf(result, sizeof result, "field '%s'", expr.class_field.field_name)
            return result


# The & operator can't go in front of most expressions.
# You can't do &(1 + 2), for example.
#
# The same rules apply to assignments: "foo = bar" is treated as setting the
# value of the pointer &foo to bar.
#
# errmsg_template can be e.g. "cannot take address of %s" or "cannot assign to %s"
def ensure_can_take_address(fom: AstFunctionOrMethod*, expr: AstExpression*, errmsg_template: byte*) -> None:
    assert fom != NULL

    # If this assertion fails, it means you called ensure_can_take_address()
    # before type-checking the expression. That's bad because this depends on
    # the results of type checking.
    #
    # The dependency is a bit surprising. Jou code "foo.bar" can mean many things:
    #   - "foo" is an enum, "bar" is an enum member
    #   - "foo" is an instance of a class, "bar" is a field
    #   - "foo" is a pointer to an instance of a class, "bar" is a field
    assert expr.types.orig_type != NULL

    if (
        expr.kind == AstExpressionKind.Dereference
        # &pointer[index] = pointer + itemsize*index (doesn't use &pointer)
        or expr.kind == AstExpressionKind.Indexing
        # &pointer.field = pointer + offset (doesn't use &pointer)
        or expr.kind == AstExpressionKind.GetClassFieldPtr
    ):
        return

    if expr.kind == AstExpressionKind.GetClassField:
        # &foo.bar = &foo + offset
        #
        # Turn "cannot assign to %s" into "cannot assign to a field of %s".
        # This assumes that errmsg_template is relatively simple, i.e. it only contains one %s somewhere.
        newtemplate: byte*
        asprintf(&newtemplate, errmsg_template, "a field of %s")

        ensure_can_take_address(fom, expr.class_field.instance, newtemplate)
        free(newtemplate)
        return

    if expr.kind == AstExpressionKind.GetVariable:
        return

    # You can take address of self if it's not passed as a pointer:
    #
    #   def method(self: MyClass) -> None:
    #       do_something(&self)
    #
    # This lets you e.g. write methods that return a modified instance.
    if (
        expr.kind == AstExpressionKind.Self
        and fom.symbol.signature.args.ptr[0].type.kind == TypeKind.Class
    ):
        return

    msg: byte[500]
    desc = short_expression_description(expr)
    snprintf(msg, sizeof(msg), errmsg_template, desc)
    fail(expr.location, msg)


# Implicit casts are used in many places, e.g. function arguments.
#
# When you pass an argument of the wrong type, it's best to give an error message
# that says so, instead of some generic "expected type foo, got object of type bar"
# kind of message.
#
# The template can contain "<from>" and "<to>". They will be substituted with names
# of types. We cannot use printf() style functions because the arguments can be in
# any order.
def fail_with_implicit_cast_error(location: Location, template: byte*, from: Type*, to: Type*) -> None:
    assert template != NULL

    message = List[byte]{}
    while *template != '\0':
        if starts_with(template, "<from>"):
            template = &template[6]
            message.extend_from_ptr(from.name, strlen(from.name))
        elif starts_with(template, "<to>"):
            template = &template[4]
            message.extend_from_ptr(to.name, strlen(to.name))
        else:
            message.append(*template++)

    message.append('\0')
    fail(location, message.ptr)


def can_cast_implicitly(from: Type*, to: Type*) -> bool:
    # Please keep doc/types.md up to date if you modify this
    return (
        from == to
        or (from.kind == TypeKind.Array and to.kind == TypeKind.Pointer and from.array.item_type == to.value_type)
        or (from.kind == TypeKind.Array and to.kind == TypeKind.VoidPointer)
        or (
            from.is_integer_type()
            and to.is_integer_type()
            and from.size_in_bits < to.size_in_bits
            and not (from.kind == TypeKind.SignedInteger and to.kind == TypeKind.UnsignedInteger)
        )
        or (from == float_type() and to == double_type())
        or (from.is_integer_type() and to.kind == TypeKind.FloatingPoint)
        or (from.is_pointer_type() and to.is_pointer_type() and (from == void_ptr_type() or to == void_ptr_type()))
    )


def can_cast_explicitly(from: Type*, to: Type*) -> bool:
    # Please keep doc/types.md up to date if you modify this.
    #
    # This does not take into account things that type inference does, see docs.
    return (
        from == to
        or (from.kind == TypeKind.Array and to.kind == TypeKind.Pointer and from.array.item_type == to.value_type)
        or (from.kind == TypeKind.Array and to.kind == TypeKind.VoidPointer)
        or (from.is_pointer_type() and to.is_pointer_type())
        or (from.is_number_type() and to.is_number_type())
        or (from.is_integer_type() and to.kind == TypeKind.Enum)
        or (from.kind == TypeKind.Enum and to.is_integer_type())
        or (from == bool_type() and to.is_integer_type())
        or (from.is_pointer_type() and to == int_type(64))
        or (from == int_type(64) and to.is_pointer_type())
    )


def do_implicit_cast(
    fom: AstFunctionOrMethod*,
    expr: AstExpression*,
    to: Type*,
    location: Location,
    errormsg_template: byte*,
) -> None:
    assert expr.types.orig_type != NULL
    assert expr.types.implicit_cast_type == expr.types.orig_type
    assert not expr.types.implicit_array_to_pointer_cast

    from = expr.types.orig_type
    if from == to:
        return

    # Passing in NULL for errormsg_template can be used to "force" a cast to happen.
    if errormsg_template != NULL and not can_cast_implicitly(from, to):
        fail_with_implicit_cast_error(location, errormsg_template, from, to)

    expr.types.implicit_cast_type = to
    expr.types.implicit_array_to_pointer_cast = (from.kind == TypeKind.Array and to.is_pointer_type())
    if expr.types.implicit_array_to_pointer_cast:
        ensure_can_take_address(
            fom,
            expr,
            "cannot create a pointer into an array that comes from %s (try storing it to a local variable first)"
        )


def cast_array_to_pointer(fom: AstFunctionOrMethod*, expr: AstExpression*) -> None:
    assert expr.types.orig_type != NULL
    assert expr.types.orig_type.kind == TypeKind.Array
    do_implicit_cast(fom, expr, expr.types.orig_type.array.item_type.pointer_type(), Location{}, NULL)


def do_explicit_cast(fom: AstFunctionOrMethod*, expr: AstExpression*, to: Type*, location: Location) -> None:
    assert expr.types.orig_type != NULL
    assert expr.types.implicit_cast_type == expr.types.orig_type
    from = expr.types.orig_type

    msg: byte[500]

    if not can_cast_explicitly(from, to):
        snprintf(msg, sizeof(msg), "cannot cast from type %s to %s", from.name, to.name)
        fail(location, msg)

    if from.kind == TypeKind.Array and to.is_pointer_type():
        cast_array_to_pointer(fom, expr)


def typecheck_expression_not_void(state: State*, expr: AstExpression*, type_hint: Type*) -> Type*:
    typecheck_expression(state, expr, type_hint)
    if expr.types.orig_type != NULL:
        # The happy path. Evaluating the expression results in a value.
        return expr.types.orig_type

    # Should be function/method call that returns None
    assert expr.kind == AstExpressionKind.Call

    msg: byte[500]
    if expr.call.signature_if_known == NULL:
        snprintf(msg, sizeof(msg), "%s does not return a value", expr.call.function_or_method())
    else:
        snprintf(msg, sizeof(msg), "%s '%s' does not return a value", expr.call.function_or_method(), expr.call.signature_if_known.name)

    fail(expr.location, msg)


def typecheck_expression_with_implicit_cast(
    state: State*,
    expr: AstExpression*,
    casttype: Type*,
    errormsg_template: byte*,
) -> None:
    assert casttype != NULL
    typecheck_expression_not_void(state, expr, casttype)
    do_implicit_cast(state.fom, expr, casttype, expr.location, errormsg_template)


def cast_type_of_integer_binop(ltype: Type*, rtype: Type*, op: AstExpressionKind) -> Type*:
    assert ltype.is_integer_type()
    assert rtype.is_integer_type()

    lhs_signed = ltype.kind == TypeKind.SignedInteger
    rhs_signed = rtype.kind == TypeKind.SignedInteger

    match op:
        # Result of bitwise and/or/xor is always one of the two types.
        # If types are of different sizes: AND uses smaller, OR/XOR uses bigger
        # If types are the same size: use unsigned if one of the two types is unsigned
        case AstExpressionKind.BitAnd:
            if ltype.size_in_bits > rtype.size_in_bits:
                return rtype
            if ltype.size_in_bits < rtype.size_in_bits:
                return ltype
            # same size, prefer unsigned
            if lhs_signed:
                return rtype
            return ltype

        case AstExpressionKind.BitOr | AstExpressionKind.BitXor:
            if ltype.size_in_bits > rtype.size_in_bits:
                return ltype
            if ltype.size_in_bits < rtype.size_in_bits:
                return rtype
            # same size, prefer unsigned
            if lhs_signed:
                return rtype
            return ltype

        # Result of bitwise xor is the type of the left side. There is no
        # "cast type" that would be applied to both.
        case AstExpressionKind.BitShiftRight:
            assert False

        case (
            AstExpressionKind.Eq
            | AstExpressionKind.Ne
            | AstExpressionKind.Gt
            | AstExpressionKind.Ge
            | AstExpressionKind.Lt
            | AstExpressionKind.Le
        ):
            # We want to cast to a common type so that we see the true values of both sides.
            bigger_size = max(ltype.size_in_bits, rtype.size_in_bits)
            if lhs_signed and rhs_signed:
                return int_type(bigger_size)
            if lhs_signed or rhs_signed:
                # Signed vs unsigned comparing. Must use a bigger integer type.
                #
                # For example, we use int16 to compare "-1 as int8" and "255 as uint8".
                # They consist of the same bits (11111111) but they represent different values.
                #
                # The biggest integers available in Jou are 64-bit.
                # This may cast them to 128-bit, which is supported in LLVM.
                return int_type(2 * bigger_size)
            return uint_type(bigger_size)

        case _:
            # A calculation that may overflow, e.g. + - * /
            # Choose the bigger size of inputs. Result is signed if either input value is.
            bigger_size = max(ltype.size_in_bits, rtype.size_in_bits)
            if lhs_signed or rhs_signed:
                return int_type(bigger_size)
            else:
                return uint_type(bigger_size)


def check_binop(
    fom: AstFunctionOrMethod*,
    op: AstExpressionKind,
    location: Location,
    lhs: AstExpression*,
    rhs: AstExpression*,
) -> Type*:
    msg: byte[500]

    assert lhs.types.orig_type != NULL
    assert rhs.types.orig_type != NULL

    do_what: byte*
    some_kind_of_compare = False
    equals_compare = False
    need_integers = False

    match op:
        case AstExpressionKind.Add:
            do_what = "add"
        case AstExpressionKind.Sub:
            do_what = "subtract"
        case AstExpressionKind.Mul:
            do_what = "multiply"
        case AstExpressionKind.Div:
            do_what = "divide"
        case AstExpressionKind.Mod:
            do_what = "take remainder with"
        case AstExpressionKind.BitAnd:
            do_what = "take bitwise AND of"
            need_integers = True
        case AstExpressionKind.BitOr:
            do_what = "take bitwise OR of"
            need_integers = True
        case AstExpressionKind.BitXor:
            do_what = "xor"
            need_integers = True
        case AstExpressionKind.BitShiftLeft | AstExpressionKind.BitShiftRight:
            do_what = "do bitwise shift with"
            need_integers = True
        case AstExpressionKind.Eq | AstExpressionKind.Ne:
            do_what = "compare"
            some_kind_of_compare = True
            equals_compare = True
        case AstExpressionKind.Gt | AstExpressionKind.Ge | AstExpressionKind.Lt | AstExpressionKind.Le:
            do_what = "compare"
            some_kind_of_compare = True
        case _:
            assert False

    ltype = lhs.types.orig_type
    rtype = rhs.types.orig_type

    got_bools = ltype == bool_type() and rtype == bool_type()
    got_integers = ltype.is_integer_type() and rtype.is_integer_type()
    got_numbers = ltype.is_number_type() and rtype.is_number_type()
    got_enums = ltype.kind == TypeKind.Enum and ltype == rtype
    got_pointers = (
        ltype.is_pointer_type()
        and rtype.is_pointer_type()
        # Ban comparisons like int* == byte*, unless one of the two types is void*
        and (ltype == rtype or ltype == void_ptr_type() or rtype == void_ptr_type())
    )

    if (
        (not (got_bools or got_numbers or got_enums or got_pointers))
        or (got_bools and not equals_compare)
        or (got_enums and not equals_compare)
        or (got_pointers and not some_kind_of_compare)
        or (need_integers and not got_integers)
    ):
        snprintf(msg, sizeof(msg), "wrong types: cannot %s %s and %s", do_what, ltype.name, rtype.name)
        fail(location, msg)

    if op == AstExpressionKind.BitShiftLeft or op == AstExpressionKind.BitShiftRight:
        # Special-cased, because right side type does not affect the type of result.
        do_implicit_cast(fom, rhs, int_type(64), Location{}, NULL)
        return lhs.types.orig_type

    cast_type: Type* = NULL
    if got_bools:
        cast_type = bool_type()
    if got_integers:
        cast_type = cast_type_of_integer_binop(ltype, rtype, op)
        if cast_type == NULL:
            # Both operands should be cast to whatever is the bigger size
            size = max(ltype.size_in_bits, rtype.size_in_bits)
            if ltype.kind == TypeKind.SignedInteger:
                do_implicit_cast(fom, lhs, int_type(size), Location{}, NULL)
            if ltype.kind == TypeKind.UnsignedInteger:
                do_implicit_cast(fom, lhs, uint_type(size), Location{}, NULL)
            if rtype.kind == TypeKind.SignedInteger:
                do_implicit_cast(fom, rhs, int_type(size), Location{}, NULL)
            if rtype.kind == TypeKind.UnsignedInteger:
                do_implicit_cast(fom, rhs, uint_type(size), Location{}, NULL)
            return int_type(size)
    if got_numbers and not got_integers:
        if ltype == double_type() or rtype == double_type():
            cast_type = double_type()
        else:
            cast_type = float_type()
    if got_pointers:
        cast_type = uint_type(64)
    if got_enums:
        cast_type = int_type(32)
    assert cast_type != NULL

    do_implicit_cast(fom, lhs, cast_type, Location{}, NULL)
    do_implicit_cast(fom, rhs, cast_type, Location{}, NULL)

    if some_kind_of_compare:
        return bool_type()
    else:
        return cast_type


def check_increment_or_decrement(state: State*, expr: AstExpression*) -> Type*:
    bad_type_fmt, bad_expr_fmt: byte*

    match expr.kind:
        case AstExpressionKind.PreIncr | AstExpressionKind.PostIncr:
            bad_type_fmt = "cannot increment a value of type %s"
            bad_expr_fmt = "cannot increment %s"
        case AstExpressionKind.PreDecr | AstExpressionKind.PostDecr:
            bad_type_fmt = "cannot decrement a value of type %s"
            bad_expr_fmt = "cannot decrement %s"
        case _:
            assert False

    t = typecheck_expression_not_void(state, &expr.operands[0], NULL)
    if not t.is_number_type() and t.kind != TypeKind.Pointer:
        msg: byte[500]
        snprintf(msg, sizeof(msg), bad_type_fmt, t.name)
        fail(expr.location, msg)

    ensure_can_take_address(state.fom, &expr.operands[0], bad_expr_fmt)
    return t


def typecheck_dereferenced_pointer(location: Location, t: Type*) -> None:
    # TODO: improved error message for dereferencing void*
    if t.kind != TypeKind.Pointer:
        msg: byte[500]
        snprintf(msg, sizeof(msg), "the dereference operator '*' is only for pointers, not for %s", t.name)
        fail(location, msg)


# ptr[index]
def typecheck_indexing(
    state: State*,
    ptrexpr: AstExpression*,
    indexexpr: AstExpression*,
) -> Type*:
    msg: byte[500]

    orig_type = typecheck_expression_not_void(state, ptrexpr, NULL)
    match orig_type.kind:
        case TypeKind.Pointer:
            ptrtype = orig_type
        case TypeKind.Array:
            cast_array_to_pointer(state.fom, ptrexpr)
            ptrtype = ptrexpr.types.implicit_cast_type
        case _:
            snprintf(msg, sizeof(msg), "value of type %s cannot be indexed", orig_type.name)
            fail(ptrexpr.location, msg)

    assert ptrtype != NULL
    assert ptrtype.kind == TypeKind.Pointer

    indextype = typecheck_expression_not_void(state, indexexpr, NULL)
    assert indextype != NULL
    if not indextype.is_integer_type():
        snprintf(msg, sizeof(msg), "the index inside [...] must be an integer, not %s", indextype.name)
        fail(indexexpr.location, msg)

    # LLVM assumes that indexes smaller than 64 bits are signed.
    # https://github.com/Akuli/jou/issues/48
    do_implicit_cast(state.fom, indexexpr, int_type(64), Location{}, NULL)

    return ptrtype.value_type


def typecheck_and_or(
    state: State*,
    lhsexpr: AstExpression*,
    rhsexpr: AstExpression*,
    and_or: byte*,
) -> None:
    assert strcmp(and_or, "and") == 0 or strcmp(and_or, "or") == 0

    errormsg: byte[100]
    snprintf(errormsg, sizeof(errormsg), "'%s' only works with bools, not <from>", and_or)

    typecheck_expression_with_implicit_cast(state, lhsexpr, bool_type(), errormsg)
    typecheck_expression_with_implicit_cast(state, rhsexpr, bool_type(), errormsg)


# This handles e.g. the things to format in printf().
def typecheck_vararg(state: State*, expr: AstExpression*, what_we_calling: byte*) -> None:
    t = typecheck_expression_not_void(state, expr, NULL)
    if t.kind == TypeKind.Array:
        cast_array_to_pointer(state.fom, expr)
    elif (t.is_integer_type() and t.size_in_bits < 32) or t == bool_type():
        # Add implicit cast to signed int, just like in C.
        do_implicit_cast(state.fom, expr, int_type(32), Location{}, NULL)
    elif t == float_type():
        do_implicit_cast(state.fom, expr, double_type(), Location{}, NULL)
    elif t.kind == TypeKind.Enum:
        msg: byte[500]
        snprintf(
            msg, sizeof(msg),
            "variadic arguments of %s cannot be enums",
            what_we_calling,
        )
        fail(expr.location, msg)


def nth(n: int) -> byte[100]:
    result: byte[100]

    assert n >= 1
    first_few = [NULL, "first", "second", "third", "fourth", "fifth", "sixth"]
    if n < array_count(first_few):
        strcpy(result, first_few[n])
    else:
        sprintf(result, "%dth", n)

    return result


def fail_with_method_not_found(
    state: State*,
    location: Location,
    self_class: Type*,
    method_name: byte*,
) -> noreturn:
    assert self_class.kind == TypeKind.Class
    class_ast = self_class.classdata.definition
    assert class_ast != NULL
    assert class_ast.kind == AstStatementKind.Class

    msg: byte[500]

    # Is the method in the class definition?
    for stmt = class_ast.classdef.body.ptr; stmt < class_ast.classdef.body.end(); stmt++:
        if (
            stmt.kind == AstStatementKind.MethodDef
            and strcmp(stmt.method.ast_signature.name, method_name) == 0
            and strcmp(stmt.location.path, state.jou_file.path) != 0
        ):
            # Method exists
            if stmt.symbol().public:
                # TODO: generate something that can be copy/pasted to write an import statement?
                snprintf(
                    msg, sizeof(msg),
                    "to use the '%s' method of class %s, you need to import the file that defines it (%s)",
                    method_name,
                    self_class.name,
                    stmt.location.path,
                )
            else:
                snprintf(
                    msg, sizeof(msg),
                    "method '%s' of class %s is private (maybe add @public to it?)",
                    method_name,
                    self_class.name,
                )
            fail(location, msg)

    snprintf(msg, sizeof(msg), "class %s has no method named '%s'", self_class.name, method_name)
    fail(location, msg)


# This is for code that looks like obj.member(). It could be a method call or a
# function pointer call, because `obj` may have a field whose type is funcptr.
#
# This function type checks the `obj.member` part
#
# Possible return values are:
#
#   NULL:
#       `member` is a method. The `call` has been updated accordingly.
#
#   non-NULL:
#       `member` is a field. Return value is the type of the field.
def typecheck_member_that_looks_like_method(state: State*, call: AstCall*) -> Type*:
    assert call.function != NULL
    func_location = call.function.location
    msg: byte[500]

    # Let's type-check `obj` and go from there.
    obj = call.function.class_field.instance
    member_name = call.function.class_field.field_name
    obj_type = typecheck_expression_not_void(state, obj, NULL)

    if obj_type.kind == TypeKind.Class:
        self_class = obj_type
    elif obj_type.kind == TypeKind.Pointer and obj_type.value_type.kind == TypeKind.Class:
        self_class = obj_type.value_type
    else:
        snprintf(
            msg, sizeof(msg),
            "left side of '.' operator must be an instance of a class or a pointer to an instance, not %s",
            obj_type.name,
        )
        fail(func_location, msg)
    assert self_class.kind == TypeKind.Class

    assert call.signature_if_known == NULL
    sig = find_and_typecheck_method(state.jou_file, self_class, member_name)
    if sig != NULL:
        # It is a method
        free(call.function)
        call.function = NULL
        call.method_call_self = obj
        sig2 = sig.copy()
        if self_class.classdata.is_generic():
            from = sig.get_self_class().classdata.generic_params  # List[T] --> list containing T
            to = self_class.classdata.generic_params
            assert from.len == to.len
            sig2.substitute_generic_params(from.ptr, to.ptr, from.len as int)
        call.signature_if_known = malloc(sizeof(sig2))
        assert call.signature_if_known != NULL
        *call.signature_if_known = sig2
        return NULL

    field = self_class.find_class_field(member_name)
    if field == NULL:
        fail_with_method_not_found(state, func_location, self_class, member_name)

    # It is a function pointer call where the function is in a class field.
    # It looks like obj.field().
    #
    # Ideally these would be handled so that we just type-check the whole
    # thing as a function call and don't special-case anything. Unfortunately
    # that's not possible because we already type-checked `obj`.
    #
    # Let's finish type-checking the `obj.field` part just like how
    # `typecheck_expression()` function would do it and continue as usual.
    if obj_type.kind == TypeKind.Class:
        call.function.kind = AstExpressionKind.GetClassField
    else:
        assert obj_type.kind == TypeKind.Pointer
        assert obj_type.value_type.kind == TypeKind.Class
        call.function.kind = AstExpressionKind.GetClassFieldPtr

    t = typecheck_class_field(state, self_class, member_name, func_location).type
    call.function.types.orig_type = t
    call.function.types.implicit_cast_type = t
    return t


# returns NULL if the function doesn't return anything
def typecheck_call(state: State*, call: AstCall*, location: Location) -> Type*:
    msg: byte[500]

    assert call.signature_if_known == NULL

    if call.function.kind == AstExpressionKind.DotOperator:
        funcptr_type = typecheck_member_that_looks_like_method(state, call)
    else:
        # Special-casing for better error message "function 'foo' not found".
        # Without this we would get "no variable named 'foo'".
        if (
            call.function.kind == AstExpressionKind.GetVariable
            and find_and_typecheck_function(state.jou_file, call.function.varname) == NULL
            and state.find_any_var(call.function.varname) == NULL
        ):
            snprintf(msg, sizeof(msg), "function '%s' not found", call.function.varname)
            match call.function.varname with strcmp:
                case "print":
                    strcat(msg, ", try 'printf' from \"stdlib/io.jou\"")
                case "input":
                    strcat(msg, ", try 'fgets' from \"stdlib/io.jou\"")
            fail(call.function.location, msg)

        funcptr_type = typecheck_expression_not_void(state, call.function, NULL)
        if call.function.kind == AstExpressionKind.GetFuncPtr:
            # It is a basic function call like printf("hi\n").
            # Let's get the signature of the function so we can use it for error messages.
            assert call.function.get_func_ptr.signature != NULL
            call.signature_if_known = malloc(sizeof(*call.signature_if_known))
            assert call.signature_if_known != NULL
            *call.signature_if_known = call.function.get_func_ptr.signature.copy()

    assert (
        funcptr_type != NULL and call.function != NULL and call.method_call_self == NULL
    ) or (
        funcptr_type == NULL and call.function == NULL and call.method_call_self != NULL
    )

    # If self argument of method must be passed by pointer, make sure we can create that pointer
    if call.method_call_self != NULL:
        assert call.method_call_self.types.implicit_cast_type != NULL
        assert call.signature_if_known != NULL
        method_name = call.signature_if_known.name
        if (
            call.signature_if_known.args.ptr[0].type.kind == TypeKind.Pointer
            and call.method_call_self.types.implicit_cast_type.kind != TypeKind.Pointer
        ):
            assert strstr(method_name, "%") == NULL
            snprintf(
                msg, sizeof msg,
                "cannot take address of %%s, needed for calling the %s() method",
                method_name,
            )
            ensure_can_take_address(state.fom, call.method_call_self, msg)

    if funcptr_type != NULL and funcptr_type.kind != TypeKind.FuncPtr:
        snprintf(msg, sizeof(msg), "expected a function, got %s", funcptr_type.name)
        fail(call.function.location, msg)

    what_we_calling: byte[500]
    if call.signature_if_known != NULL:
        sig_string = call.signature_if_known.to_string(False, False)
        snprintf(what_we_calling, sizeof(what_we_calling), "%s %s", call.function_or_method(), sig_string)
        free(sig_string)
        nparams = call.signature_if_known.args.len
        takes_varargs = call.signature_if_known.takes_varargs
        return_type = call.signature_if_known.return_type
        is_noreturn = call.signature_if_known.is_noreturn
    else:
        # It is a function pointer call, use `funcptr(int, int)` or similar as name.
        assert funcptr_type != NULL
        argstr = funcptr_type.func_ptr.arguments_string()
        snprintf(what_we_calling, sizeof(what_we_calling), "funcptr(%s)", argstr)
        free(argstr)
        nparams = funcptr_type.func_ptr.argtypes.len
        takes_varargs = funcptr_type.func_ptr.takes_varargs
        return_type = funcptr_type.func_ptr.return_type
        is_noreturn = funcptr_type.func_ptr.is_noreturn

    if call.method_call_self != NULL:
        nparams--  # skip self

    if call.args.len < nparams or (call.args.len > nparams and not takes_varargs):
        snprintf(
            msg, sizeof(msg),
            "%s takes %zd argument%s, but it was called with %zd argument%s",
            what_we_calling,
            nparams,
            plural_s(nparams),
            call.args.len,
            plural_s(call.args.len),
        )
        fail(location, msg)

    for i = 0; i < call.args.len; i++:
        if i >= nparams:
            assert takes_varargs
            typecheck_vararg(state, &call.args.ptr[i], what_we_calling)
            continue

        if funcptr_type != NULL:
            param_type = funcptr_type.func_ptr.argtypes.ptr[i]
        else:
            assert call.signature_if_known != NULL
            if call.method_call_self != NULL:
                param_type = call.signature_if_known.args.ptr[i+1].type  # skip self
            else:
                param_type = call.signature_if_known.args.ptr[i].type

        # This is a common error, so worth spending some effort to get a good error message.
        which_arg = nth(i+1)
        snprintf(
            msg, sizeof msg,
            "%s argument of %s should have type <to>, not <from>", which_arg, what_we_calling
        )
        typecheck_expression_with_implicit_cast(state, &call.args.ptr[i], param_type, msg)

    return return_type


def typecheck_class_field(
    state: State*,
    classtype: Type*,
    fieldname: byte*,
    location: Location,
) -> ClassField*:
    assert classtype.kind == TypeKind.Class
    f = classtype.find_class_field(fieldname)
    if f != NULL:
        return f

    msg: byte[500]

    # TODO: When trying to treat an unavailable private method as a field, this
    #       error message should say "is a method", not "has no field". One way
    #       to fix this could be to pass in the Jou file where the class has
    #       been defined.
    if find_and_typecheck_method(state.jou_file, classtype, fieldname) == NULL:
        snprintf(msg, sizeof(msg), "class %s has no field named '%s'", classtype.name, fieldname)
    else:
        snprintf(msg, sizeof(msg), "%s.%s() is a method, it can be called but it cannot be used in any other way", classtype.name, fieldname)

    fail(location, msg)


def typecheck_instantiation(state: State*, inst: AstInstantiation*, location: Location) -> Type*:
    t = type_from_ast(state.jou_file, state.fom.symbol.signature.get_self_class(), &inst.type)

    msg: byte[500]

    if t.kind != TypeKind.Class:
        snprintf(
            msg, sizeof(msg),
            "the %s{...} syntax is only for classes, but %s is %s",
            t.name, t.name, t.short_description())
        fail(location, msg)

    specified_fields = List[ClassField*]{}
    for f = inst.fields.ptr; f < inst.fields.end(); f++:
        field = typecheck_class_field(state, t, f.name, f.value.location)

        snprintf(msg, sizeof msg,
            "value for field '%s' of class %s must be of type <to>, not <from>",
            f.name, t.name)
        typecheck_expression_with_implicit_cast(state, &f.value, field.type, msg)
        specified_fields.append(field)

    for i1 = 0; i1 < inst.fields.len; i1++:
        for i2 = i1+1; i2 < inst.fields.len; i2++:
            if specified_fields.ptr[i1].union_id == specified_fields.ptr[i2].union_id:
                snprintf(msg, sizeof(msg),
                    "fields '%s' and '%s' cannot be set simultaneously because they belong to the same union",
                    specified_fields.ptr[i1].name, specified_fields.ptr[i2].name)
                fail(inst.fields.ptr[i2].value.location,msg)

    free(specified_fields.ptr)
    return t


def cast_array_members_to_a_common_type(
    fom: AstFunctionOrMethod*,
    error_location: Location,
    array: List[AstExpression],
    item_type_hint: Type*,
) -> Type*:
    if item_type_hint != NULL:
        for p = array.ptr; p < array.end(); p++:
            do_implicit_cast(fom, p, item_type_hint, error_location, "array items should be of type <to>, not <from>")
        return item_type_hint

    # Avoid O(ntypes^2) code in a long array where all or almost all items have the same type.
    # This is at most O(ntypes*k) where k is the number of distinct types.
    distinct = List[Type*]{}

    for p = array.ptr; p < array.end(); p++:
        itemtype = p.types.orig_type
        assert itemtype != NULL

        found = False
        for t = distinct.ptr; t < distinct.end(); t++:
            if itemtype == *t:
                found = True
                break
        if not found:
            distinct.append(itemtype)

    compatible_with_all = List[Type*]{}

    for t = distinct.ptr; t < distinct.end(); t++:
        t_compatible_with_all_others = True
        for t2 = distinct.ptr; t2 < distinct.end(); t2++:
            if not can_cast_implicitly(*t2, *t):
                t_compatible_with_all_others = False
                break

        if t_compatible_with_all_others:
            compatible_with_all.append(*t)

    if compatible_with_all.len > 1:
        # Remove void* if exists, so that type of ["hello", NULL] becomes byte*[2]
        for i = 0; i < compatible_with_all.len; i++:
            if compatible_with_all.ptr[i] == void_ptr_type():
                compatible_with_all.ptr[i] = compatible_with_all.pop()
                break

    if compatible_with_all.len != 1:
        size: intnative = 500
        for t = distinct.ptr; t < distinct.end(); t++:
            size += 3  # 1 for comma, 1 for space, 1 because why not lol
            size += strlen((*t).name)

        msg: byte* = malloc(size)
        assert msg != NULL

        strcpy(msg, "array items have different types (")
        for t = distinct.ptr; t < distinct.end(); t++:
            if t != distinct.ptr:
                strcat(msg, ", ")
            strcat(msg, (*t).name)
        strcat(msg, ")")
        fail(error_location, msg)

    elemtype = compatible_with_all.ptr[0]
    free(distinct.ptr)
    free(compatible_with_all.ptr)

    for p = array.ptr; p < array.end(); p++:
        do_implicit_cast(fom, p, elemtype, error_location, NULL)
    return elemtype


# This function handles cases like the following:
#
#   1.0 if condition else 2
#   1 if condition else 2.0
def cast_ternary_values_to_a_common_type(
    fom: AstFunctionOrMethod*,
    ternary_location: Location,
    then_expr: AstExpression*,
    otherwise_expr: AstExpression*,
    ternary_type_hint: Type*,
) -> Type*:
    t1 = then_expr.types.orig_type
    t2 = otherwise_expr.types.orig_type
    assert t1 != NULL
    assert t2 != NULL

    if ternary_type_hint != NULL:
        t = ternary_type_hint
    elif t1 == t2:
        t = t1
    else:
        t1_works = can_cast_implicitly(t2, t1)
        t2_works = can_cast_implicitly(t1, t2)
        if t1_works and t2_works:
            # Handle similarly to array members
            if t1 == void_ptr_type():
                t = t2
            elif t2 == void_ptr_type():
                t = t1
            else:
                t = NULL  # TODO: can this ever happen?
        elif t1_works:
            t = t1
        elif t2_works:
            t = t2
        else:
            t = NULL

    if t == NULL:
        msg: byte[500]
        snprintf(msg, sizeof(msg), "ternary values must be of the same type (got %s and %s)", t1.name, t2.name)
        fail(ternary_location, msg)

    do_implicit_cast(fom, then_expr, t, then_expr.location, "ternary values should be of type <to>, not <from>")
    do_implicit_cast(fom, otherwise_expr, t, otherwise_expr.location, "ternary values should be of type <to>, not <from>")
    return t


# The AST "foo.bar" may be:
#   - field "bar" of an instance of some class stored to variable "foo"
#   - field "bar" of an instance where pointer "foo" points
#   - member "bar" of enum "foo"
#
# This function recognizes enum members and modifies the AST accordingly.
# It does not distinguish between fields that use a pointer vs access
# directly. This cannot be done in the parser because it doesn't know what
# enums exist (they may be e.g. imported from other files).
#
# Feels like a hack, but works great :)
def detect_enum_member_syntax(state: State*, expr: AstExpression*) -> None:
    if expr.kind != AstExpressionKind.DotOperator:
        # not foo.bar
        return

    if expr.class_field.instance.kind != AstExpressionKind.GetVariable:
        # the "foo" part is something more complicated than a variable name
        return

    enum_name: byte[100] = expr.class_field.instance.varname
    member_name: byte[100] = expr.class_field.field_name

    if state.find_any_var(enum_name) != NULL:
        # there is a variable named "foo", use that
        return

    t = find_and_typecheck_type(state.jou_file, expr.class_field.instance.varname)
    if t == NULL:
        # no enum or variable, show variable not found error
        return

    if t.kind != TypeKind.Enum:
        # attempting to do Foo.bar, where Foo is a type but not enum type
        if t.kind == TypeKind.Class:
            fail(expr.location, "class members cannot be accessed directly on the class, they only exist on instances")
        else:
            # TODO: Currently this cannot happen. Built-in types like "int" are
            # keywords so that they cannot appear as expressions. A test should
            # be added if this becomes possible in the future.
            msg: byte[500]
            snprintf(
                msg, sizeof(msg),
                "type '%s' has no members because it is not a class or an enum",
                enum_name,
            )
            fail(expr.location, msg)

    free(expr.class_field.instance)
    expr.kind = AstExpressionKind.GetEnumMember
    expr.enum_member = AstEnumMember{
        enum_name = enum_name,
        member_name = member_name,
    }


def typecheck_expression(state: State*, expr: AstExpression*, type_hint: Type*) -> None:
    msg: byte[500]
    result: Type* = NULL

    detect_enum_member_syntax(state, expr)

    match expr.kind:
        case AstExpressionKind.IntegerConstant | AstExpressionKind.EnumCount | AstExpressionKind.EmbedFile:
            # The expression can be evaluated as a constant
            c: Constant
            ok = evaluate_constant_expression(state.jou_file, expr, &c, type_hint)
            assert ok  # Should fail with a compiler error if there is a problem
            result = c.get_type()
            expr.free()
            expr.kind = AstExpressionKind.Constant
            expr.constant = c

        case AstExpressionKind.Constant:
            # Use array string if type hint given, e.g. foo: byte[100] = "hello"
            if (
                expr.constant.kind == ConstantKind.PointerString
                and type_hint != NULL
                and type_hint.kind == TypeKind.Array
                and type_hint.array.item_type == uint_type(8)
            ):
                s = expr.constant.pointer_string
                if strlen(s) >= type_hint.array.count:
                    snprintf(msg, sizeof(msg), "a string of %zd bytes (including '\\0') does not fit into %s", strlen(s) + 1, type_hint.name)
                    fail(expr.location, msg)
                expr.constant.kind = ConstantKind.ArrayOfBytes
                expr.constant.array_of_bytes = List[byte]{}
                while expr.constant.array_of_bytes.len < type_hint.array.count:
                    expr.constant.array_of_bytes.append('\0')
                strcpy(expr.constant.array_of_bytes.ptr, s)
                free(s)
                assert expr.constant.get_type() == type_hint
                result = type_hint
            else:
                result = expr.constant.get_type()

        case AstExpressionKind.GetEnumMember:
            result = find_and_typecheck_type(state.jou_file, expr.enum_member.enum_name)
            # AstExpressionKind.GetEnumMember is only created if the enum exists
            assert result != NULL
            assert result.kind == TypeKind.Enum
            if result.find_enum_member(expr.enum_member.member_name) == -1:
                snprintf(
                    msg, sizeof(msg),
                    "enum %s has no member named '%s'",
                    expr.enum_member.enum_name, expr.enum_member.member_name)
                fail(expr.location, msg)

        case AstExpressionKind.SizeOf:
            if (
                expr.operands[0].kind == AstExpressionKind.Constant
                and expr.operands[0].constant.kind == ConstantKind.PointerString
            ):
                # sizeof("foo") should be 4
                obj_type_hint = uint_type(8).array_type((strlen(expr.operands[0].constant.pointer_string) as int) + 1)
            else:
                obj_type_hint = NULL
            typecheck_expression_not_void(state, &expr.operands[0], obj_type_hint)
            result = int_type(32)

        case AstExpressionKind.ArrayCount:
            array_type = typecheck_expression_not_void(state, &expr.operands[0], NULL)
            if array_type.kind != TypeKind.Array:
                snprintf(msg, sizeof(msg), "array_count must be called on an array, not %s", array_type.name)
                fail(expr.location, msg)
            result = int_type(32)

        case AstExpressionKind.Instantiate:
            result = typecheck_instantiation(state, &expr.instantiation, expr.location)

        case AstExpressionKind.Array:
            if type_hint != NULL and type_hint.kind == TypeKind.Array:
                item_type_hint = type_hint.array.item_type
            else:
                item_type_hint = NULL
            for item = expr.array.ptr; item < expr.array.end(); item++:
                typecheck_expression_not_void(state, item, item_type_hint)
            membertype = cast_array_members_to_a_common_type(state.fom, expr.location, expr.array, item_type_hint)
            result = membertype.array_type(expr.array.len as int)

        case AstExpressionKind.DotOperator:
            # Not enum, that is handled already.
            # It is either instance.field or pointer_to_instance.field.
            temptype = typecheck_expression_not_void(state, expr.class_field.instance, NULL)
            if temptype.kind == TypeKind.Class:
                expr.kind = AstExpressionKind.GetClassField
                result = typecheck_class_field(state, temptype, expr.class_field.field_name, expr.location).type
            elif temptype.kind == TypeKind.Pointer and temptype.value_type.kind == TypeKind.Class:
                expr.kind = AstExpressionKind.GetClassFieldPtr
                result = typecheck_class_field(state, temptype.value_type, expr.class_field.field_name, expr.location).type
            else:
                snprintf(
                    msg, sizeof(msg),
                    "left side of '.' operator must be an instance of a class or a pointer to an instance, not %s",
                    temptype.name)
                fail(expr.location, msg)

        case AstExpressionKind.GetClassField | AstExpressionKind.GetClassFieldPtr | AstExpressionKind.GetFuncPtr:
            # Constructed here, should not already be like this when we get here
            assert False

        case AstExpressionKind.Call:
            result = typecheck_call(state, &expr.call, expr.location)
            if result == NULL:
                # no return value produced
                return

        case AstExpressionKind.Indexing:
            result = typecheck_indexing(state, &expr.operands[0], &expr.operands[1])

        case AstExpressionKind.AddressOf:
            result = typecheck_expression_not_void(state, &expr.operands[0], NULL).pointer_type()
            ensure_can_take_address(state.fom, &expr.operands[0], "the '&' operator cannot be applied to %s")

        case AstExpressionKind.GetVariable:
            c_ptr = find_and_typecheck_constant(state.jou_file, expr.varname)
            if c_ptr != NULL:
                # Transform the expression into a constant
                expr.kind = AstExpressionKind.Constant
                expr.constant = c_ptr.copy()
                result = c_ptr.get_type()
            else:
                # Not a constant, proceed with normal variable lookup
                result = state.find_any_var(expr.varname)
                if result == NULL:
                    # Is it a function?
                    sig = find_and_typecheck_function(state.jou_file, expr.varname)
                    if sig == NULL:
                        snprintf(msg, sizeof(msg), "no variable named '%s'", expr.varname)
                        match expr.varname with strcmp:
                            case "stdin":
                                strcat(msg, ", try 'get_stdin()' from \"stdlib/io.jou\"")
                            case "stdout":
                                strcat(msg, ", try 'get_stdout()' from \"stdlib/io.jou\"")
                            case "stderr":
                                strcat(msg, ", try 'get_stderr()' from \"stdlib/io.jou\"")
                        fail(expr.location, msg)
                    name = expr.varname
                    expr.kind = AstExpressionKind.GetFuncPtr
                    expr.get_func_ptr.func_name = name
                    expr.get_func_ptr.signature = sig
                    result = sig.to_funcptr_type()

        case AstExpressionKind.Self:
            assert state.fom.locals.len >= 1
            selfvar = &state.fom.locals.ptr[0]
            assert strcmp(selfvar.name, "self") == 0
            result = selfvar.type

        case AstExpressionKind.Dereference:
            temptype = typecheck_expression_not_void(state, &expr.operands[0], NULL)
            typecheck_dereferenced_pointer(expr.location, temptype)
            result = temptype.value_type

        case AstExpressionKind.And:
            typecheck_and_or(state, &expr.operands[0], &expr.operands[1], "and")
            result = bool_type()

        case AstExpressionKind.Or:
            typecheck_and_or(state, &expr.operands[0], &expr.operands[1], "or")
            result = bool_type()

        case AstExpressionKind.Not:
            typecheck_expression_with_implicit_cast(
                state, &expr.operands[0], bool_type(),
                "value after 'not' must be a bool, not <from>")
            result = bool_type()

        case AstExpressionKind.Negate:
            result = typecheck_expression_not_void(state, &expr.operands[0], NULL)
            if result.kind != TypeKind.SignedInteger and result.kind != TypeKind.FloatingPoint:
                snprintf(msg, sizeof(msg),
                    "value after '-' must be a float or double or a signed integer, not %s",
                    result.name)
                fail(expr.location, msg)

        case AstExpressionKind.BitNot:
            result = typecheck_expression_not_void(state, &expr.operands[0], type_hint)
            if not result.is_integer_type():
                snprintf(msg, sizeof(msg), "cannot take bitwise NOT of %s", result.name)
                fail(expr.location, msg)

        case (
            AstExpressionKind.Add
            | AstExpressionKind.Sub
            | AstExpressionKind.Mul
            | AstExpressionKind.Div
            | AstExpressionKind.Mod
            | AstExpressionKind.BitAnd
            | AstExpressionKind.BitOr
            | AstExpressionKind.BitXor
            | AstExpressionKind.Eq
            | AstExpressionKind.Ne
            | AstExpressionKind.Gt
            | AstExpressionKind.Ge
            | AstExpressionKind.Lt
            | AstExpressionKind.Le
            | AstExpressionKind.BitShiftLeft
            | AstExpressionKind.BitShiftRight
        ):
            if (
                expr.kind == AstExpressionKind.BitShiftLeft
                or expr.kind == AstExpressionKind.BitShiftRight
            ):
                # Result of "a >> b" is same type as a. Pass type hint along.
                typecheck_expression_not_void(state, &expr.operands[0], type_hint)
            else:
                typecheck_expression_not_void(state, &expr.operands[0], NULL)
            typecheck_expression_not_void(state, &expr.operands[1], NULL)
            result = check_binop(state.fom, expr.kind, expr.location, &expr.operands[0], &expr.operands[1])

        case AstExpressionKind.TernaryIf:
            typecheck_expression_not_void(state, &expr.operands[0], NULL)
            typecheck_expression_with_implicit_cast(
                state, &expr.operands[1], bool_type(), "ternary condition must be a bool, not <from>"
            )
            typecheck_expression_not_void(state, &expr.operands[2], NULL)
            result = cast_ternary_values_to_a_common_type(
                state.fom, expr.location, &expr.operands[0], &expr.operands[2], type_hint
            )

        case (
            AstExpressionKind.PreIncr
            | AstExpressionKind.PreDecr
            | AstExpressionKind.PostIncr
            | AstExpressionKind.PostDecr
        ):
            result = check_increment_or_decrement(state, expr)

        case AstExpressionKind.As:
            result = type_from_ast(state.jou_file, state.fom.symbol.signature.get_self_class(), &expr.as_.type)

            # The `foo as SomeType` operation usually doesn't specify how the
            # type of `foo` should be inferred. The intent is that `foo` can be
            # of any type it wants to be, and we convert it afterwards.
            #
            # However, the `as` operation is documented as being also able to do
            # everything that type inference can do. This means that in a couple
            # cases, we actually use type inference and the rest of "as" does
            # nothing.

            # Special case 1: `"foo" as byte[100]`
            special_case_1 = (
                expr.as_.value.kind == AstExpressionKind.Constant
                and expr.as_.value.constant.kind == ConstantKind.PointerString
                and result.kind == TypeKind.Array
                and result.array.item_type == uint_type(8)
            )

            # Special case 2: `123123123123123 as int64`. The value doesn't fit
            # inside `int`, but the compiler would use `int` if no type hint was
            # given for inference.
            #
            # TODO: make this work for negative values?
            # TODO: may be possible to show warning about unnecessary cast, check type hint of the whole `as`
            special_case_2 = (
                expr.as_.value.kind == AstExpressionKind.IntegerConstant
                and (expr.as_.value.integer_value as int) != expr.as_.value.integer_value
                and result.is_integer_type()
            )

            if special_case_1 or special_case_2:
                typecheck_expression_not_void(state, &expr.as_.value, result)
            else:
                typecheck_expression_not_void(state, &expr.as_.value, NULL)
                do_explicit_cast(state.fom, &expr.as_.value, result, expr.location)

    assert result != NULL
    expr.types.orig_type = result
    expr.types.implicit_cast_type = result  # by default, no implicit cast


def typecheck_body(state: State*, body: List[AstStatement]) -> None:
    for p = body.ptr; p < body.end(); p++:
        typecheck_statement(state, p)


def typecheck_if_statement(state: State*, ifstmt: AstIfStatement*) -> None:
    for p = ifstmt.if_and_elifs.ptr; p < ifstmt.if_and_elifs.end(); p++:
        if p == ifstmt.if_and_elifs.ptr:
            errmsg = "'if' condition must be a bool, not <from>"
        else:
            errmsg = "'elif' condition must be a bool, not <from>"

        typecheck_expression_with_implicit_cast(state, &p.condition, bool_type(), errmsg)
        typecheck_body(state, p.body)

    typecheck_body(state, ifstmt.else_body)


def typecheck_match_statement(state: State*, match_stmt: AstMatchStatement*) -> None:
    msg: byte[500]
    sig_string: byte* = NULL
    remaining: byte** = NULL
    nremaining: intnative = -1

    if match_stmt.func_name[0] == '\0':
        case_type = typecheck_expression_not_void(state, &match_stmt.match_obj, NULL)

        match case_type.kind:
            case TypeKind.SignedInteger | TypeKind.UnsignedInteger:
                # no special handling needed
                pass
            case TypeKind.Enum:
                # Ensure user checks all possible enum values
                nremaining = case_type.enum_members.len
                remaining = malloc(sizeof(remaining[0]) * nremaining)
                assert remaining != NULL
                for i = 0; i < nremaining; i++:
                    remaining[i] = case_type.enum_members.ptr[i]
            case _:
                snprintf(msg, sizeof(msg), "cannot match a value of type %s", case_type.name)
                if strlen(msg) + 100 < sizeof(msg):
                    if case_type == uint_type(8).pointer_type():
                        strcat(msg, " (try adding 'with strcmp')")
                    if case_type == bool_type():
                        strcat(msg, " (use if/else instead)")
                fail(match_stmt.match_obj.location, msg)
    else:
        sig = find_and_typecheck_function(state.jou_file, match_stmt.func_name)
        if sig == NULL:
            snprintf(msg, sizeof(msg), "function '%s' not found", match_stmt.func_name)
            fail(match_stmt.match_obj.location, msg)
        match_stmt.func_signature = sig.copy()

        # Most of the time, only argument types are relevant, so don't include the return type into sig_string.
        sig_string = sig.to_string(False, False)

        if sig.args.len != 2 or sig.return_type != int_type(32) or sig.takes_varargs:  # TODO: could be more general
            if sig.return_type != int_type(32):
                # show return type in error message
                sig_string = sig.to_string(True, False)
            snprintf(msg, sizeof(msg), "cannot match with function %s", sig_string)
            fail(match_stmt.match_obj.location, msg)

        snprintf(msg, sizeof(msg), "cannot match <from> with %s", sig_string)
        typecheck_expression_with_implicit_cast(state, &match_stmt.match_obj, sig.args.ptr[0].type, msg)
        case_type = sig.args.ptr[1].type

    for c = match_stmt.cases.ptr; c < match_stmt.cases.end(); c++:
        for case_obj = c.case_objs.ptr; case_obj < c.case_objs.end(); case_obj++:
            if sig_string == NULL:
                msg = "case value of type <from> cannot be matched against <to>"
            else:
                snprintf(msg, sizeof(msg), "case value cannot be <from> when matching with %s", sig_string)
            typecheck_expression_with_implicit_cast(state, case_obj, case_type, msg)

            if nremaining != -1:
                if case_obj.kind != AstExpressionKind.GetEnumMember:
                    # Matching an enum but it's too dynamic, not simply TheEnum.Member
                    snprintf(msg, sizeof(msg), "'case' value must be %s.something when matching a value of enum %s", case_type.name, case_type.name)
                    fail(case_obj.location, msg)
                # We are matching against TheEnum.member. Try to find and remove it from remaining members.
                member = case_obj.enum_member.member_name
                found = False
                for k = 0; k < nremaining; k++:
                    if strcmp(remaining[k], member) == 0:
                        memmove(&remaining[k], &remaining[k+1], sizeof(remaining[0]) * (--nremaining - k))
                        found = True
                        break

                if not found:
                    snprintf(msg, sizeof(msg), "enum member %s is handled twice", member)
                    fail(case_obj.location, msg)

        typecheck_body(state, c.body)

    # Do not complain if there is a seemingly unnecessary 'case _', because it
    # may be ran by casting an integer to enum with 'as'. However, we can
    # complain if handling for enum members is missing.
    if nremaining > 0 and match_stmt.case_underscore == NULL:
        if nremaining == 1:
            snprintf(
                msg, sizeof(msg),
                "enum member %s.%s not handled in match statement",
                case_type.name, remaining[0],
            )
        else:
            snprintf(
                msg, sizeof(msg) - 20,
                "the following %d members of enum %s are not handled in match statement: ",
                nremaining, case_type.name,
            )
            for i = 0; i < nremaining; i++:
                assert sizeof(msg) > 300
                if strlen(msg) + strlen(remaining[i]) < 200:
                    strcat(msg, remaining[i])
                    strcat(msg, ", ")
                else:
                    strcat(msg, "...")
                    break
            if ends_with(msg, ", "):
                msg[strlen(msg) - 2] = '\0'

        fail(match_stmt.match_obj.location, msg)

    free(sig_string)
    free(remaining)

    if match_stmt.case_underscore != NULL:
        typecheck_body(state, *match_stmt.case_underscore)


def typecheck_statement(state: State*, stmt: AstStatement*) -> None:
    msg: byte[500]

    match stmt.kind:
        case AstStatementKind.If:
            typecheck_if_statement(state, &stmt.if_statement)

        case AstStatementKind.WhileLoop:
            typecheck_expression_with_implicit_cast(
                state, &stmt.while_loop.condition, bool_type(),
                "'while' condition must be a bool, not <from>")
            typecheck_body(state, stmt.while_loop.body)

        case AstStatementKind.ForLoop:
            if stmt.for_loop.init != NULL:
                typecheck_statement(state, stmt.for_loop.init)
            if stmt.for_loop.cond != NULL:
                typecheck_expression_with_implicit_cast(
                    state, stmt.for_loop.cond, bool_type(),
                    "'for' condition must be a bool, not <from>")
            typecheck_body(state, stmt.for_loop.body)
            if stmt.for_loop.incr != NULL:
                typecheck_statement(state, stmt.for_loop.incr)

        case AstStatementKind.Match:
            typecheck_match_statement(state, &stmt.match_statement)

        case AstStatementKind.Break | AstStatementKind.Continue | AstStatementKind.Pass:
            pass

        case AstStatementKind.Assign:
            targetexpr = &stmt.assignment.target
            valueexpr = &stmt.assignment.value

            if (
                targetexpr.kind == AstExpressionKind.GetVariable
                and state.find_any_var_or_constant(targetexpr.varname) == NULL
            ):
                # Making a new variable. Use the type of the value being assigned.
                type = typecheck_expression_not_void(state, valueexpr, NULL)
                state.fom.locals.append(LocalVariable{type = type, name = targetexpr.varname})
            else:
                # Convert value to the type of an existing variable or other assignment target.
                targettype = typecheck_expression_not_void(state, targetexpr, NULL)
                ensure_can_take_address(state.fom, targetexpr, "cannot assign to %s")

                if targetexpr.kind == AstExpressionKind.Dereference:
                    msg = "cannot place a value of type <from> into a pointer of type <to>*"
                else:
                    desc = short_expression_description(targetexpr)
                    snprintf(msg, sizeof msg, "cannot assign a value of type <from> to %s of type <to>", desc)
                typecheck_expression_with_implicit_cast(state, valueexpr, targettype, msg)

        case (
            AstStatementKind.InPlaceAdd
            | AstStatementKind.InPlaceSub
            | AstStatementKind.InPlaceMul
            | AstStatementKind.InPlaceDiv
            | AstStatementKind.InPlaceMod
            | AstStatementKind.InPlaceBitAnd
            | AstStatementKind.InPlaceBitOr
            | AstStatementKind.InPlaceBitXor
            | AstStatementKind.InPlaceBitShiftLeft
            | AstStatementKind.InPlaceBitShiftRight
        ):
            targetexpr = &stmt.assignment.target
            valueexpr = &stmt.assignment.value

            targettype = typecheck_expression_not_void(state, targetexpr, NULL)
            if (
                stmt.kind == AstStatementKind.InPlaceBitShiftLeft
                or stmt.kind == AstStatementKind.InPlaceBitShiftRight
            ):
                # The type of "y" in "x >>= y" has nothing to do with the type of x.
                value_type = typecheck_expression_not_void(state, valueexpr, NULL)
            else:
                value_type = typecheck_expression_not_void(state, valueexpr, targettype)
            ensure_can_take_address(state.fom, targetexpr, "cannot assign to %s")

            match stmt.kind:
                case AstStatementKind.InPlaceAdd:
                    op = AstExpressionKind.Add
                    opname = "addition"
                case AstStatementKind.InPlaceSub:
                    op = AstExpressionKind.Sub
                    opname = "subtraction"
                case AstStatementKind.InPlaceMul:
                    op = AstExpressionKind.Mul
                    opname = "multiplication"
                case AstStatementKind.InPlaceDiv:
                    op = AstExpressionKind.Div
                    opname = "division"
                case AstStatementKind.InPlaceMod:
                    op = AstExpressionKind.Mod
                    opname = "modulo"
                case AstStatementKind.InPlaceBitAnd:
                    op = AstExpressionKind.BitAnd
                    opname = "bitwise AND"
                case AstStatementKind.InPlaceBitOr:
                    op = AstExpressionKind.BitOr
                    opname = "bitwise OR"
                case AstStatementKind.InPlaceBitXor:
                    op = AstExpressionKind.BitXor
                    opname = "xor"
                case AstStatementKind.InPlaceBitShiftLeft:
                    op = AstExpressionKind.BitShiftLeft
                    opname = "bitwise shift"  # currently never used, I think...
                case AstStatementKind.InPlaceBitShiftRight:
                    op = AstExpressionKind.BitShiftRight
                    opname = "bitwise shift"  # currently never used, I think...
                case _:
                    assert False

            t = check_binop(state.fom, op, stmt.location, targetexpr, valueexpr)
            if t != targetexpr.types.orig_type:
                snprintf(
                    msg, sizeof msg,
                    "%s produced a value of type %s which cannot be assigned back to %s",
                    opname, t.name, targetexpr.types.orig_type.name
                )
                fail(stmt.location, msg)

        case AstStatementKind.Return:
            function_or_method = state.fom.symbol.signature.function_or_method()

            if state.fom.symbol.signature.is_noreturn:
                snprintf(
                    msg, sizeof(msg),
                    "%s '%s' cannot return because it was defined with '-> noreturn'",
                    function_or_method, state.fom.symbol.signature.name,
                )
                fail(stmt.location, msg)

            return_type = state.fom.symbol.signature.return_type

            if stmt.return_value != NULL and return_type == NULL:
                snprintf(
                    msg, sizeof(msg), "%s '%s' cannot return a value because it was defined with '-> None'",
                    function_or_method, state.fom.symbol.signature.name,
                )
                fail(stmt.location, msg)

            if return_type != NULL and stmt.return_value == NULL:
                snprintf(msg, sizeof(msg),
                    "a return value is needed, because the return type of %s '%s' is %s",
                    function_or_method,
                    state.fom.symbol.signature.name,
                    state.fom.symbol.signature.return_type.name)
                fail(stmt.location, msg)

            if stmt.return_value != NULL:
                snprintf(msg, sizeof msg,
                    "attempting to return a value of type <from> from %s '%s' defined with '-> <to>'",
                    function_or_method, state.fom.symbol.signature.name)
                typecheck_expression_with_implicit_cast(state, stmt.return_value, return_type, msg)

        case AstStatementKind.DeclareLocalVar:
            varname = stmt.local_var_declare.name

            if state.find_any_var(varname) != NULL:
                snprintf(msg, sizeof(msg), "a variable named '%s' already exists", varname)
                fail(stmt.location, msg)

            if find_and_typecheck_constant(state.jou_file, varname) != NULL:
                snprintf(msg, sizeof(msg), "a constant named '%s' already exists", varname)
                fail(stmt.location, msg)

            type = type_from_ast(state.jou_file, state.fom.symbol.signature.get_self_class(), &stmt.local_var_declare.type)
            state.fom.locals.append(LocalVariable{type=type, name=varname})

            if stmt.local_var_declare.value != NULL:
                typecheck_expression_with_implicit_cast(
                    state, stmt.local_var_declare.value, type,
                    "initial value for variable of type <to> cannot be of type <from>")

        case AstStatementKind.ExpressionStatement:
            typecheck_expression(state, &stmt.expression, NULL)

        case AstStatementKind.Assert:
            if find_and_typecheck_function(state.jou_file, "_jou_assert_fail") == NULL:
                fail(stmt.location, "you must import \"stdlib/assert.jou\" to use the assert keyword")
            typecheck_expression_with_implicit_cast(
                state, &stmt.assertion.condition, bool_type(),
                "assertion must be a bool, not <from>",
            )

        case (
            AstStatementKind.FunctionDeclare
            | AstStatementKind.FunctionDef
            | AstStatementKind.MethodDef
            | AstStatementKind.Class
            | AstStatementKind.ClassField
            | AstStatementKind.ClassUnion
            | AstStatementKind.Enum
            | AstStatementKind.GlobalVariableDeclare
            | AstStatementKind.GlobalVariableDef
            | AstStatementKind.Import
            | AstStatementKind.Link
            | AstStatementKind.Const
            | AstStatementKind.TypeDef
        ):
            # These should not appear inside a function or method
            assert False


def typecheck_function_or_method_body(state: State*, fom: AstFunctionOrMethod*) -> None:
    assert state.fom == NULL
    state.fom = fom

    sig = &fom.symbol.signature
    for arg = sig.args.ptr; arg < sig.args.end(); arg++:
        state.fom.locals.append(LocalVariable{name=arg.name, type=arg.type})

    typecheck_body(state, fom.body)
    state.fom = NULL


@public
def typecheck_step3_function_and_method_bodies() -> None:
    if global_compiler_state.args.verbosity >= 1:
        printf("Typecheck: function and method bodies (step 3/3)\n")

    for jou_file = global_compiler_state.jou_files.ptr; jou_file < global_compiler_state.jou_files.end(); jou_file++:
        if global_compiler_state.args.verbosity >= 1:
            printf("  %s\n", jou_file.path)

        state = State{jou_file = jou_file}
        for stmt = jou_file.ast.ptr; stmt < jou_file.ast.end(); stmt++:
            match stmt.kind:
                case AstStatementKind.FunctionDef:
                    if global_compiler_state.args.verbosity >= 2:
                        printf("    %s()\n", stmt.symbol().name)
                    typecheck_function_or_method_body(&state, &stmt.function)
                case AstStatementKind.Class:
                    for inner = stmt.classdef.body.ptr; inner < stmt.classdef.body.end(); inner++:
                        if inner.kind == AstStatementKind.MethodDef:
                            if global_compiler_state.args.verbosity >= 2:
                                printf("    %s.%s()\n", stmt.symbol().name, inner.method.symbol.name)
                            typecheck_function_or_method_body(&state, &inner.method)
                case _:
                    pass
