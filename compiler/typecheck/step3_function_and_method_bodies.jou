# The third and final step of type checking. Checks the code inside functions
# and methods.
#
# After the third step, local variables exist, and the types of all values in
# the program are known.
#
# This step assumes that all classes, enums, global variables and functions
# already exist and are fully populated, so that we e.g. know what methods each
# class has and what parameter types they take.

import "stdlib/str.jou"
import "stdlib/io.jou"
import "stdlib/math.jou"
import "stdlib/mem.jou"

import "../ast.jou"
import "../errors_and_warnings.jou"
import "../evaluate.jou"
import "../types.jou"
import "./common.jou"


# Intended for errors. Returned string can be overwritten in next call.
# Imagine "cannot assign to" in front of these, e.g. "cannot assign to a constant"
def short_expression_description(expr: AstExpression*) -> byte[200]:
    if (
        expr->kind == AstExpressionKind::String
        or expr->kind == AstExpressionKind::Int
        or expr->kind == AstExpressionKind::Short
        or expr->kind == AstExpressionKind::Long
        or expr->kind == AstExpressionKind::Byte
        or expr->kind == AstExpressionKind::Float
        or expr->kind == AstExpressionKind::Double
        or expr->kind == AstExpressionKind::Bool
    ):
        return "a constant"

    if expr->kind == AstExpressionKind::Null:
        return "NULL"
    if expr->kind == AstExpressionKind::GetEnumMember:
        return "an enum member"
    if expr->kind == AstExpressionKind::SizeOf:
        return "a sizeof expression"
    if expr->kind == AstExpressionKind::Instantiate:
        return "a newly created instance"
    if expr->kind == AstExpressionKind::Array:
        return "an array literal"
    if expr->kind == AstExpressionKind::Indexing:
        return "an indexed value"
    if expr->kind == AstExpressionKind::As:
        return "the result of a cast"
    if expr->kind == AstExpressionKind::Dereference:
        return "the value of a pointer"
    if expr->kind == AstExpressionKind::And:
        return "the result of 'and'"
    if expr->kind == AstExpressionKind::Or:
        return "the result of 'or'"
    if expr->kind == AstExpressionKind::Not:
        return "the result of 'not'"
    if expr->kind == AstExpressionKind::Self:
        return "self"

    if expr->kind == AstExpressionKind::Call:
        if expr->call.method_call_self == NULL:
            return "a function call"
        else:
            return "a method call"

    if expr->kind == AstExpressionKind::GetVariable:
        if get_special_constant(expr->varname) != -1:
            return "a special constant"
        return "a variable"

    if (
        expr->kind == AstExpressionKind::Add
        or expr->kind == AstExpressionKind::Sub
        or expr->kind == AstExpressionKind::Mul
        or expr->kind == AstExpressionKind::Div
        or expr->kind == AstExpressionKind::Mod
        or expr->kind == AstExpressionKind::Negate
    ):
        return "the result of a calculation"

    if (
        expr->kind == AstExpressionKind::Eq
        or expr->kind == AstExpressionKind::Ne
        or expr->kind == AstExpressionKind::Gt
        or expr->kind == AstExpressionKind::Ge
        or expr->kind == AstExpressionKind::Lt
        or expr->kind == AstExpressionKind::Le
    ):
        return "the result of a comparison"

    if (
        expr->kind == AstExpressionKind::PreIncr
        or expr->kind == AstExpressionKind::PostIncr
    ):
        return "the result of incrementing a value"

    if (
        expr->kind == AstExpressionKind::PreDecr
        or expr->kind == AstExpressionKind::PostDecr
    ):
        return "the result of decrementing a value"

    result: byte[200]

    if expr->kind == AstExpressionKind::AddressOf:
        inner = short_expression_description(&expr->operands[0])
        snprintf(result, sizeof result, "address of %s", inner)
        return result

    if expr->kind == AstExpressionKind::GetClassField:
        snprintf(result, sizeof result, "field '%s'", expr->class_field.field_name)
        return result

    assert False


# The & operator can't go in front of most expressions.
# You can't do &(1 + 2), for example.
#
# The same rules apply to assignments: "foo = bar" is treated as setting the
# value of the pointer &foo to bar.
#
# errmsg_template can be e.g. "cannot take address of %s" or "cannot assign to %s"
def ensure_can_take_address(fom: FunctionOrMethodTypes*, expr: AstExpression*, errmsg_template: byte*) -> None:
    assert fom != NULL

    if (
        expr->kind == AstExpressionKind::Dereference
        or expr->kind == AstExpressionKind::Indexing  # &foo[bar]
        or (
            # &foo->bar = foo + offset (it doesn't use &foo)
            expr->kind == AstExpressionKind::GetClassField
            and expr->class_field.uses_arrow_operator
        )
    ):
        return

    if expr->kind == AstExpressionKind::GetClassField:
        # &foo.bar = &foo + offset
        assert not expr->class_field.uses_arrow_operator

        # Turn "cannot assign to %s" into "cannot assign to a field of %s".
        # This assumes that errmsg_template is relatively simple, i.e. it only contains one %s somewhere.
        newtemplate: byte* = malloc(strlen(errmsg_template) + 100)
        sprintf(newtemplate, errmsg_template, "a field of %s")

        ensure_can_take_address(fom, &expr->operands[0], newtemplate)
        free(newtemplate)
        return

    # You can usually take address of variable, but you can't take address of special
    # constant (e.g. &WINDOWS)
    if (
        expr->kind == AstExpressionKind::GetVariable
        and get_special_constant(expr->varname) == -1
    ):
        return

    # You can take address of self if it's not passed as a pointer:
    #
    #   def method(self: MyClass) -> None:
    #       do_something(&self)
    #
    # This lets you e.g. write methods that return a modified instance.
    if (
        expr->kind == AstExpressionKind::Self
        and fom->signature.argtypes[0]->kind == TypeKind::Class
    ):
        return

    msg: byte[500]
    desc = short_expression_description(expr)
    snprintf(msg, sizeof(msg), errmsg_template, desc)
    fail(expr->location, msg)


# Implicit casts are used in many places, e.g. function arguments.
#
# When you pass an argument of the wrong type, it's best to give an error message
# that says so, instead of some generic "expected type foo, got object of type bar"
# kind of message.
#
# The template can contain "<from>" and "<to>". They will be substituted with names
# of types. We cannot use printf() style functions because the arguments can be in
# any order.
def fail_with_implicit_cast_error(location: Location, template: byte*, from: Type*, to: Type*) -> None:
    assert template != NULL

    n = 0
    for i = 0; template[i] != '\0'; i++:
        if template[i] == '<':
            n++

    message: byte* = malloc(sizeof(from->name)*n + strlen(template) + 1)
    message[0] = '\0'
    while *template != '\0':
        if starts_with(template, "<from>"):
            template = &template[6]
            strcat(message, from->name)
        elif starts_with(template, "<to>"):
            template = &template[4]
            strcat(message, to->name)
        else:
            s = [*template++, '\0']
            strcat(message, s)

    fail(location, message)


def can_cast_implicitly(from: Type*, to: Type*) -> bool:
    # TODO: document these properly. But they are:
    #   array to pointer, e.g. int[3] --> int* (needs special-casing elsewhere)
    #   from one integer type to another bigger integer type, unless it is signed-->unsigned
    #   between two pointer types when one of the two is void*
    #   from float to double (TODO)
    return (
        from == to
        or (from->kind == TypeKind::Array and to->kind == TypeKind::Pointer and from->array.item_type == to->value_type)
        or (from->kind == TypeKind::Array and to->kind == TypeKind::VoidPointer)
        or (
            from->is_integer_type()
            and to->is_integer_type()
            and from->size_in_bits < to->size_in_bits
            and not (from->kind == TypeKind::SignedInteger and to->kind == TypeKind::UnsignedInteger)
        )
        or (from == floatType and to == doubleType)
        or (from->is_integer_type() and to->kind == TypeKind::FloatingPoint)
        or (from->is_pointer_type() and to->is_pointer_type() and (from == voidPtrType or to == voidPtrType))
    )


def can_cast_explicitly(from: Type*, to: Type*) -> bool:
    return (
        from == to
        or (from->kind == TypeKind::Array and to->kind == TypeKind::Pointer and from->array.item_type == to->value_type)
        or (from->kind == TypeKind::Array and to->kind == TypeKind::VoidPointer)
        or (from->is_pointer_type() and to->is_pointer_type())
        or (from->is_number_type() and to->is_number_type())
        or (from->is_integer_type() and to->kind == TypeKind::Enum)
        or (from->kind == TypeKind::Enum and to->is_integer_type())
        or (from == boolType and to->is_integer_type())
        or (from->is_pointer_type() and to == longType)
        or (from == longType and to->is_pointer_type())
    )


def do_implicit_cast(
    fom: FunctionOrMethodTypes*,
    types: ExpressionTypes*,
    to: Type*,
    location: Location,
    errormsg_template: byte*,
) -> None:
    assert types->implicit_cast_type == NULL
    assert not types->implicit_array_to_pointer_cast
    from = types->type
    if from == to:
        return

    if (
        types->expr->kind == AstExpressionKind::String
        and from == byteType->pointer_type()
        and to->kind == TypeKind::Array
        and to->array.item_type == byteType
    ):
        string_size = strlen(types->expr->string) + 1
        if to->array.len < string_size:
            msg: byte[500]
            snprintf(msg, sizeof(msg), "a string of %d bytes (including '\\0') does not fit into %s", string_size, to->name)
            fail(location, msg)
        types->implicit_string_to_array_cast = True
    # Passing in NULL for errormsg_template can be used to "force" a cast to happen.
    elif errormsg_template != NULL and not can_cast_implicitly(from, to):
        fail_with_implicit_cast_error(location, errormsg_template, from, to)

    types->implicit_cast_type = to
    types->implicit_array_to_pointer_cast = (from->kind == TypeKind::Array and to->is_pointer_type())

    if types->implicit_array_to_pointer_cast:
        ensure_can_take_address(
            fom,
            types->expr,
            "cannot create a pointer into an array that comes from %s (try storing it to a local variable first)"
        )


def cast_array_to_pointer(fom: FunctionOrMethodTypes*, types: ExpressionTypes*) -> None:
    assert types->type->kind == TypeKind::Array
    do_implicit_cast(fom, types, types->type->array.item_type->pointer_type(), Location{}, NULL)


def do_explicit_cast(fom: FunctionOrMethodTypes*, types: ExpressionTypes*, to: Type*, location: Location) -> None:
    assert types->implicit_cast_type == NULL
    from = types->type

    msg: byte[500]

    if from == to:
        snprintf(msg, sizeof(msg), "unnecessary cast from %s to %s", from->name, to->name)
        show_warning(location, msg)

    if not can_cast_explicitly(from, to):
        snprintf(msg, sizeof(msg), "cannot cast from type %s to %s", from->name, to->name)
        fail(location, msg)

    if from->kind == TypeKind::Array and to->is_pointer_type():
        cast_array_to_pointer(fom, types)


def typecheck_expression_not_void(ft: FileTypes*, expr: AstExpression*) -> ExpressionTypes*:
    types: ExpressionTypes* = typecheck_expression(ft, expr)
    if types != NULL:
        return types

    # Should be function/method call that returns void
    assert expr->kind == AstExpressionKind::Call

    msg: byte[500]
    if expr->call.method_call_self == NULL:
        snprintf(msg, sizeof(msg), "function '%s' does not return a value", expr->call.name)
    else:
        snprintf(msg, sizeof(msg), "method '%s' does not return a value", expr->call.name)
    fail(expr->location, msg)


def typecheck_expression_with_implicit_cast(
    ft: FileTypes*,
    expr: AstExpression*,
    casttype: Type*,
    errormsg_template: byte*,
) -> None:
    types = typecheck_expression_not_void(ft, expr)
    do_implicit_cast(ft->current_fom_types, types, casttype, expr->location, errormsg_template)


def check_binop(
    fom: FunctionOrMethodTypes*,
    op: AstExpressionKind,
    location: Location,
    lhstypes: ExpressionTypes*,
    rhstypes: ExpressionTypes*,
) -> Type*:
    do_what: byte*
    if op == AstExpressionKind::Add:
        do_what = "add"
    elif op == AstExpressionKind::Sub:
        do_what = "subtract"
    elif op == AstExpressionKind::Mul:
        do_what = "multiply"
    elif op == AstExpressionKind::Div:
        do_what = "divide"
    elif op == AstExpressionKind::Mod:
        do_what = "take remainder with"
    elif (
        op == AstExpressionKind::Eq
        or op == AstExpressionKind::Ne
        or op == AstExpressionKind::Gt
        or op == AstExpressionKind::Ge
        or op == AstExpressionKind::Lt
        or op == AstExpressionKind::Le
    ):
        do_what = "compare"
    else:
        assert False

    got_bools = lhstypes->type == boolType and rhstypes->type == boolType
    got_integers = lhstypes->type->is_integer_type() and rhstypes->type->is_integer_type()
    got_numbers = lhstypes->type->is_number_type() and rhstypes->type->is_number_type()
    got_enums = lhstypes->type->kind == TypeKind::Enum and rhstypes->type->kind == TypeKind::Enum
    got_pointers = (
        lhstypes->type->is_pointer_type()
        and rhstypes->type->is_pointer_type()
        and (
            # Ban comparisons like int* == byte*, unless one of the two types is void*
            lhstypes->type == rhstypes->type
            or lhstypes->type == voidPtrType
            or rhstypes->type == voidPtrType
        )
    )

    if (
        (
            (not got_bools)
            and (not got_numbers)
            and (not got_enums)
            and (not got_pointers)
        ) or (
            (got_bools or got_enums)
            and op != AstExpressionKind::Eq
            and op != AstExpressionKind::Ne
        ) or (
            got_pointers
            and op != AstExpressionKind::Eq
            and op != AstExpressionKind::Ne
            and op != AstExpressionKind::Gt
            and op != AstExpressionKind::Ge
            and op != AstExpressionKind::Lt
            and op != AstExpressionKind::Le
        )
    ):
        msg: byte[500]
        snprintf(msg, sizeof(msg), "wrong types: cannot %s %s and %s", do_what, lhstypes->type->name, rhstypes->type->name)
        fail(location, msg)

    cast_type: Type* = NULL
    if got_bools:
        cast_type = boolType
    if got_integers:
        cast_type = get_integer_type(
            max(lhstypes->type->size_in_bits, rhstypes->type->size_in_bits),
            lhstypes->type->kind == TypeKind::SignedInteger or rhstypes->type->kind == TypeKind::SignedInteger
        )
    if got_numbers and not got_integers:
        if lhstypes->type == doubleType or rhstypes->type == doubleType:
            cast_type = doubleType
        else:
            cast_type = floatType
    if got_pointers:
        cast_type = get_integer_type(64, False)
    if got_enums:
        cast_type = intType
    assert cast_type != NULL

    do_implicit_cast(fom, lhstypes, cast_type, Location{}, NULL)
    do_implicit_cast(fom, rhstypes, cast_type, Location{}, NULL)

    if (
        op == AstExpressionKind::Add
        or op == AstExpressionKind::Sub
        or op == AstExpressionKind::Mul
        or op == AstExpressionKind::Div
        or op == AstExpressionKind::Mod
    ):
        return cast_type

    if (
        op == AstExpressionKind::Eq
        or op == AstExpressionKind::Ne
        or op == AstExpressionKind::Gt
        or op == AstExpressionKind::Ge
        or op == AstExpressionKind::Lt
        or op == AstExpressionKind::Le
    ):
        return boolType

    assert False


def check_increment_or_decrement(ft: FileTypes*, expr: AstExpression*) -> Type*:
    bad_type_fmt, bad_expr_fmt: byte*

    if expr->kind == AstExpressionKind::PreIncr or expr->kind == AstExpressionKind::PostIncr:
        bad_type_fmt = "cannot increment a value of type %s"
        bad_expr_fmt = "cannot increment %s"
    elif expr->kind == AstExpressionKind::PreDecr or expr->kind == AstExpressionKind::PostDecr:
        bad_type_fmt = "cannot decrement a value of type %s"
        bad_expr_fmt = "cannot decrement %s"
    else:
        assert False

    ensure_can_take_address(ft->current_fom_types, &expr->operands[0], bad_expr_fmt)

    t = typecheck_expression_not_void(ft, &expr->operands[0])->type
    if not t->is_integer_type() and not t->is_pointer_type():
        msg: byte[500]
        snprintf(msg, sizeof(msg), bad_type_fmt, t->name)
        fail(expr->location, msg)
    return t


def typecheck_dereferenced_pointer(location: Location, t: Type*) -> None:
    # TODO: improved error message for dereferencing void*
    if t->kind != TypeKind::Pointer:
        msg: byte[500]
        snprintf(msg, sizeof(msg), "the dereference operator '*' is only for pointers, not for %s", t->name)
        fail(location, msg)


# ptr[index]
def typecheck_indexing(
    ft: FileTypes*,
    ptrexpr: AstExpression*,
    indexexpr: AstExpression*,
) -> Type*:
    msg: byte[500]

    types = typecheck_expression_not_void(ft, ptrexpr)

    if types->type->kind == TypeKind::Array:
        cast_array_to_pointer(ft->current_fom_types, types)
        ptrtype = types->implicit_cast_type
    else:
        if types->type->kind != TypeKind::Pointer:
            snprintf(msg, sizeof(msg), "value of type %s cannot be indexed", types->type->name)
            fail(ptrexpr->location, msg)
        ptrtype = types->type

    assert ptrtype != NULL
    assert ptrtype->kind == TypeKind::Pointer

    indextypes = typecheck_expression_not_void(ft, indexexpr)
    if not indextypes->type->is_integer_type():
        snprintf(msg, sizeof(msg), "the index inside [...] must be an integer, not %s", indextypes->type->name)
        fail(indexexpr->location, msg)

    # LLVM assumes that indexes smaller than 64 bits are signed.
    # https://github.com/Akuli/jou/issues/48
    do_implicit_cast(ft->current_fom_types, indextypes, longType, Location{}, NULL)

    return ptrtype->value_type


def typecheck_and_or(
    ft: FileTypes*,
    lhsexpr: AstExpression*,
    rhsexpr: AstExpression*,
    and_or: byte*,
) -> None:
    assert strcmp(and_or, "and") == 0 or strcmp(and_or, "or") == 0

    errormsg: byte[100]
    snprintf(errormsg, sizeof(errormsg), "'%s' only works with booleans, not <from>", and_or)

    typecheck_expression_with_implicit_cast(ft, lhsexpr, boolType, errormsg)
    typecheck_expression_with_implicit_cast(ft, rhsexpr, boolType, errormsg)


def nth(n: int) -> byte[100]:
    result: byte[100]

    assert n >= 1
    first_few = [NULL, "first", "second", "third", "fourth", "fifth", "sixth"]
    if n < sizeof(first_few) / sizeof(first_few[0]):
        strcpy(result, first_few[n])
    else:
        sprintf(result, "%dth", n)

    return result


def plural_s(n: int) -> byte*:
    if n == 1:
        # e.g. "1 argument"
        return ""
    else:
        # e.g. "0 arguments", "2 arguments"
        return "s"


# returns NULL if the function doesn't return anything, otherwise non-owned pointer to non-owned type
def typecheck_function_or_method_call(ft: FileTypes*, call: AstCall*, self_type: Type*, location: Location) -> Type*:
    msg: byte[500]

    sig = ft->find_function_or_method(self_type, call->name)
    if sig == NULL:
        if self_type == NULL:
            snprintf(msg, sizeof(msg), "function '%s' not found", call->name)
        elif self_type->kind == TypeKind::Class:
            snprintf(
                msg, sizeof(msg),
                "class %s does not have a method named '%s'",
                self_type->name, call->name)
        elif self_type->kind == TypeKind::Pointer and self_type->value_type->find_method(call->name) != NULL:
            snprintf(
                msg, sizeof(msg),
                "the method '%s' is defined on class %s, not on the pointer type %s, so you need to dereference the pointer first (e.g. by using '->' instead of '.')",
                call->name, self_type->value_type->name, self_type->name)
        else:
            snprintf(
                msg, sizeof(msg),
                "type %s does not have any methods because it is %s, not a class",
                self_type->name, short_type_description(self_type))

        fail(location, msg)

    if self_type == NULL:
        function_or_method = "function"
    else:
        function_or_method = "method"

    sigstr = sig->to_string(False, False)

    nargs = sig->nargs
    if self_type != NULL:
        nargs--

    if call->nargs < nargs or (call->nargs > nargs and not sig->takes_varargs):
        snprintf(
            msg, sizeof(msg),
            "%s %s takes %d argument%s, but it was called with %d argument%s",
            function_or_method,
            sigstr,
            nargs,
            plural_s(nargs),
            call->nargs,
            plural_s(call->nargs),
        )
        fail(location, msg)

    k = 0
    for i = 0; i < sig->nargs; i++:
        if strcmp(sig->argnames[i], "self") == 0:
            continue
        # This is a common error, so worth spending some effort to get a good error message.
        which_arg = nth(i+1)
        snprintf(
            msg, sizeof msg,
            "%s argument of %s %s should have type <to>, not <from>", which_arg, function_or_method, sigstr
        )
        typecheck_expression_with_implicit_cast(ft, &call->args[k++], sig->argtypes[i], msg)

    for i = k; i < call->nargs; i++:
        # This code runs for varargs, e.g. the things to format in printf().
        types = typecheck_expression_not_void(ft, &call->args[i])

        if types->type->kind == TypeKind::Array:
            cast_array_to_pointer(ft->current_fom_types, types)
        elif (
            (types->type->is_integer_type() and types->type->size_in_bits < 32)
            or types->type == boolType
        ):
            # Add implicit cast to signed int, just like in C.
            do_implicit_cast(ft->current_fom_types, types, intType, Location{}, NULL)
        elif types->type == floatType:
            do_implicit_cast(ft->current_fom_types, types, doubleType, Location{}, NULL)

    free(sigstr)
    return sig->returntype


def typecheck_class_field(
    classtype: Type*,
    fieldname: byte*,
    location: Location,
) -> ClassField*:
    assert classtype->kind == TypeKind::Class
    for f = classtype->classdata.fields; f < &classtype->classdata.fields[classtype->classdata.nfields]; f++:
        if strcmp(f->name, fieldname) == 0:
            return f

    msg: byte[500]
    snprintf(msg, sizeof(msg), "class %s has no field named '%s'", classtype->name, fieldname)
    fail(location, msg)


def typecheck_instantiation(ft: FileTypes*, inst: AstInstantiation*, location: Location) -> Type*:
    tmp = AstType{kind = AstTypeKind::Named, location = inst->class_name_location}
    assert sizeof(tmp.name) == sizeof(inst->class_name)
    strcpy(tmp.name, inst->class_name)
    t = type_from_ast(ft, &tmp)

    msg: byte[500]

    if t->kind != TypeKind::Class:
        snprintf(
            msg, sizeof(msg),
            "the %s{...} syntax is only for classes, but %s is %s",
            t->name, t->name, short_type_description(t))
        fail(location, msg)

    specified_fields: ClassField** = malloc(sizeof(specified_fields[0]) * inst->nfields)

    for i = 0; i < inst->nfields; i++:
        f = typecheck_class_field(t, inst->field_names[i], inst->field_values[i].location)

        snprintf(msg, sizeof msg,
            "value for field '%s' of class %s must be of type <to>, not <from>",
            inst->field_names[i], inst->class_name)
        typecheck_expression_with_implicit_cast(ft, &inst->field_values[i], f->type, msg)
        specified_fields[i] = f

    for i1 = 0; i1 < inst->nfields; i1++:
        for i2 = i1+1; i2 < inst->nfields; i2++:
            if specified_fields[i1]->union_id == specified_fields[i2]->union_id:
                snprintf(msg, sizeof(msg),
                    "fields '%s' and '%s' cannot be set simultaneously because they belong to the same union",
                    specified_fields[i1]->name, specified_fields[i2]->name)
                fail(inst->field_values[i2].location,msg)

    free(specified_fields)
    return t


def enum_member_exists(t: Type*, name: byte*) -> bool:
    assert t->kind == TypeKind::Enum
    for i = 0; i < t->enummembers.count; i++:
        if strcmp(t->enummembers.names[i], name) == 0:
            return True
    return False


def cast_array_members_to_a_common_type(fom: FunctionOrMethodTypes*, error_location: Location, exprtypes: ExpressionTypes**) -> Type*:
    # Avoid O(ntypes^2) code in a long array where all or almost all items have the same type.
    # This is at most O(ntypes*k) where k is the number of distinct types.
    distinct: Type** = NULL
    ndistinct = 0

    for et = exprtypes; *et != NULL; et++:
        found = False
        for t = distinct; t < &distinct[ndistinct]; t++:
            if (*et)->type == *t:
                found = True
                break
        if not found:
            distinct = realloc(distinct, sizeof(distinct[0]) * (ndistinct + 1))
            assert distinct != NULL
            distinct[ndistinct++] = (*et)->type

    compatible_with_all: Type** = NULL
    n_compatible_with_all = 0

    for t = distinct; t < &distinct[ndistinct]; t++:
        t_compatible_with_all_others = True
        for t2 = distinct; t2 < &distinct[ndistinct]; t2++:
            if not can_cast_implicitly(*t2, *t):
                t_compatible_with_all_others = False
                break

        if t_compatible_with_all_others:
            compatible_with_all = realloc(compatible_with_all, sizeof(compatible_with_all[0]) * (n_compatible_with_all + 1))
            assert compatible_with_all != NULL
            compatible_with_all[n_compatible_with_all++] = *t

    if n_compatible_with_all > 1:
        # Remove void* if exists, so that type of ["hello", NULL] becomes byte*[2]
        for i = 0; i < n_compatible_with_all; i++:
            if compatible_with_all[i] == voidPtrType:
                compatible_with_all[i] = compatible_with_all[--n_compatible_with_all]
                break

    if n_compatible_with_all != 1:
        size = 500L
        for t = distinct; t < &distinct[ndistinct]; t++:
            size += strlen((*t)->name) + 3  # 1 for comma, 1 for space, 1 because why not lol

        msg: byte* = malloc(size)
        assert msg != NULL

        strcpy(msg, "array items have different types (")
        for t = distinct; t < &distinct[ndistinct]; t++:
            if t != distinct:
                strcat(msg, ", ")
            strcat(msg, (*t)->name)
        strcat(msg, ")")
        fail(error_location, msg)

    elemtype = compatible_with_all[0]
    free(distinct)
    free(compatible_with_all)

    for et = exprtypes; *et != NULL; et++:
        do_implicit_cast(fom, *et, elemtype, error_location, NULL)
    return elemtype


def typecheck_expression(ft: FileTypes*, expr: AstExpression*) -> ExpressionTypes*:
    msg: byte[500]
    result: Type* = NULL

    if expr->kind == AstExpressionKind::Bool:
        result = boolType
    elif expr->kind == AstExpressionKind::Byte:
        result = byteType
    elif expr->kind == AstExpressionKind::Double:
        result = doubleType
    elif expr->kind == AstExpressionKind::Float:
        result = floatType
    elif expr->kind == AstExpressionKind::Short:
        result = shortType
    elif expr->kind == AstExpressionKind::Int:
        result = intType
    elif expr->kind == AstExpressionKind::Long:
        result = longType
    elif expr->kind == AstExpressionKind::Null:
        result = voidPtrType
    elif expr->kind == AstExpressionKind::String:
        result = byteType->pointer_type()

    elif expr->kind == AstExpressionKind::GetEnumMember:
        result = ft->find_type(expr->enum_member.enum_name)
        if result == NULL:
            snprintf(msg, sizeof(msg), "there is no type named '%s'", expr->enum_member.enum_name)
            fail(expr->location, msg)
        if result->kind != TypeKind::Enum:
            snprintf(
                msg, sizeof(msg),
                "the '::' syntax is only for enums, but %s is %s",
                expr->enum_member.enum_name,
                short_type_description(result),
            )
            fail(expr->location, msg)
        if not enum_member_exists(result, expr->enum_member.member_name):
            snprintf(
                msg, sizeof(msg),
                "enum %s has no member named '%s'",
                expr->enum_member.enum_name, expr->enum_member.member_name)
            fail(expr->location, msg)

    elif expr->kind == AstExpressionKind::SizeOf:
        typecheck_expression_not_void(ft, &expr->operands[0])
        result = longType

    elif expr->kind == AstExpressionKind::Instantiate:
        result = typecheck_instantiation(ft, &expr->instantiation, expr->location)

    elif expr->kind == AstExpressionKind::Array:
        n = expr->array.length
        exprtypes: ExpressionTypes** = calloc(sizeof(exprtypes[0]), n+1)
        for i = 0; i < n; i++:
            exprtypes[i] = typecheck_expression_not_void(ft, &expr->array.items[i])

        membertype = cast_array_members_to_a_common_type(ft->current_fom_types, expr->location, exprtypes)
        free(exprtypes)
        result = membertype->array_type(n)

    elif expr->kind == AstExpressionKind::GetClassField:
        if expr->class_field.uses_arrow_operator:
            temptype = typecheck_expression_not_void(ft, expr->class_field.instance)->type
            if temptype->kind != TypeKind::Pointer or temptype->value_type->kind != TypeKind::Class:
                snprintf(
                    msg, sizeof(msg),
                    "left side of the '->' operator must be a pointer to a class, not %s",
                    temptype->name)
                fail(expr->location, msg)
            result = typecheck_class_field(temptype->value_type, expr->class_field.field_name, expr->location)->type
        else:
            temptype = typecheck_expression_not_void(ft, expr->class_field.instance)->type
            if temptype->kind != TypeKind::Class:
                snprintf(
                    msg, sizeof(msg),
                    "left side of the '.' operator must be an instance of a class, not %s",
                    temptype->name)
                fail(expr->location, msg)
            result = typecheck_class_field(temptype, expr->class_field.field_name, expr->location)->type

    elif expr->kind == AstExpressionKind::Call:
        if expr->call.method_call_self == NULL:
            result = typecheck_function_or_method_call(ft, &expr->call, NULL, expr->location)
        elif expr->call.uses_arrow_operator:
            temptype = typecheck_expression_not_void(ft, expr->call.method_call_self)->type
            if temptype->kind != TypeKind::Pointer:
                snprintf(msg, sizeof(msg),
                    "left side of the '->' operator must be a pointer, not %s",
                    temptype->name)
                fail(expr->location, msg)
            result = typecheck_function_or_method_call(ft, &expr->call, temptype->value_type, expr->location)
        else:
            temptype = typecheck_expression_not_void(ft, expr->call.method_call_self)->type
            result = typecheck_function_or_method_call(ft, &expr->call, temptype, expr->location)

            # If self argument is passed by pointer, make sure we can create that pointer
            assert temptype->kind == TypeKind::Class
            signature = temptype->find_method(expr->call.name)
            assert signature != NULL
            if signature->argtypes[0]->is_pointer_type():
                assert strstr(expr->call.name, "%") == NULL
                snprintf(
                    msg, sizeof msg,
                    "cannot take address of %%s, needed for calling the %s() method",
                    expr->call.name)
                ensure_can_take_address(ft->current_fom_types, expr->call.method_call_self, msg)

        if result == NULL:
            # no return value produced
            return NULL

    elif expr->kind == AstExpressionKind::Indexing:
        result = typecheck_indexing(ft, &expr->operands[0], &expr->operands[1])

    elif expr->kind == AstExpressionKind::AddressOf:
        ensure_can_take_address(ft->current_fom_types, &expr->operands[0], "the '&' operator cannot be used with %s")
        temptype = typecheck_expression_not_void(ft, &expr->operands[0])->type
        result = temptype->pointer_type()

    elif expr->kind == AstExpressionKind::GetVariable:
        result = ft->find_any_var(expr->varname)
        if result == NULL:
            snprintf(msg, sizeof(msg), "no variable named '%s'", expr->varname)
            fail(expr->location, msg)

    elif expr->kind == AstExpressionKind::Self:
        selfvar = ft->find_local_var("self")
        assert selfvar != NULL
        result = selfvar->type

    elif expr->kind == AstExpressionKind::Dereference:
        temptype = typecheck_expression_not_void(ft, &expr->operands[0])->type
        typecheck_dereferenced_pointer(expr->location, temptype)
        result = temptype->value_type

    elif expr->kind == AstExpressionKind::And:
        typecheck_and_or(ft, &expr->operands[0], &expr->operands[1], "and")
        result = boolType

    elif expr->kind == AstExpressionKind::Or:
        typecheck_and_or(ft, &expr->operands[0], &expr->operands[1], "or")
        result = boolType

    elif expr->kind == AstExpressionKind::Not:
        typecheck_expression_with_implicit_cast(
            ft, &expr->operands[0], boolType,
            "value after 'not' must be a boolean, not <from>")
        result = boolType

    elif expr->kind == AstExpressionKind::Negate:
        result = typecheck_expression_not_void(ft, &expr->operands[0])->type
        if result->kind != TypeKind::SignedInteger and result->kind != TypeKind::FloatingPoint:
            snprintf(msg, sizeof(msg),
                "value after '-' must be a float or double or a signed integer, not %s",
                result->name)
            fail(expr->location, msg)

    elif (
        expr->kind == AstExpressionKind::Add
        or expr->kind == AstExpressionKind::Sub
        or expr->kind == AstExpressionKind::Mul
        or expr->kind == AstExpressionKind::Div
        or expr->kind == AstExpressionKind::Mod
        or expr->kind == AstExpressionKind::Eq
        or expr->kind == AstExpressionKind::Ne
        or expr->kind == AstExpressionKind::Gt
        or expr->kind == AstExpressionKind::Ge
        or expr->kind == AstExpressionKind::Lt
        or expr->kind == AstExpressionKind::Le
    ):
        lhstypes = typecheck_expression_not_void(ft, &expr->operands[0])
        rhstypes = typecheck_expression_not_void(ft, &expr->operands[1])
        result = check_binop(ft->current_fom_types, expr->kind, expr->location, lhstypes, rhstypes)

    elif (
        expr->kind == AstExpressionKind::PreIncr
        or expr->kind == AstExpressionKind::PreDecr
        or expr->kind == AstExpressionKind::PostIncr
        or expr->kind == AstExpressionKind::PostDecr
    ):
        result = check_increment_or_decrement(ft, expr)

    elif expr->kind == AstExpressionKind::As:
        origtypes = typecheck_expression_not_void(ft, &expr->as_->value)
        result = type_from_ast(ft, &expr->as_->type)
        do_explicit_cast(ft->current_fom_types, origtypes, result, expr->location)

    else:
        printf("%d\n", expr->kind)
        assert False

    assert result != NULL

    types: ExpressionTypes* = calloc(1, sizeof *types)
    types->expr = expr
    types->type = result

    ft->current_fom_types->expr_types = realloc(ft->current_fom_types->expr_types, sizeof(ft->current_fom_types->expr_types[0]) * (ft->current_fom_types->n_expr_types + 1))
    assert ft->current_fom_types->expr_types != NULL
    ft->current_fom_types->expr_types[ft->current_fom_types->n_expr_types++] = types

    return types


def typecheck_body(ft: FileTypes*, body: AstBody*) -> None:
    for i = 0; i < body->nstatements; i++:
        typecheck_statement(ft, &body->statements[i])


def typecheck_if_statement(ft: FileTypes*, ifstmt: AstIfStatement*) -> None:
    for i = 0; i < ifstmt->n_if_and_elifs; i++:
        if i == 0:
            errmsg = "'if' condition must be a boolean, not <from>"
        else:
            errmsg = "'elif' condition must be a boolean, not <from>"

        typecheck_expression_with_implicit_cast(
            ft, &ifstmt->if_and_elifs[i].condition, boolType, errmsg)
        typecheck_body(ft, &ifstmt->if_and_elifs[i].body)

    typecheck_body(ft, &ifstmt->else_body)


def typecheck_statement(ft: FileTypes*, stmt: AstStatement*) -> None:
    msg: byte[500]

    if stmt->kind == AstStatementKind::If:
        typecheck_if_statement(ft, &stmt->if_statement)

    elif stmt->kind == AstStatementKind::WhileLoop:
        typecheck_expression_with_implicit_cast(
            ft, &stmt->while_loop.condition, boolType,
            "'while' condition must be a boolean, not <from>")
        typecheck_body(ft, &stmt->while_loop.body)

    elif stmt->kind == AstStatementKind::ForLoop:
        typecheck_statement(ft, stmt->for_loop.init)
        typecheck_expression_with_implicit_cast(
            ft, &stmt->for_loop.cond, boolType,
            "'for' condition must be a boolean, not <from>")
        typecheck_body(ft, &stmt->for_loop.body)
        typecheck_statement(ft, stmt->for_loop.incr)

    elif (
        stmt->kind == AstStatementKind::Break
        or stmt->kind == AstStatementKind::Continue
        or stmt->kind == AstStatementKind::Pass
    ):
        pass

    elif stmt->kind == AstStatementKind::Assign:
        targetexpr = &stmt->assignment.target
        valueexpr = &stmt->assignment.value

        if (
            targetexpr->kind == AstExpressionKind::GetVariable
            and ft->find_any_var(targetexpr->varname) == NULL
        ):
            # Making a new variable. Use the type of the value being assigned.
            types = typecheck_expression_not_void(ft, valueexpr)
            ft->current_fom_types->add_variable(types->type, targetexpr->varname)
        else:
            # Convert value to the type of an existing variable or other assignment target.
            ensure_can_take_address(ft->current_fom_types, targetexpr, "cannot assign to %s")

            if targetexpr->kind == AstExpressionKind::Dereference:
                strcpy(msg, "cannot place a value of type <from> into a pointer of type <to>*")
            else:
                desc = short_expression_description(targetexpr)
                snprintf(msg, sizeof msg, "cannot assign a value of type <from> to %s of type <to>", desc)

            targettypes = typecheck_expression_not_void(ft, targetexpr)
            typecheck_expression_with_implicit_cast(ft, valueexpr, targettypes->type, msg)

    elif (
        stmt->kind == AstStatementKind::InPlaceAdd
        or stmt->kind == AstStatementKind::InPlaceSub
        or stmt->kind == AstStatementKind::InPlaceMul
        or stmt->kind == AstStatementKind::InPlaceDiv
        or stmt->kind == AstStatementKind::InPlaceMod
    ):
        targetexpr = &stmt->assignment.target
        valueexpr = &stmt->assignment.value

        ensure_can_take_address(ft->current_fom_types, targetexpr, "cannot assign to %s")
        targettypes = typecheck_expression_not_void(ft, targetexpr)
        value_types = typecheck_expression_not_void(ft, valueexpr)

        if stmt->kind == AstStatementKind::InPlaceAdd:
            op = AstExpressionKind::Add
            opname = "addition"
        elif stmt->kind == AstStatementKind::InPlaceSub:
            op = AstExpressionKind::Sub
            opname = "subtraction"
        elif stmt->kind == AstStatementKind::InPlaceMul:
            op = AstExpressionKind::Mul
            opname = "multiplication"
        elif stmt->kind == AstStatementKind::InPlaceDiv:
            op = AstExpressionKind::Div
            opname = "division"
        elif stmt->kind == AstStatementKind::InPlaceMod:
            op = AstExpressionKind::Mod
            opname = "modulo"
        else:
            assert False

        t = check_binop(ft->current_fom_types, op, stmt->location, targettypes, value_types)
        tempvalue_types = ExpressionTypes{expr = targetexpr, type = t}

        snprintf(msg, sizeof msg, "%s produced a value of type <from> which cannot be assigned back to <to>", opname)
        do_implicit_cast(ft->current_fom_types, &tempvalue_types, targettypes->type, stmt->location, msg)

        # I think it is currently impossible to cast target.
        # If this assert fails, we probably need to add another error message for it.
        assert targettypes->implicit_cast_type == NULL

    elif stmt->kind == AstStatementKind::Return:
        if ft->current_fom_types->signature.is_noreturn:
            snprintf(msg, sizeof(msg),
                "function '%s' cannot return because it was defined with '-> noreturn'",
                ft->current_fom_types->signature.name)
            fail(stmt->location, msg)

        return_type = ft->current_fom_types->signature.returntype

        if stmt->return_value != NULL and return_type == NULL:
            snprintf(msg, sizeof(msg), "function '%s' cannot return a value because it was defined with '-> None'",
                ft->current_fom_types->signature.name)
            fail(stmt->location, msg)

        if return_type != NULL and stmt->return_value == NULL:
            snprintf(msg, sizeof(msg),
                "a return value is needed, because the return type of function '%s' is %s",
                ft->current_fom_types->signature.name,
                ft->current_fom_types->signature.returntype->name)
            fail(stmt->location, msg)

        if stmt->return_value != NULL:
            snprintf(msg, sizeof msg,
                "attempting to return a value of type <from> from function '%s' defined with '-> <to>'",
                ft->current_fom_types->signature.name)
            typecheck_expression_with_implicit_cast(
                ft, stmt->return_value, ft->find_local_var("return")->type, msg)

    elif stmt->kind == AstStatementKind::DeclareLocalVar:
        if ft->find_any_var(stmt->var_declaration.name) != NULL:
            snprintf(msg, sizeof(msg), "a variable named '%s' already exists", stmt->var_declaration.name)
            fail(stmt->location, msg)

        type = type_from_ast(ft, &stmt->var_declaration.type)
        ft->current_fom_types->add_variable(type, stmt->var_declaration.name)

        if stmt->var_declaration.value != NULL:
            typecheck_expression_with_implicit_cast(
                ft, stmt->var_declaration.value, type,
                "initial value for variable of type <to> cannot be of type <from>")

    elif stmt->kind == AstStatementKind::ExpressionStatement:
        typecheck_expression(ft, &stmt->expression)

    elif stmt->kind == AstStatementKind::Assert:
        typecheck_expression_with_implicit_cast(ft, &stmt->expression, boolType, "assertion must be a boolean, not <from>")

    else:
        assert False


def typecheck_function_or_method_body(ft: FileTypes*, sig: Signature*, body: AstBody*) -> None:
    assert ft->current_fom_types == NULL

    ft->fomtypes = realloc(ft->fomtypes, sizeof(ft->fomtypes[0]) * (ft->nfomtypes + 1))
    assert ft->fomtypes != NULL
    ft->fomtypes[ft->nfomtypes++] = FunctionOrMethodTypes{}

    ft->current_fom_types = &ft->fomtypes[ft->nfomtypes - 1]
    ft->current_fom_types->signature = sig->copy()

    for i = 0; i < sig->nargs; i++:
        v = ft->current_fom_types->add_variable(sig->argtypes[i], sig->argnames[i])
        v->is_argument = True

    if sig->returntype != NULL:
        ft->current_fom_types->add_variable(sig->returntype, "return")

    typecheck_body(ft, body)
    ft->current_fom_types = NULL


def typecheck_step3_function_and_method_bodies(ft: FileTypes*, ast: AstFile*) -> None:
    for i = 0; i < ast->body.nstatements; i++:
        stmt = &ast->body.statements[i]
        if stmt->kind == AstStatementKind::Function and stmt->function.body.nstatements > 0:
            sig = ft->find_function(stmt->function.signature.name)
            assert sig != NULL
            typecheck_function_or_method_body(ft, sig, &stmt->function.body)

        if stmt->kind == AstStatementKind::Class:
            classtype: Type* = NULL
            for t = ft->owned_types; t < &ft->owned_types[ft->n_owned_types]; t++:
                if strcmp((*t)->name, stmt->classdef.name) == 0:
                    classtype = *t
                    break
            assert classtype != NULL

            for m = stmt->classdef.members; m < &stmt->classdef.members[stmt->classdef.nmembers]; m++:
                if m->kind != AstClassMemberKind::Method:
                    continue
                method = &m->method

                sig = classtype->find_method(method->signature.name)
                assert sig != NULL
                typecheck_function_or_method_body(ft, sig, &method->body)
