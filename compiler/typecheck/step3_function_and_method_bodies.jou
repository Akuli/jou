# The third and final step of type checking. Checks the code inside functions
# and methods.
#
# After the third step, local variables exist, and the types of all values in
# the program are known.
#
# This step assumes that all classes, enums, global variables and functions
# already exist and are fully populated, so that we e.g. know what methods each
# class has and what parameter types they take.

import "stdlib/list.jou"
import "stdlib/str.jou"
import "stdlib/io.jou"
import "stdlib/math.jou"
import "stdlib/mem.jou"

import "../ast.jou"
import "../constants.jou"
import "../errors_and_warnings.jou"
import "../evaluate.jou"
import "../types.jou"
import "../types_in_ast.jou"
import "./common.jou"


class State:
    file_types: FileTypes*
    fom_types: FunctionOrMethodTypes*

    def find_any_var(self, name: byte*) -> Type*:
        local = self->fom_types->find_local_var(name)
        if local != NULL:
            return local->type
        return self->file_types->find_global_var(name)

    def find_any_constant(self, name: byte*) -> Type*:
        if get_special_constant(name) != -1:
            return boolType
        c = self->file_types->find_constant(name)
        if c != NULL:
            return c->get_type()
        return NULL

    def find_any_var_or_constant(self, name: byte*) -> Type*:
        vartype = self->find_any_var(name)
        if vartype != NULL:
            return vartype
        return self->find_any_constant(name)


# Intended for errors. Returned string can be overwritten in next call.
# Imagine "cannot assign to" in front of these, e.g. "cannot assign to a constant"
def short_expression_description(expr: AstExpression*) -> byte[200]:
    result: byte[200]

    match expr->kind:
        case AstExpressionKind.Constant:
            return "a constant"
        case AstExpressionKind.GetEnumMember:
            return "an enum member"
        case AstExpressionKind.SizeOf:
            return "a sizeof expression"
        case AstExpressionKind.Instantiate:
            return "a newly created instance"
        case AstExpressionKind.Array:
            return "an array literal"
        case AstExpressionKind.Indexing:
            return "an indexed value"
        case AstExpressionKind.As:
            return "the result of a cast"
        case AstExpressionKind.Dereference:
            return "the value of a pointer"
        case AstExpressionKind.And:
            return "the result of 'and'"
        case AstExpressionKind.Or:
            return "the result of 'or'"
        case AstExpressionKind.Not:
            return "the result of 'not'"
        case AstExpressionKind.Self:
            return "self"

        case AstExpressionKind.Call:
            if expr->call.method_call_self == NULL:
                return "a function call"
            else:
                return "a method call"

        case AstExpressionKind.GetVariable:
            return "a variable"

        case (
            AstExpressionKind.Add
            | AstExpressionKind.Sub
            | AstExpressionKind.Mul
            | AstExpressionKind.Div
            | AstExpressionKind.Mod
            | AstExpressionKind.Negate
        ):
            return "the result of a calculation"

        case (
            AstExpressionKind.Eq
            | AstExpressionKind.Ne
            | AstExpressionKind.Gt
            | AstExpressionKind.Ge
            | AstExpressionKind.Lt
            | AstExpressionKind.Le
        ):
            return "the result of a comparison"

        case AstExpressionKind.PreIncr | AstExpressionKind.PostIncr:
            return "the result of incrementing a value"
        case AstExpressionKind.PreDecr | AstExpressionKind.PostDecr:
            return "the result of decrementing a value"

        case AstExpressionKind.AddressOf:
            inner = short_expression_description(&expr->operands[0])
            snprintf(result, sizeof result, "address of %s", inner)
            return result

        case AstExpressionKind.GetClassField:
            snprintf(result, sizeof result, "field '%s'", expr->class_field.field_name)
            return result


# The & operator can't go in front of most expressions.
# You can't do &(1 + 2), for example.
#
# The same rules apply to assignments: "foo = bar" is treated as setting the
# value of the pointer &foo to bar.
#
# errmsg_template can be e.g. "cannot take address of %s" or "cannot assign to %s"
def ensure_can_take_address(fom: FunctionOrMethodTypes*, expr: AstExpression*, errmsg_template: byte*) -> None:
    assert fom != NULL

    # If this assertion fails, it means you called ensure_can_take_address()
    # before type-checking the expression. That's bad because this depends on
    # the results of type checking.
    #
    # The dependency is a bit surprising. Jou code "foo.bar" can be either an
    # enum member, or a field on an instance of a class. That is determined
    # when type checking. Members of instances can be (usually) assigned to,
    # but enum members cannot.
    assert expr->types.orig_type != NULL

    if (
        expr->kind == AstExpressionKind.Dereference
        or expr->kind == AstExpressionKind.Indexing  # &foo[bar]
        or (
            # &foo->bar = foo + offset (it doesn't use &foo)
            expr->kind == AstExpressionKind.GetClassField
            and expr->class_field.uses_arrow_operator
        )
    ):
        return

    if expr->kind == AstExpressionKind.GetClassField:
        # &foo.bar = &foo + offset
        assert not expr->class_field.uses_arrow_operator

        # Turn "cannot assign to %s" into "cannot assign to a field of %s".
        # This assumes that errmsg_template is relatively simple, i.e. it only contains one %s somewhere.
        newtemplate: byte*
        asprintf(&newtemplate, errmsg_template, "a field of %s")

        ensure_can_take_address(fom, &expr->operands[0], newtemplate)
        free(newtemplate)
        return

    if expr->kind == AstExpressionKind.GetVariable:
        return

    # You can take address of self if it's not passed as a pointer:
    #
    #   def method(self: MyClass) -> None:
    #       do_something(&self)
    #
    # This lets you e.g. write methods that return a modified instance.
    if (
        expr->kind == AstExpressionKind.Self
        and fom->signature.argtypes[0]->kind == TypeKind.Class
    ):
        return

    msg: byte[500]
    desc = short_expression_description(expr)
    snprintf(msg, sizeof(msg), errmsg_template, desc)
    fail(expr->location, msg)


# Implicit casts are used in many places, e.g. function arguments.
#
# When you pass an argument of the wrong type, it's best to give an error message
# that says so, instead of some generic "expected type foo, got object of type bar"
# kind of message.
#
# The template can contain "<from>" and "<to>". They will be substituted with names
# of types. We cannot use printf() style functions because the arguments can be in
# any order.
def fail_with_implicit_cast_error(location: Location, template: byte*, from: Type*, to: Type*) -> None:
    assert template != NULL

    n = 0
    for i = 0; template[i] != '\0'; i++:
        if template[i] == '<':
            n++

    message: byte* = malloc(sizeof(from->name)*n + strlen(template) + 1)
    message[0] = '\0'
    while *template != '\0':
        if starts_with(template, "<from>"):
            template = &template[6]
            strcat(message, from->name)
        elif starts_with(template, "<to>"):
            template = &template[4]
            strcat(message, to->name)
        else:
            s = [*template++, '\0']
            strcat(message, s)

    fail(location, message)


def can_cast_implicitly(from: Type*, to: Type*) -> bool:
    # Please keep doc/types.md up to date if you modify this
    return (
        from == to
        or (from->kind == TypeKind.Array and to->kind == TypeKind.Pointer and from->array.item_type == to->value_type)
        or (from->kind == TypeKind.Array and to->kind == TypeKind.VoidPointer)
        or (
            from->is_integer_type()
            and to->is_integer_type()
            and from->size_in_bits < to->size_in_bits
            and not (from->kind == TypeKind.SignedInteger and to->kind == TypeKind.UnsignedInteger)
        )
        or (from == floatType and to == doubleType)
        or (from->is_integer_type() and to->kind == TypeKind.FloatingPoint)
        or (from->is_pointer_type() and to->is_pointer_type() and (from == voidPtrType or to == voidPtrType))
    )


def can_cast_explicitly(from: Type*, to: Type*) -> bool:
    # Please keep doc/types.md up to date if you modify this
    return (
        from == to
        or (from->kind == TypeKind.Array and to->kind == TypeKind.Pointer and from->array.item_type == to->value_type)
        or (from->kind == TypeKind.Array and to->kind == TypeKind.VoidPointer)
        or (from->is_pointer_type() and to->is_pointer_type())
        or (from->is_number_type() and to->is_number_type())
        or (from->is_integer_type() and to->kind == TypeKind.Enum)
        or (from->kind == TypeKind.Enum and to->is_integer_type())
        or (from == boolType and to->is_integer_type())
        or (from->is_pointer_type() and to == longType)
        or (from == longType and to->is_pointer_type())
    )


def do_implicit_cast(
    fom: FunctionOrMethodTypes*,
    expr: AstExpression*,
    to: Type*,
    location: Location,
    errormsg_template: byte*,
) -> None:
    assert expr->types.orig_type != NULL
    assert expr->types.implicit_cast_type == expr->types.orig_type
    assert not expr->types.implicit_array_to_pointer_cast

    from = expr->types.orig_type
    if from == to:
        return

    # Passing in NULL for errormsg_template can be used to "force" a cast to happen.
    if errormsg_template != NULL and not can_cast_implicitly(from, to):
        fail_with_implicit_cast_error(location, errormsg_template, from, to)

    expr->types.implicit_cast_type = to
    expr->types.implicit_array_to_pointer_cast = (from->kind == TypeKind.Array and to->is_pointer_type())
    if expr->types.implicit_array_to_pointer_cast:
        ensure_can_take_address(
            fom,
            expr,
            "cannot create a pointer into an array that comes from %s (try storing it to a local variable first)"
        )


def cast_array_to_pointer(fom: FunctionOrMethodTypes*, expr: AstExpression*) -> None:
    assert expr->types.orig_type != NULL
    assert expr->types.orig_type->kind == TypeKind.Array
    do_implicit_cast(fom, expr, expr->types.orig_type->array.item_type->pointer_type(), Location{}, NULL)


def do_explicit_cast(fom: FunctionOrMethodTypes*, expr: AstExpression*, to: Type*, location: Location) -> None:
    assert expr->types.orig_type != NULL
    assert expr->types.implicit_cast_type == expr->types.orig_type
    from = expr->types.orig_type

    msg: byte[500]

    if from == to:
        snprintf(msg, sizeof(msg), "unnecessary cast from %s to %s", from->name, to->name)
        show_warning(location, msg)

    if not can_cast_explicitly(from, to):
        snprintf(msg, sizeof(msg), "cannot cast from type %s to %s", from->name, to->name)
        fail(location, msg)

    if from->kind == TypeKind.Array and to->is_pointer_type():
        cast_array_to_pointer(fom, expr)


def typecheck_expression_not_void(state: State*, expr: AstExpression*, type_hint: Type*) -> Type*:
    typecheck_expression(state, expr, type_hint)
    if expr->types.orig_type != NULL:
        # The happy path. Evaluating the expression results in a value.
        return expr->types.orig_type

    # Should be function/method call that returns None
    assert expr->kind == AstExpressionKind.Call

    msg: byte[500]
    snprintf(msg, sizeof(msg), "%s '%s' does not return a value", expr->call.function_or_method(), expr->call.name)
    fail(expr->location, msg)


def typecheck_expression_with_implicit_cast(
    state: State*,
    expr: AstExpression*,
    casttype: Type*,
    errormsg_template: byte*,
) -> None:
    assert casttype != NULL
    typecheck_expression_not_void(state, expr, casttype)
    do_implicit_cast(state->fom_types, expr, casttype, expr->location, errormsg_template)


def check_binop(
    fom: FunctionOrMethodTypes*,
    op: AstExpressionKind,
    location: Location,
    lhs: AstExpression*,
    rhs: AstExpression*,
) -> Type*:
    assert lhs->types.orig_type != NULL
    assert rhs->types.orig_type != NULL

    do_what: byte*
    match op:
        case AstExpressionKind.Add:
            do_what = "add"
        case AstExpressionKind.Sub:
            do_what = "subtract"
        case AstExpressionKind.Mul:
            do_what = "multiply"
        case AstExpressionKind.Div:
            do_what = "divide"
        case AstExpressionKind.Mod:
            do_what = "take remainder with"
        case (
            AstExpressionKind.Eq
            | AstExpressionKind.Ne
            | AstExpressionKind.Gt
            | AstExpressionKind.Ge
            | AstExpressionKind.Lt
            | AstExpressionKind.Le
        ):
            do_what = "compare"
        case _:
            assert False

    got_bools = lhs->types.orig_type == boolType and rhs->types.orig_type == boolType
    got_integers = lhs->types.orig_type->is_integer_type() and rhs->types.orig_type->is_integer_type()
    got_numbers = lhs->types.orig_type->is_number_type() and rhs->types.orig_type->is_number_type()
    got_enums = lhs->types.orig_type->kind == TypeKind.Enum and lhs->types.orig_type == rhs->types.orig_type
    got_pointers = (
        lhs->types.orig_type->is_pointer_type()
        and rhs->types.orig_type->is_pointer_type()
        and (
            # Ban comparisons like int* == byte*, unless one of the two types is void*
            lhs->types.orig_type == rhs->types.orig_type
            or lhs->types.orig_type == voidPtrType
            or rhs->types.orig_type == voidPtrType
        )
    )

    if (
        (
            (not got_bools)
            and (not got_numbers)
            and (not got_enums)
            and (not got_pointers)
        ) or (
            (got_bools or got_enums)
            and op != AstExpressionKind.Eq
            and op != AstExpressionKind.Ne
        ) or (
            got_pointers
            and op != AstExpressionKind.Eq
            and op != AstExpressionKind.Ne
            and op != AstExpressionKind.Gt
            and op != AstExpressionKind.Ge
            and op != AstExpressionKind.Lt
            and op != AstExpressionKind.Le
        )
    ):
        msg: byte[500]
        snprintf(msg, sizeof(msg), "wrong types: cannot %s %s and %s", do_what, lhs->types.orig_type->name, rhs->types.orig_type->name)
        fail(location, msg)

    cast_type: Type* = NULL
    if got_bools:
        cast_type = boolType
    if got_integers:
        cast_type = get_integer_type(
            max(lhs->types.orig_type->size_in_bits, rhs->types.orig_type->size_in_bits),
            lhs->types.orig_type->kind == TypeKind.SignedInteger or rhs->types.orig_type->kind == TypeKind.SignedInteger
        )
    if got_numbers and not got_integers:
        if lhs->types.orig_type == doubleType or rhs->types.orig_type == doubleType:
            cast_type = doubleType
        else:
            cast_type = floatType
    if got_pointers:
        cast_type = get_integer_type(64, False)
    if got_enums:
        cast_type = intType
    assert cast_type != NULL

    do_implicit_cast(fom, lhs, cast_type, Location{}, NULL)
    do_implicit_cast(fom, rhs, cast_type, Location{}, NULL)

    match op:
        case (
            AstExpressionKind.Add
            | AstExpressionKind.Sub
            | AstExpressionKind.Mul
            | AstExpressionKind.Div
            | AstExpressionKind.Mod
        ):
            return cast_type
        case (
            AstExpressionKind.Eq
            | AstExpressionKind.Ne
            | AstExpressionKind.Gt
            | AstExpressionKind.Ge
            | AstExpressionKind.Lt
            | AstExpressionKind.Le
        ):
            return boolType
        case _:
            assert False


def check_increment_or_decrement(state: State*, expr: AstExpression*) -> Type*:
    bad_type_fmt, bad_expr_fmt: byte*

    match expr->kind:
        case AstExpressionKind.PreIncr | AstExpressionKind.PostIncr:
            bad_type_fmt = "cannot increment a value of type %s"
            bad_expr_fmt = "cannot increment %s"
        case AstExpressionKind.PreDecr | AstExpressionKind.PostDecr:
            bad_type_fmt = "cannot decrement a value of type %s"
            bad_expr_fmt = "cannot decrement %s"
        case _:
            assert False

    t = typecheck_expression_not_void(state, &expr->operands[0], NULL)
    if not t->is_number_type() and t->kind != TypeKind.Pointer:
        msg: byte[500]
        snprintf(msg, sizeof(msg), bad_type_fmt, t->name)
        fail(expr->location, msg)

    ensure_can_take_address(state->fom_types, &expr->operands[0], bad_expr_fmt)
    return t


def typecheck_dereferenced_pointer(location: Location, t: Type*) -> None:
    # TODO: improved error message for dereferencing void*
    if t->kind != TypeKind.Pointer:
        msg: byte[500]
        snprintf(msg, sizeof(msg), "the dereference operator '*' is only for pointers, not for %s", t->name)
        fail(location, msg)


# ptr[index]
def typecheck_indexing(
    state: State*,
    ptrexpr: AstExpression*,
    indexexpr: AstExpression*,
) -> Type*:
    msg: byte[500]

    orig_type = typecheck_expression_not_void(state, ptrexpr, NULL)
    match orig_type->kind:
        case TypeKind.Pointer:
            ptrtype = orig_type
        case TypeKind.Array:
            cast_array_to_pointer(state->fom_types, ptrexpr)
            ptrtype = ptrexpr->types.implicit_cast_type
        case _:
            snprintf(msg, sizeof(msg), "value of type %s cannot be indexed", orig_type->name)
            fail(ptrexpr->location, msg)

    assert ptrtype != NULL
    assert ptrtype->kind == TypeKind.Pointer

    indextype = typecheck_expression_not_void(state, indexexpr, NULL)
    assert indextype != NULL
    if not indextype->is_integer_type():
        snprintf(msg, sizeof(msg), "the index inside [...] must be an integer, not %s", indextype->name)
        fail(indexexpr->location, msg)

    # LLVM assumes that indexes smaller than 64 bits are signed.
    # https://github.com/Akuli/jou/issues/48
    do_implicit_cast(state->fom_types, indexexpr, longType, Location{}, NULL)

    return ptrtype->value_type


def typecheck_and_or(
    state: State*,
    lhsexpr: AstExpression*,
    rhsexpr: AstExpression*,
    and_or: byte*,
) -> None:
    assert strcmp(and_or, "and") == 0 or strcmp(and_or, "or") == 0

    errormsg: byte[100]
    snprintf(errormsg, sizeof(errormsg), "'%s' only works with bools, not <from>", and_or)

    typecheck_expression_with_implicit_cast(state, lhsexpr, boolType, errormsg)
    typecheck_expression_with_implicit_cast(state, rhsexpr, boolType, errormsg)


def nth(n: int) -> byte[100]:
    result: byte[100]

    assert n >= 1
    first_few = [NULL, "first", "second", "third", "fourth", "fifth", "sixth"]
    if n < sizeof(first_few) / sizeof(first_few[0]):
        strcpy(result, first_few[n])
    else:
        sprintf(result, "%dth", n)

    return result


# returns NULL if the function doesn't return anything, otherwise non-owned pointer to non-owned type
def typecheck_function_or_method_call(state: State*, call: AstCall*, self_type: Type*, location: Location) -> Type*:
    msg: byte[500]

    if self_type == NULL:
        sig = state->file_types->find_function(call->name)
        if sig == NULL:
            snprintf(msg, sizeof(msg), "function '%s' not found", call->name)
            fail(location, msg)
    else:
        assert self_type->kind == TypeKind.Class
        sig = self_type->find_method(call->name)
        if sig == NULL:
            snprintf(
                msg, sizeof(msg),
                "class %s does not have a method named '%s'", self_type->name, call->name)
            fail(location, msg)

    call->called_signature = sig

    if self_type == NULL:
        function_or_method = "function"
    else:
        function_or_method = "method"

    sig_string = sig->to_string(False, False)

    nargs = sig->nargs
    if self_type != NULL:
        nargs--

    if call->args.len < nargs or (call->args.len > nargs and not sig->takes_varargs):
        snprintf(
            msg, sizeof(msg),
            "%s %s takes %d argument%s, but it was called with %lld argument%s",
            function_or_method,
            sig_string,
            nargs,
            plural_s(nargs),
            call->args.len,
            plural_s(call->args.len),
        )
        fail(location, msg)

    k = 0
    selfless_counter = 0
    for i = 0; i < sig->nargs; i++:
        if strcmp(sig->argnames[i], "self") == 0:
            continue
        # This is a common error, so worth spending some effort to get a good error message.
        which_arg = nth(++selfless_counter)
        snprintf(
            msg, sizeof msg,
            "%s argument of %s %s should have type <to>, not <from>", which_arg, function_or_method, sig_string
        )
        typecheck_expression_with_implicit_cast(state, &call->args.ptr[k++], sig->argtypes[i], msg)

    for vararg = &call->args.ptr[k]; vararg < call->args.end(); vararg++:
        # This code runs for varargs, e.g. the things to format in printf().
        t = typecheck_expression_not_void(state, vararg, NULL)
        if t->kind == TypeKind.Array:
            cast_array_to_pointer(state->fom_types, vararg)
        elif (t->is_integer_type() and t->size_in_bits < 32) or t == boolType:
            # Add implicit cast to signed int, just like in C.
            do_implicit_cast(state->fom_types, vararg, intType, Location{}, NULL)
        elif t == floatType:
            do_implicit_cast(state->fom_types, vararg, doubleType, Location{}, NULL)
        elif t->kind == TypeKind.Enum:
            snprintf(
                msg, sizeof(msg),
                "enums cannot be passed to functions that take variadic arguments, such as %s",
                sig->name,
            )
            fail(vararg->location, msg)

    free(sig_string)
    return sig->return_type


def typecheck_class_field(
    classtype: Type*,
    fieldname: byte*,
    location: Location,
) -> ClassField*:
    assert classtype->kind == TypeKind.Class
    f = classtype->find_class_field(fieldname)
    if f != NULL:
        return f

    msg: byte[500]
    snprintf(msg, sizeof(msg), "class %s has no field named '%s'", classtype->name, fieldname)
    fail(location, msg)


def typecheck_instantiation(state: State*, inst: AstInstantiation*, location: Location) -> Type*:
    t = type_from_ast(state->file_types, state->fom_types->signature.get_self_class(), &inst->type)

    msg: byte[500]

    if t->kind != TypeKind.Class:
        snprintf(
            msg, sizeof(msg),
            "the %s{...} syntax is only for classes, but %s is %s",
            t->name, t->name, t->short_description())
        fail(location, msg)

    specified_fields = List[ClassField*]{}
    for f = inst->fields.ptr; f < inst->fields.end(); f++:
        field = typecheck_class_field(t, f->name, f->value.location)

        snprintf(msg, sizeof msg,
            "value for field '%s' of class %s must be of type <to>, not <from>",
            f->name, t->name)
        typecheck_expression_with_implicit_cast(state, &f->value, field->type, msg)
        specified_fields.append(&field, sizeof(field))

    for i1 = 0; i1 < inst->fields.len; i1++:
        for i2 = i1+1; i2 < inst->fields.len; i2++:
            if specified_fields.ptr[i1]->union_id == specified_fields.ptr[i2]->union_id:
                snprintf(msg, sizeof(msg),
                    "fields '%s' and '%s' cannot be set simultaneously because they belong to the same union",
                    specified_fields.ptr[i1]->name, specified_fields.ptr[i2]->name)
                fail(inst->fields.ptr[i2].value.location,msg)

    specified_fields.clear()
    return t


def cast_array_members_to_a_common_type(
    fom: FunctionOrMethodTypes*,
    error_location: Location,
    array: List[AstExpression],
    item_type_hint: Type*,
) -> Type*:
    if item_type_hint != NULL:
        for p = array.ptr; p < array.end(); p++:
            do_implicit_cast(fom, p, item_type_hint, error_location, "array items should be of type <to>, not <from>")
        return item_type_hint

    # Avoid O(ntypes^2) code in a long array where all or almost all items have the same type.
    # This is at most O(ntypes*k) where k is the number of distinct types.
    distinct = List[Type*]{}

    for p = array.ptr; p < array.end(); p++:
        itemtype = p->types.orig_type
        assert itemtype != NULL

        found = False
        for t = distinct.ptr; t < distinct.end(); t++:
            if itemtype == *t:
                found = True
                break
        if not found:
            distinct.append(&itemtype, sizeof(itemtype))

    compatible_with_all = List[Type*]{}

    for t = distinct.ptr; t < distinct.end(); t++:
        t_compatible_with_all_others = True
        for t2 = distinct.ptr; t2 < distinct.end(); t2++:
            if not can_cast_implicitly(*t2, *t):
                t_compatible_with_all_others = False
                break

        if t_compatible_with_all_others:
            compatible_with_all.append(t, sizeof(*t))

    if compatible_with_all.len > 1:
        # Remove void* if exists, so that type of ["hello", NULL] becomes byte*[2]
        for i = 0; i < compatible_with_all.len; i++:
            if compatible_with_all.ptr[i] == voidPtrType:
                compatible_with_all.ptr[i] = compatible_with_all.ptr[--compatible_with_all.len]
                break

    if compatible_with_all.len != 1:
        size = 500L
        for t = distinct.ptr; t < distinct.end(); t++:
            size += strlen((*t)->name) + 3  # 1 for comma, 1 for space, 1 because why not lol

        msg: byte* = malloc(size)
        assert msg != NULL

        strcpy(msg, "array items have different types (")
        for t = distinct.ptr; t < distinct.end(); t++:
            if t != distinct.ptr:
                strcat(msg, ", ")
            strcat(msg, (*t)->name)
        strcat(msg, ")")
        fail(error_location, msg)

    elemtype = compatible_with_all.ptr[0]
    distinct.clear()
    compatible_with_all.clear()

    for p = array.ptr; p < array.end(); p++:
        do_implicit_cast(fom, p, elemtype, error_location, NULL)
    return elemtype


# The AST "foo.bar" may be:
#   - field "bar" of an instance of some class stored to variable "foo"
#   - member "bar" of enum "foo"
#
# The parser assumes it is always a field on an instance, because it's more
# general: "foo" can be any expression, not necessarily enum name.
#
# This function modifies the AST so that it sometimes changes from accessing
# class fields to accessing enum members. This cannot be done in the parser
# because it doesn't know what enums exist (they may be e.g. imported from
# other files). Feels like a hack, but works great :)
def handle_conflicting_class_field_and_enum_member_syntax(state: State*, expr: AstExpression*) -> None:
    if expr->kind != AstExpressionKind.GetClassField:
        # not foo.bar
        return

    if expr->class_field.instance->kind != AstExpressionKind.GetVariable:
        # the "foo" part is something more complicated than a variable name
        return

    enum_name: byte[100] = expr->class_field.instance->varname
    member_name: byte[100] = expr->class_field.field_name

    if state->find_any_var(enum_name) != NULL:
        # there is a variable named "foo", use that
        return

    t = state->file_types->find_type(expr->class_field.instance->varname)
    if t == NULL:
        # no enum or variable, show variable not found error
        return

    if t->kind != TypeKind.Enum:
        # attempting to do Foo.bar, where Foo is a type but not enum type
        if t->kind == TypeKind.Class:
            fail(expr->location, "class members cannot be accessed directly on the class, they only exist on instances")
        else:
            # TODO: Currently this cannot happen. Built-in types like "int" are
            # keywords so that they cannot appear as expressions. A test should
            # be added if this becomes possible in the future.
            msg: byte[500]
            snprintf(
                msg, sizeof(msg),
                "type '%s' has no members because it is not a class or an enum",
                enum_name,
            )
            fail(expr->location, msg)

    if expr->class_field.uses_arrow_operator:
        fail(expr->location, "the '->' operator cannot be used to look up enum members")

    free(expr->class_field.instance)
    expr->kind = AstExpressionKind.GetEnumMember
    expr->enum_member = AstEnumMember{
        enum_name = enum_name,
        member_name = member_name,
    }


def typecheck_expression(state: State*, expr: AstExpression*, type_hint: Type*) -> None:
    msg: byte[500]
    result: Type* = NULL

    handle_conflicting_class_field_and_enum_member_syntax(state, expr)

    match expr->kind:
        case AstExpressionKind.Constant:
            # Use array string if type hint given, e.g. foo: byte[100] = "hello"
            if (
                expr->constant.kind == ConstantKind.PointerString
                and type_hint != NULL
                and type_hint->kind == TypeKind.Array
                and type_hint->array.item_type == byteType
            ):
                s = expr->constant.pointer_string
                if strlen(s) >= type_hint->array.len:
                    snprintf(msg, sizeof(msg), "a string of %lld bytes (including '\\0') does not fit into %s", strlen(s) + 1, type_hint->name)
                    fail(expr->location, msg)
                expr->constant.kind = ConstantKind.ArrayString
                expr->constant.array_string.str = s
                expr->constant.array_string.array_size = type_hint->array.len
                assert expr->constant.get_type() == type_hint
                result = type_hint
            else:
                result = expr->constant.get_type()

        case AstExpressionKind.GetEnumMember:
            result = state->file_types->find_type(expr->enum_member.enum_name)
            # AstExpressionKind.GetEnumMember is only created if the enum exists
            assert result != NULL
            assert result->kind == TypeKind.Enum
            if result->find_enum_member(expr->enum_member.member_name) == -1:
                snprintf(
                    msg, sizeof(msg),
                    "enum %s has no member named '%s'",
                    expr->enum_member.enum_name, expr->enum_member.member_name)
                fail(expr->location, msg)

        case AstExpressionKind.SizeOf:
            if (
                expr->operands[0].kind == AstExpressionKind.Constant
                and expr->operands[0].constant.kind == ConstantKind.PointerString
            ):
                # sizeof("foo") should be 4
                obj_type_hint = byteType->array_type((strlen(expr->operands[0].constant.pointer_string) as int) + 1)
            else:
                obj_type_hint = NULL
            typecheck_expression_not_void(state, &expr->operands[0], obj_type_hint)
            result = longType

        case AstExpressionKind.Instantiate:
            result = typecheck_instantiation(state, &expr->instantiation, expr->location)

        case AstExpressionKind.Array:
            if type_hint != NULL and type_hint->kind == TypeKind.Array:
                item_type_hint = type_hint->array.item_type
            else:
                item_type_hint = NULL
            n = expr->array.len
            for i = 0; i < n; i++:
                typecheck_expression_not_void(state, &expr->array.ptr[i], item_type_hint)
            membertype = cast_array_members_to_a_common_type(state->fom_types, expr->location, expr->array, item_type_hint)
            result = membertype->array_type(n as int)

        case AstExpressionKind.GetClassField:
            if expr->class_field.uses_arrow_operator:
                temptype = typecheck_expression_not_void(state, expr->class_field.instance, NULL)
                if temptype->kind != TypeKind.Pointer or temptype->value_type->kind != TypeKind.Class:
                    snprintf(
                        msg, sizeof(msg),
                        "left side of '->' operator must be a pointer to an instance of a class, not %s",
                        temptype->name)
                    if temptype->kind == TypeKind.Class and strlen(msg) + 50 < sizeof(msg):
                        strcat(msg, " (try . instead of ->)")
                    fail(expr->location, msg)
                result = typecheck_class_field(temptype->value_type, expr->class_field.field_name, expr->location)->type
            else:
                temptype = typecheck_expression_not_void(state, expr->class_field.instance, NULL)
                if temptype->kind != TypeKind.Class:
                    snprintf(
                        msg, sizeof(msg),
                        "left side of '.' operator must be an instance of a class, not %s",
                        temptype->name)
                    if (
                        temptype->kind == TypeKind.Pointer
                        and temptype->value_type->kind == TypeKind.Class
                        and strlen(msg) + 50 < sizeof(msg)
                    ):
                        strcat(msg, " (try -> instead of .)")
                    fail(expr->location, msg)
                result = typecheck_class_field(temptype, expr->class_field.field_name, expr->location)->type

        case AstExpressionKind.Call:
            if expr->call.method_call_self == NULL:
                result = typecheck_function_or_method_call(state, &expr->call, NULL, expr->location)
            elif expr->call.uses_arrow_operator:
                temptype = typecheck_expression_not_void(state, expr->call.method_call_self, NULL)
                if temptype->kind != TypeKind.Pointer or temptype->value_type->kind != TypeKind.Class:
                    snprintf(msg, sizeof(msg),
                        "left side of '->' operator must be a pointer to an instance of a class, not %s",
                        temptype->name)
                    if temptype->kind == TypeKind.Class and strlen(msg) + 50 < sizeof(msg):
                        strcat(msg, " (try . instead of ->)")
                    fail(expr->location, msg)
                result = typecheck_function_or_method_call(state, &expr->call, temptype->value_type, expr->location)
            else:
                temptype = typecheck_expression_not_void(state, expr->call.method_call_self, NULL)
                if temptype->kind != TypeKind.Class:
                    snprintf(msg, sizeof(msg),
                        "left side of '.' operator must be an instance of a class, not %s",
                        temptype->name)
                    if (
                        temptype->kind == TypeKind.Pointer
                        and temptype->value_type->kind == TypeKind.Class
                        and strlen(msg) + 50 < sizeof(msg)
                    ):
                        strcat(msg, " (try -> instead of .)")
                    fail(expr->location, msg)

                result = typecheck_function_or_method_call(state, &expr->call, temptype, expr->location)

                # If self argument is passed by pointer, make sure we can create that pointer
                assert temptype->kind == TypeKind.Class
                signature = temptype->find_method(expr->call.name)
                assert signature != NULL
                if signature->argtypes[0]->is_pointer_type():
                    assert strstr(expr->call.name, "%") == NULL
                    snprintf(
                        msg, sizeof msg,
                        "cannot take address of %%s, needed for calling the %s() method",
                        expr->call.name)
                    ensure_can_take_address(state->fom_types, expr->call.method_call_self, msg)

            if result == NULL:
                # no return value produced
                return

        case AstExpressionKind.Indexing:
            result = typecheck_indexing(state, &expr->operands[0], &expr->operands[1])

        case AstExpressionKind.AddressOf:
            result = typecheck_expression_not_void(state, &expr->operands[0], NULL)->pointer_type()
            ensure_can_take_address(state->fom_types, &expr->operands[0], "the '&' operator cannot be used with %s")

        case AstExpressionKind.GetVariable:
            result = state->find_any_constant(expr->varname)
            if result != NULL:
                # Transform the expression into a constant
                expr->kind = AstExpressionKind.Constant
                match get_special_constant(expr->varname):
                    case 1:
                        expr->constant = Constant{kind = ConstantKind.Bool, boolean = True}
                    case 0:
                        expr->constant = Constant{kind = ConstantKind.Bool, boolean = False}
                    case -1:
                        expr->constant = state->file_types->find_constant(expr->varname)->copy()
                    case _:
                        assert False
            else:
                # Not a constant, proceed with normal variable lookup
                result = state->find_any_var(expr->varname)
                if result == NULL:
                    snprintf(msg, sizeof(msg), "no variable named '%s'", expr->varname)
                    fail(expr->location, msg)

        case AstExpressionKind.Self:
            selfvar = state->fom_types->find_local_var("self")
            assert selfvar != NULL
            result = selfvar->type

        case AstExpressionKind.Dereference:
            temptype = typecheck_expression_not_void(state, &expr->operands[0], NULL)
            typecheck_dereferenced_pointer(expr->location, temptype)
            result = temptype->value_type

        case AstExpressionKind.And:
            typecheck_and_or(state, &expr->operands[0], &expr->operands[1], "and")
            result = boolType

        case AstExpressionKind.Or:
            typecheck_and_or(state, &expr->operands[0], &expr->operands[1], "or")
            result = boolType

        case AstExpressionKind.Not:
            typecheck_expression_with_implicit_cast(
                state, &expr->operands[0], boolType,
                "value after 'not' must be a bool, not <from>")
            result = boolType

        case AstExpressionKind.Negate:
            result = typecheck_expression_not_void(state, &expr->operands[0], NULL)
            if result->kind != TypeKind.SignedInteger and result->kind != TypeKind.FloatingPoint:
                snprintf(msg, sizeof(msg),
                    "value after '-' must be a float or double or a signed integer, not %s",
                    result->name)
                fail(expr->location, msg)

        case (
            AstExpressionKind.Add
            | AstExpressionKind.Sub
            | AstExpressionKind.Mul
            | AstExpressionKind.Div
            | AstExpressionKind.Mod
            | AstExpressionKind.Eq
            | AstExpressionKind.Ne
            | AstExpressionKind.Gt
            | AstExpressionKind.Ge
            | AstExpressionKind.Lt
            | AstExpressionKind.Le
        ):
            typecheck_expression_not_void(state, &expr->operands[0], NULL)
            typecheck_expression_not_void(state, &expr->operands[1], NULL)
            result = check_binop(state->fom_types, expr->kind, expr->location, &expr->operands[0], &expr->operands[1])

        case (
            AstExpressionKind.PreIncr
            | AstExpressionKind.PreDecr
            | AstExpressionKind.PostIncr
            | AstExpressionKind.PostDecr
        ):
            result = check_increment_or_decrement(state, expr)

        case AstExpressionKind.As:
            result = type_from_ast(state->file_types, state->fom_types->signature.get_self_class(), &expr->as_->type)
            typecheck_expression_not_void(state, &expr->as_->value, result)

            # Special case: `"foo" as byte[100]` is not really a cast. It sets
            # the type of the string through a type hint and it's already
            # byte[100]. If we try to cast it anyway, there will be a warning
            # about "unnecessary" cast.
            special_case = (
                expr->as_->value.kind == AstExpressionKind.Constant
                and expr->as_->value.constant.kind == ConstantKind.ArrayString
                and result == expr->as_->value.constant.get_type()
            )
            if not special_case:
                do_explicit_cast(state->fom_types, &expr->as_->value, result, expr->location)

        case _:
            printf("%d\n", expr->kind as int)
            assert False

    assert result != NULL
    expr->types.orig_type = result
    expr->types.implicit_cast_type = result  # by default, no implicit cast


def typecheck_body(state: State*, body: AstBody*) -> None:
    for i = 0; i < body->nstatements; i++:
        typecheck_statement(state, &body->statements[i])


def typecheck_if_statement(state: State*, ifstmt: AstIfStatement*) -> None:
    for p = ifstmt->if_and_elifs.ptr; p < ifstmt->if_and_elifs.end(); p++:
        if p == ifstmt->if_and_elifs.ptr:
            errmsg = "'if' condition must be a bool, not <from>"
        else:
            errmsg = "'elif' condition must be a bool, not <from>"

        typecheck_expression_with_implicit_cast(state, &p->condition, boolType, errmsg)
        typecheck_body(state, &p->body)

    typecheck_body(state, &ifstmt->else_body)


def typecheck_match_statement(state: State*, match_stmt: AstMatchStatement*) -> None:
    msg: byte[500]
    sig_string: byte* = NULL
    remaining: byte** = NULL
    nremaining = -1

    if match_stmt->func_name[0] == '\0':
        case_type = typecheck_expression_not_void(state, &match_stmt->match_obj, NULL)

        match case_type->kind:
            case TypeKind.SignedInteger | TypeKind.UnsignedInteger:
                # no special handling needed
                pass
            case TypeKind.Enum:
                # Ensure user checks all possible enum values
                nremaining = case_type->enum_members.count
                remaining = malloc(sizeof(remaining[0]) * nremaining)
                assert remaining != NULL
                for i = 0; i < nremaining; i++:
                    remaining[i] = case_type->enum_members.names[i]
            case _:
                snprintf(msg, sizeof(msg), "cannot match a value of type %s", case_type->name)
                if strlen(msg) + 100 < sizeof(msg):
                    if case_type == byteType->pointer_type():
                        strcat(msg, " (try adding 'with strcmp')")
                    if case_type == boolType:
                        strcat(msg, " (use if/else instead)")
                fail(match_stmt->match_obj.location, msg)
    else:
        sig = state->file_types->find_function(match_stmt->func_name)
        if sig == NULL:
            snprintf(msg, sizeof(msg), "function '%s' not found", match_stmt->func_name)
            fail(match_stmt->match_obj.location, msg)
        match_stmt->func_signature = sig->copy()

        # Most of the time, only argument types are relevant, so don't include the return type into sig_string.
        sig_string = sig->to_string(False, False)

        if sig->nargs != 2 or sig->return_type != intType or sig->takes_varargs:  # TODO: could be more general
            if sig->return_type != intType:
                # show return type in error message
                sig_string = sig->to_string(True, False)
            snprintf(msg, sizeof(msg), "cannot match with function %s", sig_string)
            fail(match_stmt->match_obj.location, msg)

        snprintf(msg, sizeof(msg), "cannot match <from> with %s", sig_string)
        typecheck_expression_with_implicit_cast(state, &match_stmt->match_obj, sig->argtypes[0], msg)
        case_type = sig->argtypes[1]

    for c = match_stmt->cases.ptr; c < match_stmt->cases.end(); c++:
        for case_obj = c->case_objs.ptr; case_obj < c->case_objs.end(); case_obj++:
            if sig_string == NULL:
                msg = "case value of type <from> cannot be matched against <to>"
            else:
                snprintf(msg, sizeof(msg), "case value cannot be <from> when matching with %s", sig_string)
            typecheck_expression_with_implicit_cast(state, case_obj, case_type, msg)

            if nremaining != -1:
                if case_obj->kind != AstExpressionKind.GetEnumMember:
                    # Matching an enum but it's too dynamic, not simply TheEnum.Member
                    snprintf(msg, sizeof(msg), "'case' value must be %s.something when matching a value of enum %s", case_type->name, case_type->name)
                    fail(case_obj->location, msg)
                # We are matching against TheEnum.member. Try to find and remove it from remaining members.
                member = case_obj->enum_member.member_name
                found = False
                for k = 0; k < nremaining; k++:
                    if strcmp(remaining[k], member) == 0:
                        memmove(&remaining[k], &remaining[k+1], sizeof(remaining[0]) * (--nremaining - k))
                        found = True
                        break

                if not found:
                    snprintf(msg, sizeof(msg), "enum member %s is handled twice", member)
                    fail(case_obj->location, msg)

        typecheck_body(state, &c->body)

    # Do not complain if there is a seemingly unnecessary 'case _', because it
    # may be ran by casting an integer to enum with 'as'. However, we can
    # complain if handling for enum members is missing.
    if nremaining > 0 and match_stmt->case_underscore == NULL:
        if nremaining == 1:
            snprintf(
                msg, sizeof(msg),
                "enum member %s.%s not handled in match statement",
                case_type->name, remaining[0],
            )
        else:
            snprintf(
                msg, sizeof(msg) - 20,
                "the following %d members of enum %s are not handled in match statement: ",
                nremaining, case_type->name,
            )
            for i = 0; i < nremaining; i++:
                assert sizeof(msg) > 300
                if strlen(msg) + strlen(remaining[i]) < 200:
                    strcat(msg, remaining[i])
                    strcat(msg, ", ")
                else:
                    strcat(msg, "...")
                    break
            if ends_with(msg, ", "):
                msg[strlen(msg) - 2] = '\0'

        fail(match_stmt->match_obj.location, msg)

    free(sig_string)
    free(remaining)

    if match_stmt->case_underscore != NULL:
        typecheck_body(state, match_stmt->case_underscore)


def typecheck_statement(state: State*, stmt: AstStatement*) -> None:
    msg: byte[500]

    match stmt->kind:
        case AstStatementKind.If:
            typecheck_if_statement(state, &stmt->if_statement)

        case AstStatementKind.WhileLoop:
            typecheck_expression_with_implicit_cast(
                state, &stmt->while_loop.condition, boolType,
                "'while' condition must be a bool, not <from>")
            typecheck_body(state, &stmt->while_loop.body)

        case AstStatementKind.ForLoop:
            if stmt->for_loop.init != NULL:
                typecheck_statement(state, stmt->for_loop.init)
            if stmt->for_loop.cond != NULL:
                typecheck_expression_with_implicit_cast(
                    state, stmt->for_loop.cond, boolType,
                    "'for' condition must be a bool, not <from>")
            typecheck_body(state, &stmt->for_loop.body)
            if stmt->for_loop.incr != NULL:
                typecheck_statement(state, stmt->for_loop.incr)

        case AstStatementKind.Match:
            typecheck_match_statement(state, &stmt->match_statement)

        case AstStatementKind.Break | AstStatementKind.Continue | AstStatementKind.Pass:
            pass

        case AstStatementKind.Assign:
            targetexpr = &stmt->assignment.target
            valueexpr = &stmt->assignment.value

            if (
                targetexpr->kind == AstExpressionKind.GetVariable
                and state->find_any_var_or_constant(targetexpr->varname) == NULL
            ):
                # Making a new variable. Use the type of the value being assigned.
                type = typecheck_expression_not_void(state, valueexpr, NULL)
                state->fom_types->add_variable(type, targetexpr->varname)
            else:
                # Convert value to the type of an existing variable or other assignment target.
                targettype = typecheck_expression_not_void(state, targetexpr, NULL)
                ensure_can_take_address(state->fom_types, targetexpr, "cannot assign to %s")

                if targetexpr->kind == AstExpressionKind.Dereference:
                    msg = "cannot place a value of type <from> into a pointer of type <to>*"
                else:
                    desc = short_expression_description(targetexpr)
                    snprintf(msg, sizeof msg, "cannot assign a value of type <from> to %s of type <to>", desc)
                typecheck_expression_with_implicit_cast(state, valueexpr, targettype, msg)

        case (
            AstStatementKind.InPlaceAdd
            | AstStatementKind.InPlaceSub
            | AstStatementKind.InPlaceMul
            | AstStatementKind.InPlaceDiv
            | AstStatementKind.InPlaceMod
        ):
            targetexpr = &stmt->assignment.target
            valueexpr = &stmt->assignment.value

            targettype = typecheck_expression_not_void(state, targetexpr, NULL)
            value_type = typecheck_expression_not_void(state, valueexpr, NULL)
            ensure_can_take_address(state->fom_types, targetexpr, "cannot assign to %s")

            match stmt->kind:
                case AstStatementKind.InPlaceAdd:
                    op = AstExpressionKind.Add
                    opname = "addition"
                case AstStatementKind.InPlaceSub:
                    op = AstExpressionKind.Sub
                    opname = "subtraction"
                case AstStatementKind.InPlaceMul:
                    op = AstExpressionKind.Mul
                    opname = "multiplication"
                case AstStatementKind.InPlaceDiv:
                    op = AstExpressionKind.Div
                    opname = "division"
                case AstStatementKind.InPlaceMod:
                    op = AstExpressionKind.Mod
                    opname = "modulo"
                case _:
                    assert False

            t = check_binop(state->fom_types, op, stmt->location, targetexpr, valueexpr)
            if t != targetexpr->types.orig_type:
                snprintf(
                    msg, sizeof msg,
                    "%s produced a value of type %s which cannot be assigned back to %s",
                    opname, t->name, targetexpr->types.orig_type->name
                )
                fail(stmt->location, msg)

        case AstStatementKind.Return:
            function_or_method = state->fom_types->signature.function_or_method()

            if state->fom_types->signature.is_noreturn:
                snprintf(
                    msg, sizeof(msg),
                    "%s '%s' cannot return because it was defined with '-> noreturn'",
                    function_or_method, state->fom_types->signature.name,
                )
                fail(stmt->location, msg)

            return_type = state->fom_types->signature.return_type

            if stmt->return_value != NULL and return_type == NULL:
                snprintf(
                    msg, sizeof(msg), "%s '%s' cannot return a value because it was defined with '-> None'",
                    function_or_method, state->fom_types->signature.name,
                )
                fail(stmt->location, msg)

            if return_type != NULL and stmt->return_value == NULL:
                snprintf(msg, sizeof(msg),
                    "a return value is needed, because the return type of %s '%s' is %s",
                    function_or_method,
                    state->fom_types->signature.name,
                    state->fom_types->signature.return_type->name)
                fail(stmt->location, msg)

            if stmt->return_value != NULL:
                snprintf(msg, sizeof msg,
                    "attempting to return a value of type <from> from %s '%s' defined with '-> <to>'",
                    function_or_method, state->fom_types->signature.name)
                typecheck_expression_with_implicit_cast(state, stmt->return_value, return_type, msg)

        case AstStatementKind.DeclareLocalVar:
            varname = stmt->local_var_declare.name

            if state->find_any_var(varname) != NULL:
                snprintf(msg, sizeof(msg), "a variable named '%s' already exists", varname)
                fail(stmt->location, msg)

            if state->find_any_constant(varname) != NULL:
                snprintf(msg, sizeof(msg), "a constant named '%s' already exists", varname)
                fail(stmt->location, msg)

            type = type_from_ast(state->file_types, state->fom_types->signature.get_self_class(), &stmt->local_var_declare.type)
            state->fom_types->add_variable(type, varname)

            if stmt->local_var_declare.value != NULL:
                typecheck_expression_with_implicit_cast(
                    state, stmt->local_var_declare.value, type,
                    "initial value for variable of type <to> cannot be of type <from>")

        case AstStatementKind.ExpressionStatement:
            typecheck_expression(state, &stmt->expression, NULL)

        case AstStatementKind.Assert:
            typecheck_expression_with_implicit_cast(state, &stmt->expression, boolType, "assertion must be a bool, not <from>")

        case (
            AstStatementKind.FunctionDeclare
            | AstStatementKind.FunctionDef
            | AstStatementKind.MethodDef
            | AstStatementKind.Class
            | AstStatementKind.ClassField
            | AstStatementKind.ClassUnion
            | AstStatementKind.Enum
            | AstStatementKind.GlobalVariableDeclare
            | AstStatementKind.GlobalVariableDef
            | AstStatementKind.Import
            | AstStatementKind.Link
            | AstStatementKind.Const
        ):
            assert False


def typecheck_function_or_method_body(state: State*, fom: AstFunctionOrMethod*) -> None:
    assert state->fom_types == NULL
    state->fom_types = &fom->types

    sig = &fom->types.signature
    for i = 0; i < sig->nargs; i++:
        state->fom_types->add_variable(sig->argtypes[i], sig->argnames[i])

    typecheck_body(state, &fom->body)
    state->fom_types = NULL


@public
def typecheck_step3_function_and_method_bodies(ast: AstFile*) -> None:
    state = State{file_types = &ast->types}

    for i = 0; i < ast->body.nstatements; i++:
        stmt = &ast->body.statements[i]
        match stmt->kind:
            case AstStatementKind.FunctionDef:
                typecheck_function_or_method_body(&state, &stmt->function)
            case AstStatementKind.Class:
                for inner = stmt->classdef.body->statements; inner < &stmt->classdef.body->statements[stmt->classdef.body->nstatements]; inner++:
                    if inner->kind == AstStatementKind.MethodDef:
                        typecheck_function_or_method_body(&state, &inner->method)
            case _:
                pass
