import "stdlib/io.jou"
import "stdlib/str.jou"
import "stdlib/mem.jou"


enum UvgInstructionKind:
    Set                 # value = something_doesnt_matter_what
    Use                 # do_something(value)
    SetToAddressOf      # set first value to address of second value (first = &second)
    SetValueOfPointer   # *value = something_doesnt_matter_what

class UvgInstruction:
    #location: Location
    kind: UvgInstructionKind
    union:
        value_id: int       # Set, Use, SetValueOfPointer
        value_ids: int[2]   # SetToAddressOf


class UvgBranch:
    cond_value_id: int  # which value is the branch true/false condition
    then: UvgBlock*
    otherwise: UvgBlock*


enum UvgTerminatorKind:
    NotSet  # must be first so it's zero memory
    Jump
    Branch
    Return
    ExitProgram

class UvgTerminator:
    kind: UvgTerminatorKind
    union:
        jump_block: UvgBlock*   # UvgTerminatorKind.Jump
        branch: UvgBranch       # UvgTerminatorKind.Branch


class UvgBlock:
    instructions: UvgInstruction*
    ninstructions: int
    terminator: UvgTerminator

    def free(self) -> None:
        free(self->instructions)


# We build one UVG for each function.
class Uvg:
    name: byte[200]

    # Each block is allocated separately so that we can pass them around as
    # pointers, and they don't become invalid when adding more blocks.
    blocks: UvgBlock**
    nblocks: int

    # Each variable name points to something within the AST. We won't free() them.
    varnames: byte**
    n_values: int

    def free(self) -> None:
        for i = 0; i < self->nblocks; i++:
            self->blocks[i]->free()
            free(self->blocks[i])
        free(self->blocks)
        free(self->varnames)

    def index_of_block(self, b: UvgBlock*) -> int:
        for i = 0; i < self->nblocks; i++:
            if self->blocks[i] == b:
                return i
        assert False

    # Prints variable name or e.g. "$6"
    def print_value_id(self, value_id: int) -> None:
        assert 0 <= value_id and value_id < self->n_values
        if self->varnames[value_id] == NULL:
            printf("$%d", value_id)
        else:
            printf("%s", self->varnames[value_id])

    def print(self) -> None:
        printf("===== UVG for %s =====\n", self->name)

        assert self->nblocks > 0

        for i = 0; i < self->nblocks; i++:
            if i == 0:
                printf("block %d (start):\n", i)
            else:
                printf("\nblock %d:\n", i)
            b = self->blocks[i]

            for ins = b->instructions; ins < &b->instructions[b->ninstructions]; ins++:
                #printf("    [line %d]   ", ins->location.lineno)
                printf("    [line ???]   ")
                match ins->kind:
                    case UvgInstructionKind.Set:
                        printf("set ")
                        self->print_value_id(ins->value_id)
                    case UvgInstructionKind.Use:
                        printf("use ")
                        self->print_value_id(ins->value_id)
                    case UvgInstructionKind.SetToAddressOf:
                        printf("set ")
                        self->print_value_id(ins->value_ids[0])
                        printf(" to address of ")
                        self->print_value_id(ins->value_ids[1])
                    case UvgInstructionKind.SetValueOfPointer:
                        printf("set value of pointer ")
                        self->print_value_id(ins->value_id)
                printf("\n")

            printf("    ")
            match b->terminator.kind:
                case UvgTerminatorKind.Jump:
                    printf("Jump to block %d.\n", self->index_of_block(b->terminator.jump_block))
                case UvgTerminatorKind.Branch:
                    printf("If ")
                    self->print_value_id(b->terminator.branch.cond_value_id)
                    printf(
                        " is True, jump to block %d. Otherwise jump to block %d.\n",
                        self->index_of_block(b->terminator.branch.then),
                        self->index_of_block(b->terminator.branch.otherwise),
                    )
                case UvgTerminatorKind.Return:
                    printf("Return from function.\n")
                case UvgTerminatorKind.ExitProgram:
                    printf("The program will exit/crash/fail if we get here.\n")
                case UvgTerminatorKind.NotSet:
                    printf("(terminator not set)\n")

    def add_block(self) -> UvgBlock*:
        b: UvgBlock* = malloc(sizeof(*b))
        assert b != NULL
        memset(b, 0, sizeof(*b))

        self->blocks = realloc(self->blocks, sizeof(self->blocks[0]) * (self->nblocks + 1))
        assert self->blocks != NULL
        self->blocks[self->nblocks++] = b

        return b

    # Name should point to something within AST, it won't be free()Â¨d.
    # Name may be NULL to create a variable that represents an anonymous value.
    def add_value_id(self, varname: byte*) -> int:
        if varname != NULL:
            # Must not exist yet
            for i = 0; i < self->n_values; i++:
                if self->varnames[i] != NULL:
                    assert strcmp(self->varnames[i], varname) != 0

        self->varnames = realloc(self->varnames, sizeof(self->varnames[0]) * (self->n_values + 1))
        assert self->varnames != NULL
        value_id = self->n_values++
        self->varnames[value_id] = varname
        return value_id

    def value_id_for_varname(self, varname: byte*) -> int:
        assert varname != NULL
        assert varname[0] != '\0'

        for i = 0; i < self->n_values; i++:
            if self->varnames[i] != NULL:
                return i
        return self->add_value_id(varname)
