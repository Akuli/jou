# Undefined Value Graphs are used to determine which values may be undefined
# when the code runs.
#
# For example, consider the following Jou code (5 lines):
#
#    def foo(a: int) -> int:
#        x = a + 6
#        y: int
#        z = y
#        printf("%d %d\n", x, y, z)
#
# For this code, we create the following UVG:
#
#    block 0 (start):
#        [line 1]   set a
#        [line 2]   use a
#        [line 2]   set $1
#        [line 2]   use $1
#        [line 2]   set $2
#        [line 2]   use $2
#        [line 2]   set x
#        [line 4]   use y
#        [line 4]   set z
#        [line 5]   set $3
#        [line 5]   use $3
#        [line 5]   use x
#        [line 5]   use y
#        [line 5]   use z
#        [line 5]   set $4
#        [line 5]   use return
#        Return from function.
#
# Here:
#   - $1 is an anonymous value that represents the number 6
#   - $2 is an anonymous value that represents the result of a + 6
#   - "use a", "use $1", "set $2" comes from computing a + 6
#   - $3 is an anonymous value that represents the string "%d\n"
#   - $4 is an anonymous value that represents the return value of printf(...)
#   - "return" in "use return" represents the return value of the function
#
# On lines 4 and 5, we have "use y" even though there is no "set y". On line 5
# we also have "use $0". This means that we can emit the following warnings:
#
#    compiler warning for file "foo.jou", line 4: the value of 'y' is undefined
#    compiler warning for file "foo.jou", line 5: the value of 'y' is undefined
#    compiler error in file "foo.jou", line 5: function 'foo' must return a value, because it is defined with '-> int'
#
# This gets more complicated when branching and loops are involved. For example,
# consider the following:
#
#    def bar(cond: bool) -> None:
#        x: int
#        if cond:
#            x = 7
#        printf("%d\n", x)
#
# We handle this very similarly to LLVM IR. Here's the UVG for bar():
#
#    block 0 (start):
#        [line 1]   set cond
#        [line 3]   use cond
#        If cond is True, jump to block 1. Otherwise jump to block 2.
#
#    block 1:
#        [line 4]   set $1
#        [line 4]   use $1
#        [line 4]   set x
#        Jump to block 3.
#
#    block 2:
#        Jump to block 3.
#
#    block 3:
#        [line 5]   set $2
#        [line 5]   use $2
#        [line 5]   use x
#        [line 5]   set $3
#        Return from function.
#
# Here:
#   - $1 is an anonymous value that represents 7
#   - $2 is an anonymous value that represents "%d\n"
#   - $3 is an anonymous value that represents the return value of printf(...)
#   - $0 does not appear at all, because this is a '-> None' function (no return value)
#   - block 2 is basically empty, because it represents the "else" which is missing

import "stdlib/io.jou"
import "stdlib/str.jou"
import "stdlib/mem.jou"


enum UvgInstructionKind:
    Set
    Use
    UseAddress  # this means that &foo is used, so don't even try to figure out when and how foo changes

class UvgInstruction:
    #location: Location
    kind: UvgInstructionKind
    value_id: int


class UvgBranch:
    cond_value_id: int  # which value is the branch true/false condition
    then: UvgBlock*
    otherwise: UvgBlock*


enum UvgTerminatorKind:
    NotSet  # must be first so it's zero memory
    Jump
    Branch
    Return
    ExitProgram

class UvgTerminator:
    kind: UvgTerminatorKind
    union:
        jump_block: UvgBlock*   # UvgTerminatorKind.Jump
        branch: UvgBranch       # UvgTerminatorKind.Branch


class UvgBlock:
    instructions: UvgInstruction*
    ninstructions: int
    terminator: UvgTerminator

    def free(self) -> None:
        free(self->instructions)


# We build one UVG for each function.
class Uvg:
    name: byte[200]
    returns_a_value: bool

    # Each block is allocated separately so that we can pass them around as
    # pointers, and they don't become invalid when adding more blocks.
    blocks: UvgBlock**
    nblocks: int

    # Each variable name points to something within the AST. We won't free() them.
    varnames: byte**
    n_values: int

    def index_of_block(self, b: UvgBlock*) -> int:
        for i = 0; i < self->nblocks; i++:
            if self->blocks[i] == b:
                return i
        assert False

    # Prints variable name or e.g. "$6"
    def print_value_id(self, value_id: int) -> None:
        assert 0 <= value_id and value_id < self->n_values
        if self->varnames[value_id] == NULL:
            printf("$%d", value_id)
        else:
            printf("%s", self->varnames[value_id])

    def print(self) -> None:
        printf("===== UVG for %s =====\n", self->name)

        assert self->nblocks > 0

        for i = 0; i < self->nblocks; i++:
            if i == 0:
                printf("block %d (start):\n", i)
            else:
                printf("\nblock %d:\n", i)
            b = self->blocks[i]

            for ins = b->instructions; ins < &b->instructions[b->ninstructions]; ins++:
                #printf("    [line %d]   ", ins->location.lineno)
                printf("    [line ???]   ")
                match ins->kind:
                    case UvgInstructionKind.Set:
                        printf("set")
                    case UvgInstructionKind.Use:
                        printf("use")
                    case UvgInstructionKind.UseAddress:
                        printf("use address of")
                printf(" ")
                self->print_value_id(ins->value_id)
                printf("\n")

            printf("    ")
            match b->terminator.kind:
                case UvgTerminatorKind.Jump:
                    printf("Jump to block %d.\n", self->index_of_block(b->terminator.jump_block))
                case UvgTerminatorKind.Branch:
                    printf("If ")
                    self->print_value_id(b->terminator.branch.cond_value_id)
                    printf(
                        " is True, jump to block %d. Otherwise jump to block %d.\n",
                        self->index_of_block(b->terminator.branch.then),
                        self->index_of_block(b->terminator.branch.otherwise),
                    )
                case UvgTerminatorKind.Return:
                    printf("Return from function.\n")
                case UvgTerminatorKind.ExitProgram:
                    printf("The program will exit/crash/fail if we get here.\n")
                case UvgTerminatorKind.NotSet:
                    printf("(terminator not set)\n")

    def add_block(self) -> UvgBlock*:
        b: UvgBlock* = malloc(sizeof(*b))
        assert b != NULL
        memset(b, 0, sizeof(*b))

        self->blocks = realloc(self->blocks, sizeof(self->blocks[0]) * (self->nblocks + 1))
        assert self->blocks != NULL
        self->blocks[self->nblocks++] = b

        return b

    # Name should point to something within AST, it won't be free()Â¨d.
    # Name may be NULL to create a variable that represents an anonymous value.
    def add_value_id(self, varname: byte*) -> int:
        if varname != NULL:
            # Must not exist yet
            for i = 0; i < self->n_values; i++:
                if self->varnames[i] != NULL:
                    assert strcmp(self->varnames[i], varname) != 0

        self->varnames = realloc(self->varnames, sizeof(self->varnames[0]) * (self->n_values + 1))
        assert self->varnames != NULL
        value_id = self->n_values++
        self->varnames[value_id] = varname
        return value_id

    def value_id_for_varname(self, varname: byte*) -> int:
        assert varname != NULL
        assert varname[0] != '\0'

        for i = 0; i < self->n_values; i++:
            if self->varnames[i] != NULL:
                return i
        return self->add_value_id(varname)
