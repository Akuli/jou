import "stdlib/io.jou"
import "stdlib/str.jou"
import "stdlib/mem.jou"


enum UvgInstructionKind:
    UseX                # something = x
    SetX                # x = something
    UseDerefX           # something = *x
    SetDerefX           # *x = something
    SetXToAddressOfY    # x = &y

class UvgInstruction:
    #location: Location
    kind: UvgInstructionKind
    x: int
    y: int


class UvgBranch:
    cond_value_id: int  # which value is the branch true/false condition
    then: UvgBlock*
    otherwise: UvgBlock*


enum UvgTerminatorKind:
    NotSet  # must be first so it's zero memory
    Jump
    Branch
    Return
    ExitProgram

class UvgTerminator:
    kind: UvgTerminatorKind
    union:
        jump_block: UvgBlock*   # UvgTerminatorKind.Jump
        branch: UvgBranch       # UvgTerminatorKind.Branch


class UvgBlock:
    instructions: UvgInstruction*
    ninstructions: int
    terminator: UvgTerminator

    def free(self) -> None:
        free(self->instructions)


# We build one UVG for each function.
class Uvg:
    name: byte[200]

    # Each block is allocated separately so that we can pass them around as
    # pointers, and they don't become invalid when adding more blocks.
    blocks: UvgBlock**
    nblocks: int

    varnames: byte[100]*
    n_values: int

    def free(self) -> None:
        for i = 0; i < self->nblocks; i++:
            self->blocks[i]->free()
            free(self->blocks[i])
        free(self->blocks)
        free(self->varnames)

    def index_of_block(self, b: UvgBlock*) -> int:
        for i = 0; i < self->nblocks; i++:
            if self->blocks[i] == b:
                return i
        assert False

    def print(self) -> None:
        printf("===== UVG for %s =====\n", self->name)

        assert self->nblocks > 0

        for i = 0; i < self->nblocks; i++:
            if i == 0:
                printf("block 0 (start):\n")
            else:
                printf("block %d:\n", i)
            b = self->blocks[i]

            for ins = b->instructions; ins < &b->instructions[b->ninstructions]; ins++:
                #printf("    [line %d]   ", ins->location.lineno)
                printf("    [line ???]   ")
                match ins->kind:
                    case UvgInstructionKind.UseX:
                        printf("use %s\n", self->varnames[ins->x])
                    case UvgInstructionKind.SetX:
                        printf("set %s\n", self->varnames[ins->x])
                    case UvgInstructionKind.UseDerefX:
                        printf("use *%s\n", self->varnames[ins->x])
                    case UvgInstructionKind.SetDerefX:
                        printf("set *%s\n", self->varnames[ins->x])
                    case UvgInstructionKind.SetXToAddressOfY:
                        printf("set %s to &%s\n", self->varnames[ins->x], self->varnames[ins->y])

            printf("    ")
            match b->terminator.kind:
                case UvgTerminatorKind.Jump:
                    printf("Jump to block %d.\n", self->index_of_block(b->terminator.jump_block))
                case UvgTerminatorKind.Branch:
                    printf(
                        "If %s is True, jump to block %d. Otherwise jump to block %d.\n",
                        self->varnames[b->terminator.branch.cond_value_id],
                        self->index_of_block(b->terminator.branch.then),
                        self->index_of_block(b->terminator.branch.otherwise),
                    )
                case UvgTerminatorKind.Return:
                    printf("Return from function.\n")
                case UvgTerminatorKind.ExitProgram:
                    printf("The program will exit/crash/fail if we get here.\n")
                case UvgTerminatorKind.NotSet:
                    printf("(terminator not set)\n")
        printf("\n")

    def add_block(self) -> UvgBlock*:
        b: UvgBlock* = malloc(sizeof(*b))
        assert b != NULL
        memset(b, 0, sizeof(*b))

        self->blocks = realloc(self->blocks, sizeof(self->blocks[0]) * (self->nblocks + 1))
        assert self->blocks != NULL
        self->blocks[self->nblocks++] = b

        return b

    # Name should point to something within AST, it won't be free()Â¨d.
    # Name may be NULL to create a variable that represents an anonymous value.
    def add_value(self, varname: byte*) -> int:
        if varname != NULL:
            # Must not exist yet
            for i = 0; i < self->n_values; i++:
                assert strcmp(self->varnames[i], varname) != 0

        self->varnames = realloc(self->varnames, sizeof(self->varnames[0]) * (self->n_values + 1))
        assert self->varnames != NULL
        value_id = self->n_values++
        if varname == NULL:
            sprintf(self->varnames[value_id], "$%d", value_id)
        else:
            assert strlen(varname) < sizeof(self->varnames[value_id])
            strcpy(self->varnames[value_id], varname)
        return value_id

    def value_id_for_varname(self, varname: byte*) -> int:
        assert varname != NULL
        assert varname[0] != '\0'

        for i = 0; i < self->n_values; i++:
            if strcmp(self->varnames[i], varname) == 0:
                return i
        return self->add_value(varname)
