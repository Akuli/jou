import "stdlib/str.jou"
import "stdlib/mem.jou"

import "./cf_graph.jou"
import "./constants.jou"
import "./evaluate.jou"
import "./types.jou"
import "./types_in_ast.jou"
import "./typecheck/common.jou"
import "./errors_and_warnings.jou"
import "./ast.jou"


enum PreOrPost:
    Pre
    Post


enum AndOr:
    And
    Or


def find_enum_member(enumtype: Type*, name: byte*) -> int:
    for i = 0; i < enumtype->enummembers.count; i++:
        if strcmp(enumtype->enummembers.names[i], name) == 0:
            return i
    assert False


class CfBuilder:
    filetypes: FileTypes*
    fomtypes: FunctionOrMethodTypes*
    cfg: CfGraph*
    current_block: CfBlock*
    breakstack: CfBlock**
    continuestack: CfBlock**
    nloops: int

    def find_var(self, name: byte*) -> LocalVariable*:
        for var = self->cfg->locals; var < &self->cfg->locals[self->cfg->nlocals]; var++:
            if strcmp((*var)->name, name) == 0:
                return *var
        return NULL

    def add_var(self, t: Type*) -> LocalVariable*:
        var: LocalVariable* = calloc(1, sizeof *var)
        var->id = self->cfg->nlocals
        var->type = t

        self->cfg->locals = realloc(self->cfg->locals, sizeof(self->cfg->locals[0]) * (self->cfg->nlocals + 1))
        assert self->cfg->locals != NULL
        self->cfg->locals[self->cfg->nlocals++] = var

        return var

    def add_block(self) -> CfBlock*:
        block: CfBlock* = calloc(1, sizeof *block)

        self->cfg->all_blocks = realloc(self->cfg->all_blocks, sizeof(self->cfg->all_blocks[0]) * (self->cfg->n_all_blocks + 1))
        assert self->cfg->all_blocks != NULL
        self->cfg->all_blocks[self->cfg->n_all_blocks++] = block

        return block

    def jump(
        self,
        branchvar: LocalVariable*,
        iftrue: CfBlock*,
        iffalse: CfBlock*,
        new_current_block: CfBlock*,
    ) -> None:
        assert (iftrue != NULL and iffalse != NULL) or (iftrue == NULL and iffalse == NULL and branchvar == NULL)
        if iftrue != iffalse:
            assert branchvar != NULL
            assert branchvar->type == boolType

        self->current_block->branchvar = branchvar
        self->current_block->iftrue = iftrue
        self->current_block->iffalse = iffalse
        if new_current_block == NULL:
            self->current_block = self->add_block()
        else:
            self->current_block = new_current_block

    # Returned pointer is only valid until next call to add_instruction()
    # because the list of instructions may be reallocated.
    def add_instruction(self, ins: CfInstruction) -> CfInstruction*:
        self->current_block->instructions = realloc(self->current_block->instructions, sizeof(self->current_block->instructions[0]) * (self->current_block->ninstructions + 1))
        assert self->current_block->instructions != NULL
        self->current_block->instructions[self->current_block->ninstructions++] = ins
        return &self->current_block->instructions[self->current_block->ninstructions - 1]

    def unary_op(
        self,
        location: Location,
        op: CfInstructionKind,
        arg: LocalVariable*,
        target: LocalVariable*,
    ) -> None:
        ins = CfInstruction{location = location, kind = op, destvar = target}
        ins.add_operand(arg)
        self->add_instruction(ins)

    def binary_op(
        self,
        location: Location,
        op: CfInstructionKind,
        lhs: LocalVariable*,
        rhs: LocalVariable*,
        target: LocalVariable*,
    ) -> None:
        ins = CfInstruction{location = location, kind = op, destvar = target}
        ins.add_operand(lhs)
        ins.add_operand(rhs)
        self->add_instruction(ins)

    def constant(self, location: Location, c: Constant, target: LocalVariable*) -> CfInstruction*:
        ins = CfInstruction{location = location, kind = CfInstructionKind.Constant, constant = c.copy(), destvar = target}
        return self->add_instruction(ins)

    def build_bool_to_int_conversion(
        self,
        boolvar: LocalVariable*,
        location: Location,
        t: Type*,
    ) -> LocalVariable*:
        assert t->is_integer_type()
        result: LocalVariable* = self->add_var(t)

        set1 = self->add_block()
        set0 = self->add_block()
        done = self->add_block()

        self->jump(boolvar, set1, set0, set1)
        self->constant(location, int_constant(t, 1), result)->hide_unreachable_warning = True
        self->jump(NULL, done, done, set0)
        self->constant(location, int_constant(t, 0), result)->hide_unreachable_warning = True
        self->jump(NULL, done, done, done)

        return result

    def build_cast(
        self,
        obj: LocalVariable*,
        to: Type*,
        location: Location,
    ) -> LocalVariable*:
        if obj->type == to:
            return obj

        if obj->type->is_pointer_type() and to->is_pointer_type():
            result = self->add_var(to)
            self->unary_op(location, CfInstructionKind.PtrCast, obj, result)
            return result

        if obj->type->is_number_type() and to->is_number_type():
            result = self->add_var(to)
            self->unary_op(location, CfInstructionKind.NumCast, obj, result)
            return result

        if obj->type->is_number_type() and obj->type->size_in_bits == 64 and to->is_pointer_type():
            result = self->add_var(to)
            self->unary_op(location, CfInstructionKind.Int64ToPtr, obj, result)
            return result

        if obj->type->is_integer_type() or to->kind == TypeKind.Enum:
            i32var = self->add_var(intType)
            result = self->add_var(to)
            self->unary_op(location, CfInstructionKind.NumCast, obj, i32var)
            self->unary_op(location, CfInstructionKind.Int32ToEnum, i32var, result)
            return result

        if obj->type->kind == TypeKind.Enum and to->is_integer_type():
            i32var = self->add_var(intType)
            result = self->add_var(to)
            self->unary_op(location, CfInstructionKind.EnumToInt32, obj, i32var)
            self->unary_op(location, CfInstructionKind.NumCast, i32var, result)
            return result

        if obj->type == boolType and to->is_integer_type():
            return self->build_bool_to_int_conversion(obj, location, to)

        if obj->type->is_pointer_type() and to->is_integer_type() and to->size_in_bits == 64:
            result = self->add_var(to)
            self->unary_op(location, CfInstructionKind.PtrToInt64, obj, result)
            return result

        assert False

    def build_bool_eq(self, location: Location, a: LocalVariable*, b: LocalVariable*) -> LocalVariable*:
        assert a->type == boolType
        assert b->type == boolType

        # Pseudo code:
        #
        #    if a:
        #        result = b
        #    else:
        #        result = not b
        result = self->add_var(boolType)

        atrue = self->add_block()
        afalse = self->add_block()
        done = self->add_block()

        # if a:
        self->jump(a, atrue, afalse, atrue)

        # result = b
        self->unary_op(location, CfInstructionKind.VarCpy, b, result)

        # else:
        self->jump(NULL, done, done, afalse)

        # result = not b
        self->unary_op(location, CfInstructionKind.BoolNegate, b, result)

        self->jump(NULL, done, done, done)
        return result

    def build_binop(
        self,
        op: AstExpressionKind,
        location: Location,
        lhs: LocalVariable*,
        rhs: LocalVariable*,
        result_type: Type*,
    ) -> LocalVariable*:
        got_bools = lhs->type == boolType and rhs->type == boolType
        got_numbers = lhs->type->is_number_type() and rhs->type->is_number_type()
        got_pointers = lhs->type->is_pointer_type() and rhs->type->is_pointer_type()
        assert got_bools or got_numbers or got_pointers

        negate = False
        swap = False

        destvar: LocalVariable*
        if got_bools:
            assert result_type == boolType
            destvar = self->build_bool_eq(location, lhs, rhs)
            assert op == AstExpressionKind.Eq or op == AstExpressionKind.Ne
            negate = (op == AstExpressionKind.Ne)
        else:
            destvar = self->add_var(result_type)
            match op:
                case AstExpressionKind.Add:
                    k = CfInstructionKind.NumAdd
                case AstExpressionKind.Sub:
                    k = CfInstructionKind.NumSub
                case AstExpressionKind.Mul:
                    k = CfInstructionKind.NumMul
                case AstExpressionKind.Div:
                    k = CfInstructionKind.NumDiv
                case AstExpressionKind.Mod:
                    k = CfInstructionKind.NumMod
                case AstExpressionKind.Eq:
                    k = CfInstructionKind.NumEq
                case AstExpressionKind.Ne:
                    k = CfInstructionKind.NumEq
                    negate = True
                case AstExpressionKind.Lt:
                    k = CfInstructionKind.NumLt
                case AstExpressionKind.Gt:
                    k = CfInstructionKind.NumLt
                    swap = True
                case AstExpressionKind.Le:
                    k = CfInstructionKind.NumLt
                    negate = True
                    swap = True
                case AstExpressionKind.Ge:
                    k = CfInstructionKind.NumLt
                    negate = True
                case _:
                    assert False

            if swap:
                self->binary_op(location, k, rhs, lhs, destvar)
            else:
                self->binary_op(location, k, lhs, rhs, destvar)

        if not negate:
            return destvar

        negated = self->add_var(boolType)
        self->unary_op(location, CfInstructionKind.BoolNegate, destvar, negated)
        return negated

    def build_class_field_pointer(
        self, instance: LocalVariable*, fieldname: byte*, location: Location
    ) -> LocalVariable*:
        assert instance->type->kind == TypeKind.Pointer
        assert instance->type->value_type->kind == TypeKind.Class
        class_type = instance->type->value_type

        for f = class_type->classdata.fields; f < &class_type->classdata.fields[class_type->classdata.nfields]; f++:
            if strcmp(f->name, fieldname) == 0:
                result = self->add_var(f->type->pointer_type())

                ins = CfInstruction{
                    location = location,
                    kind = CfInstructionKind.PtrClassField,
                    destvar = result,
                }
                ins.add_operand(instance)

                assert sizeof(ins.fieldname) == sizeof(f->name)
                strcpy(ins.fieldname, f->name)

                self->add_instruction(ins)
                return result

        assert False

    def build_class_field(
        self,
        instance: LocalVariable*,
        fieldname: byte*,
        location: Location,
    ) -> LocalVariable*:
        ptr = self->add_var(instance->type->pointer_type())
        self->unary_op(location, CfInstructionKind.AddressOfLocalVar, instance, ptr)
        field_ptr = self->build_class_field_pointer(ptr, fieldname, location)
        field = self->add_var(field_ptr->type->value_type)
        self->unary_op(location, CfInstructionKind.PtrLoad, field_ptr, field)
        return field

    def build_increment_or_decrement(
        self,
        location: Location,
        inner: AstExpression*,
        pop: PreOrPost,
        diff: int,
    ) -> LocalVariable*:
        assert diff == 1 or diff == -1  # 1=increment, -1=decrement

        addr = self->build_address_of_expression(inner)
        assert addr->type->kind == TypeKind.Pointer
        t = addr->type->value_type

        assert t->is_integer_type() or t->is_pointer_type()

        old_value = self->add_var(t)
        new_value = self->add_var(t)
        if t->is_integer_type():
            diffvar = self->add_var(t)
        else:
            diffvar = self->add_var(intType)

        self->constant(location, int_constant(diffvar->type, diff), diffvar)
        self->unary_op(location, CfInstructionKind.PtrLoad, addr, old_value)
        if t->is_number_type():
            self->binary_op(location, CfInstructionKind.NumAdd, old_value, diffvar, new_value)
        else:
            self->binary_op(location, CfInstructionKind.PtrAddInt, old_value, diffvar, new_value)
        self->binary_op(location, CfInstructionKind.PtrStore, addr, new_value, NULL)

        match pop:
            case PreOrPost.Pre:
                return new_value
            case PreOrPost.Post:
                return old_value
        assert False

    def build_and_or(
        self,
        lhsexpr: AstExpression*,
        rhsexpr: AstExpression*,
        andor: AndOr,
    ) -> LocalVariable*:
        # Must be careful with side effects.
        #
        # and:
        #    # lhs returning False means we don't evaluate rhs
        #    if lhs:
        #        result = rhs
        #    else:
        #        result = False
        #
        # or:
        #    # lhs returning True means we don't evaluate rhs
        #    if lhs:
        #        result = True
        #    else:
        #        result = rhs
        lhs = self->build_expression(lhsexpr)
        result = self->add_var(boolType)

        lhstrue = self->add_block()
        lhsfalse = self->add_block()
        done = self->add_block()

        # if lhs:
        self->jump(lhs, lhstrue, lhsfalse, lhstrue)

        match andor:
            case AndOr.And:
                # result = rhs
                rhs = self->build_expression(rhsexpr)
                self->unary_op(rhsexpr->location, CfInstructionKind.VarCpy, rhs, result)
            case AndOr.Or:
                # result = True
                ins = self->constant(lhsexpr->location, Constant{kind = ConstantKind.Bool, boolean = True}, result)
                ins->hide_unreachable_warning = True

        # else:
        self->jump(NULL, done, done, lhsfalse)

        match andor:
            case AndOr.And:
                # result = False
                ins = self->constant(lhsexpr->location, Constant{kind = ConstantKind.Bool, boolean = False}, result)
                ins->hide_unreachable_warning = True
            case AndOr.Or:
                # result = rhs
                rhs = self->build_expression(rhsexpr)
                self->unary_op(rhsexpr->location, CfInstructionKind.VarCpy, rhs, result)

        self->jump(NULL, done, done, done)
        return result

    def build_address_of_expression(self, address_of_what: AstExpression*) -> LocalVariable*:
        match address_of_what->kind:
            case AstExpressionKind.GetVariable:
                ptrtype = address_of_what->types.orig_type->pointer_type()
                addr = self->add_var(ptrtype)

                local_var = self->find_var(address_of_what->varname)
                if local_var == NULL:
                    # Global variable (possibly imported from another file)
                    ins = CfInstruction {
                        location = address_of_what->location,
                        kind = CfInstructionKind.AddressOfGlobalVar,
                        destvar = addr,
                    }
                    assert sizeof(ins.globalname) == sizeof(address_of_what->varname)
                    strcpy(ins.globalname, address_of_what->varname)
                    self->add_instruction(ins)
                else:
                    self->unary_op(address_of_what->location, CfInstructionKind.AddressOfLocalVar, local_var, addr)
                return addr

            case AstExpressionKind.Self:
                ptrtype = address_of_what->types.orig_type->pointer_type()
                addr = self->add_var(ptrtype)

                local_var = self->find_var("self")
                assert local_var != NULL
                self->unary_op(address_of_what->location, CfInstructionKind.AddressOfLocalVar, local_var, addr)
                return addr

            case AstExpressionKind.Dereference:
                # &*foo --> just evaluate foo
                return self->build_expression(&address_of_what->operands[0])

            case AstExpressionKind.GetClassField:
                if address_of_what->class_field.uses_arrow_operator:
                    # &obj->field aka &(obj->field)
                    obj = self->build_expression(address_of_what->class_field.instance)
                else:
                    # &obj.field aka &(obj.field), evaluate as &(&obj)->field
                    obj = self->build_address_of_expression(address_of_what->class_field.instance)

                assert obj->type->kind == TypeKind.Pointer
                assert obj->type->value_type->kind == TypeKind.Class
                return self->build_class_field_pointer(obj, address_of_what->class_field.field_name, address_of_what->location)

            case AstExpressionKind.Indexing:
                ptr = self->build_expression(&address_of_what->operands[0])
                assert ptr->type->kind == TypeKind.Pointer

                index = self->build_expression(&address_of_what->operands[1])
                assert index->type->is_integer_type()

                result = self->add_var(ptr->type)
                self->binary_op(address_of_what->location, CfInstructionKind.PtrAddInt, ptr, index, result)
                return result

            case _:
                assert False

    def build_call(
        self,
        location: Location,
        call: AstCall*,
    ) -> LocalVariable*:
        sig: Signature* = NULL

        if call->method_call_self != NULL:
            selfclass = call->method_call_self->types.orig_type
            if call->uses_arrow_operator:
                assert selfclass->kind == TypeKind.Pointer
                selfclass = selfclass->value_type
            assert selfclass->kind == TypeKind.Class
            sig = selfclass->find_method(call->name)
        else:
            sig = self->filetypes->find_function(call->name)

        assert sig != NULL

        ins = CfInstruction{
            location = location,
            kind = CfInstructionKind.Call,
            signature = sig->copy(),
        }

        if call->method_call_self != NULL:
            if sig->argtypes[0]->is_pointer_type() and not call->uses_arrow_operator:
                ins.add_operand(self->build_address_of_expression(call->method_call_self))
            elif (not sig->argtypes[0]->is_pointer_type()) and call->uses_arrow_operator:
                self_ptr = self->build_expression(call->method_call_self)
                assert self_ptr->type->kind == TypeKind.Pointer

                # dereference the pointer
                val = self->add_var(self_ptr->type->value_type)
                self->unary_op(call->method_call_self->location, CfInstructionKind.PtrLoad, self_ptr, val)
                ins.add_operand(val)
            else:
                ins.add_operand(self->build_expression(call->method_call_self))

        for i = 0; i < call->nargs; i++:
            ins.add_operand(self->build_expression(&call->args[i]))

        if sig->returntype != NULL:
            ins.destvar = self->add_var(sig->returntype)

        self->add_instruction(ins)

        if sig->is_noreturn:
            # Place the remaining code into an unreachable block, so you will get a warning if there is any
            self->jump(NULL, NULL, NULL, NULL)

        return ins.destvar

    def build_instantiation(self, type: Type*, inst: AstInstantiation*, location: Location) -> LocalVariable*:
        instance = self->add_var(type)
        instanceptr = self->add_var(type->pointer_type())

        self->unary_op(location, CfInstructionKind.AddressOfLocalVar, instance, instanceptr)
        self->unary_op(location, CfInstructionKind.PtrMemsetToZero, instanceptr, NULL)

        for i = 0; i < inst->nfields; i++:
            fieldptr = self->build_class_field_pointer(instanceptr, inst->field_names[i], inst->field_values[i].location)
            fieldval = self->build_expression(&inst->field_values[i])
            self->binary_op(location, CfInstructionKind.PtrStore, fieldptr, fieldval, NULL)

        return instance

    def build_array(self, type: Type*, items: AstExpression*, location: Location) -> LocalVariable*:
        assert type->kind == TypeKind.Array

        arr = self->add_var(type)
        arrptr = self->add_var(type->pointer_type())
        self->unary_op(location, CfInstructionKind.AddressOfLocalVar, arr, arrptr)
        first_item_ptr = self->add_var(type->array.item_type->pointer_type())
        self->unary_op(location, CfInstructionKind.PtrCast, arrptr, first_item_ptr)

        for i = 0; i < type->array.len; i++:
            value = self->build_expression(&items[i])

            ivar = self->add_var(intType)
            self->constant(location, int_constant(intType, i), ivar)

            destptr = self->add_var(first_item_ptr->type)
            self->binary_op(location, CfInstructionKind.PtrAddInt, first_item_ptr, ivar, destptr)
            self->binary_op(location, CfInstructionKind.PtrStore, destptr, value, NULL)

        return arr

    def build_expression(self, expr: AstExpression*) -> LocalVariable*:
        if expr->types.implicit_array_to_pointer_cast:
            arrptr = self->build_address_of_expression(expr)
            memberptr = self->add_var(expr->types.implicit_cast_type)
            self->unary_op(expr->location, CfInstructionKind.PtrCast, arrptr, memberptr)
            return memberptr

        if expr->types.implicit_string_to_array_cast:
            assert expr->types.implicit_cast_type != NULL
            assert expr->types.implicit_cast_type->kind == TypeKind.Array
            assert expr->kind == AstExpressionKind.String

            array_size = expr->types.implicit_cast_type->array.len
            assert strlen(expr->string) < array_size
            padded: byte* = calloc(1, array_size)
            assert padded != NULL
            strcpy(padded, expr->string)

            result = self->add_var(expr->types.implicit_cast_type)
            ins = CfInstruction{
                location = expr->location,
                kind = CfInstructionKind.StringArray,
                strarray = CfStringArray{
                    str = padded,
                    len = array_size,
                },
                destvar = result,
            }
            self->add_instruction(ins)
            return result

        t = expr->types.orig_type
        if expr->kind != AstExpressionKind.Call:
            # Calls do not necessary return anything, all other expressions do.
            assert t != NULL

        match expr->kind:
            case AstExpressionKind.Call:
                result = self->build_call(expr->location, &expr->call)
                if result == NULL:
                    # called function/method has no return value
                    return NULL
            case AstExpressionKind.Instantiate:
                result = self->build_instantiation(t, &expr->instantiation, expr->location)
            case AstExpressionKind.Array:
                assert t->kind == TypeKind.Array
                assert t->array.len == expr->array.length
                result = self->build_array(t, expr->array.items, expr->location)
            case AstExpressionKind.GetEnumMember:
                result = self->add_var(t)
                c = Constant{
                    kind = ConstantKind.EnumMember,
                    enum_member = EnumMemberConstant{
                        enumtype = t,
                        memberidx = find_enum_member(t, expr->enum_member.member_name),
                    }
                }
                self->constant(expr->location, c, result)
            case AstExpressionKind.GetVariable:
                if get_special_constant(expr->varname) != -1:
                    result = self->add_var(boolType)
                    ins = CfInstruction{
                        location = expr->location,
                        kind = CfInstructionKind.SpecialConstant,
                        destvar = result,
                    }
                    assert sizeof(ins.scname) == sizeof(expr->varname)
                    strcpy(ins.scname, expr->varname)
                    self->add_instruction(ins)
                else:
                    temp = self->find_var(expr->varname)
                    if temp != NULL:
                        if expr->types.implicit_cast_type == NULL or t == expr->types.implicit_cast_type:
                            # Must take a "snapshot" of this variable, as it may change soon.
                            result = self->add_var(temp->type)
                            self->unary_op(expr->location, CfInstructionKind.VarCpy, temp, result)
                        else:
                            result = temp
                    else:
                        # For other than local variables we can evaluate as &*variable.
                        # Would also work for locals, but it would confuse simplify_cfg.
                        temp = self->build_address_of_expression(expr)
                        result = self->add_var(t)
                        self->unary_op(expr->location, CfInstructionKind.PtrLoad, temp, result)
            case AstExpressionKind.GetClassField:
                if expr->class_field.uses_arrow_operator:
                    # Evaluate foo->bar as *(&(foo->bar)). This works even if we can't
                    # take the address of foo, because foo is already a pointer and we
                    # only add a memory offset to it.
                    temp = self->build_address_of_expression(expr)
                    result = self->add_var(t)
                    self->unary_op(expr->location, CfInstructionKind.PtrLoad, temp, result)
                else:
                    temp = self->build_expression(expr->class_field.instance)
                    result = self->build_class_field(temp, expr->class_field.field_name, expr->location)
            case AstExpressionKind.Indexing:
                # Evaluate foo[bar] as *(&(foo[bar])). This works even if we can't take
                # the address of foo, because foo is already a pointer and we only add a
                # memory offset to it.
                temp = self->build_address_of_expression(expr)
                result = self->add_var(t)
                self->unary_op(expr->location, CfInstructionKind.PtrLoad, temp, result)
            case AstExpressionKind.AddressOf:
                result = self->build_address_of_expression(&expr->operands[0])
            case AstExpressionKind.SizeOf:
                result = self->add_var(longType)
                ins = CfInstruction{
                    location = expr->location,
                    kind = CfInstructionKind.SizeOf,
                    type = expr->operands[0].types.orig_type,
                    destvar = result,
                }
                self->add_instruction(ins)
            case AstExpressionKind.Dereference:
                temp = self->build_expression(&expr->operands[0])
                result = self->add_var(t)
                self->unary_op(expr->location, CfInstructionKind.PtrLoad, temp, result)
            case AstExpressionKind.Self:
                selfvar = self->find_var("self")
                assert selfvar != NULL
                if expr->types.orig_type == expr->types.implicit_cast_type or t == expr->types.implicit_cast_type:
                    # Must take a "snapshot" of this variable, as it may change soon.
                    result = self->add_var(selfvar->type)
                    self->unary_op(expr->location, CfInstructionKind.VarCpy, selfvar, result)
                else:
                    result = selfvar
            case (
                AstExpressionKind.Bool
                | AstExpressionKind.Byte
                | AstExpressionKind.Float
                | AstExpressionKind.Double
                | AstExpressionKind.Short
                | AstExpressionKind.Int
                | AstExpressionKind.Long
                | AstExpressionKind.Null
                | AstExpressionKind.String
            ):
                match expr->kind:
                    case AstExpressionKind.Bool:
                        c = Constant{kind = ConstantKind.Bool, boolean = expr->bool_value}
                    case AstExpressionKind.Byte:
                        c = int_constant(byteType, expr->byte_value)
                    case AstExpressionKind.Short:
                        c = int_constant(shortType, expr->short_value)
                    case AstExpressionKind.Int:
                        c = int_constant(intType, expr->int_value)
                    case AstExpressionKind.Long:
                        c = int_constant(longType, expr->long_value)
                    case AstExpressionKind.Null:
                        c = Constant{kind = ConstantKind.Null}
                    case AstExpressionKind.Float:
                        c = Constant{kind = ConstantKind.Float}
                        assert sizeof(c.double_or_float_text) == sizeof(expr->float_or_double_text)
                        strcpy(c.double_or_float_text, expr->float_or_double_text)
                    case AstExpressionKind.Double:
                        c = Constant{kind = ConstantKind.Double}
                        assert sizeof(c.double_or_float_text) == sizeof(expr->float_or_double_text)
                        strcpy(c.double_or_float_text, expr->float_or_double_text)
                    case AstExpressionKind.String:
                        c = Constant{kind = ConstantKind.String, str = expr->string}
                    case _:
                        assert False
                result = self->add_var(t)
                self->constant(expr->location, c, result)
            case AstExpressionKind.And:
                result = self->build_and_or(&expr->operands[0], &expr->operands[1], AndOr.And)
            case AstExpressionKind.Or:
                result = self->build_and_or(&expr->operands[0], &expr->operands[1], AndOr.Or)
            case AstExpressionKind.Not:
                temp = self->build_expression(&expr->operands[0])
                result = self->add_var(boolType)
                self->unary_op(expr->location, CfInstructionKind.BoolNegate, temp, result)
            case AstExpressionKind.Negate:
                temp = self->build_expression(&expr->operands[0])
                zero = self->add_var(temp->type)
                result = self->add_var(temp->type)
                if temp->type == doubleType:
                    c = Constant{kind = ConstantKind.Double, double_or_float_text = "0"}
                elif temp->type == floatType:
                    c = Constant{kind = ConstantKind.Float, double_or_float_text = "0"}
                else:
                    c = int_constant(temp->type, 0)
                self->constant(expr->location, c, zero)
                self->binary_op(expr->location, CfInstructionKind.NumSub, zero, temp, result)
            case (
                AstExpressionKind.Add
                | AstExpressionKind.Sub
                | AstExpressionKind.Mul
                | AstExpressionKind.Div
                | AstExpressionKind.Mod
                | AstExpressionKind.Eq
                | AstExpressionKind.Ne
                | AstExpressionKind.Gt
                | AstExpressionKind.Ge
                | AstExpressionKind.Lt
                | AstExpressionKind.Le
            ):
                # Refactoring note: If you rewrite this in another language, like C, make sure to
                # evaluate lhs first. C doesn't guarantee evaluation order of function arguments.
                lhs = self->build_expression(&expr->operands[0])
                rhs = self->build_expression(&expr->operands[1])
                result = self->build_binop(expr->kind, expr->location, lhs, rhs, t)
            case (
                AstExpressionKind.PreIncr
                | AstExpressionKind.PreDecr
                | AstExpressionKind.PostIncr
                | AstExpressionKind.PostDecr
            ):
                match expr->kind:
                    case AstExpressionKind.PreIncr:
                        pop = PreOrPost.Pre
                        diff = 1
                    case AstExpressionKind.PreDecr:
                        pop = PreOrPost.Pre
                        diff = -1
                    case AstExpressionKind.PostIncr:
                        pop = PreOrPost.Post
                        diff = 1
                    case AstExpressionKind.PostDecr:
                        pop = PreOrPost.Post
                        diff = -1
                    case _:
                        assert False
                result = self->build_increment_or_decrement(expr->location, &expr->operands[0], pop, diff)
            case AstExpressionKind.As:
                temp = self->build_expression(&expr->as_->value)
                result = self->build_cast(temp, t, expr->location)

        assert result->type == t
        if expr->types.implicit_cast_type == expr->types.orig_type:
            return result
        return self->build_cast(result, expr->types.implicit_cast_type, expr->location)

    def build_if_statement(self, ifstmt: AstIfStatement*) -> None:
        assert ifstmt->n_if_and_elifs >= 1

        done = self->add_block()
        for i = 0; i < ifstmt->n_if_and_elifs; i++:
            cond = self->build_expression(&ifstmt->if_and_elifs[i].condition)
            then = self->add_block()
            otherwise = self->add_block()

            self->jump(cond, then, otherwise, then)
            self->build_body(&ifstmt->if_and_elifs[i].body)
            self->jump(NULL, done, done, otherwise)

        self->build_body(&ifstmt->else_body)
        self->jump(NULL, done, done, done)

    def build_match_statement(self, match_stmt: AstMatchStatement*) -> None:
        match_obj_enum = self->build_expression(&match_stmt->match_obj)
        match_obj_int = self->add_var(intType)
        self->unary_op(match_stmt->match_obj.location, CfInstructionKind.EnumToInt32, match_obj_enum, match_obj_int)

        done = self->add_block()
        for i = 0; i < match_stmt->ncases; i++:
            then = self->add_block()
            otherwise: CfBlock* = NULL
            for k = 0; k < match_stmt->cases[i].n_case_objs; k++:
                case_obj_ast = &match_stmt->cases[i].case_objs[k]
                case_obj_enum = self->build_expression(case_obj_ast)
                case_obj_int = self->add_var(intType)
                self->unary_op(case_obj_ast->location, CfInstructionKind.EnumToInt32, case_obj_enum, case_obj_int)
                cond = self->build_binop(AstExpressionKind.Eq, case_obj_ast->location, match_obj_int, case_obj_int, boolType)

                otherwise = self->add_block()
                self->jump(cond, then, otherwise, otherwise)

            assert otherwise != NULL

            self->current_block = then
            self->build_body(&match_stmt->cases[i].body)
            self->jump(NULL, done, done, otherwise)

        if match_stmt->case_underscore != NULL:
            self->build_body(match_stmt->case_underscore)
        self->jump(NULL, done, done, done)

    def build_assert(self, assert_location: Location, assertion: AstAssertion*) -> None:
        condvar = self->build_expression(&assertion->condition)

        # If the condition is true, we jump to a block where the rest of the code goes.
        # If the condition is false, we jump to a block that calls _jou_assert_fail().
        trueblock = self->add_block()
        falseblock = self->add_block()
        self->jump(condvar, trueblock, falseblock, falseblock)

        argnames: byte[100]* = malloc(3 * sizeof(argnames[0]))
        strcpy(argnames[0], "assertion")
        strcpy(argnames[1], "path")
        strcpy(argnames[2], "lineno")

        argtypes: Type** = malloc(3 * sizeof(argtypes[0]))
        argtypes[0] = byteType->pointer_type()
        argtypes[1] = byteType->pointer_type()
        argtypes[2] = intType

        ins = CfInstruction{
            location = assert_location,
            kind = CfInstructionKind.Call,
            signature = Signature{
                name = "_jou_assert_fail",
                nargs = 3,
                argtypes = argtypes,
                argnames = argnames,
                takes_varargs = False,
                is_noreturn = True,
                returntype_location = assert_location,
            }
        }

        arg1 = self->add_var(argtypes[0])
        arg2 = self->add_var(argtypes[1])
        arg3 = self->add_var(argtypes[2])

        self->constant(assert_location, Constant{kind = ConstantKind.String, str = assertion->condition_str}, arg1)
        self->constant(assert_location, Constant{kind = ConstantKind.String, str = assertion->condition.location.path}, arg2)
        self->constant(assert_location, int_constant(intType, assert_location.lineno), arg3)

        ins.add_operand(arg1)
        ins.add_operand(arg2)
        ins.add_operand(arg3)
        self->add_instruction(ins)

        self->current_block = trueblock

    # for init; cond; incr:
    #     ...body...
    #
    # While loop is basically a special case of for loop, so it uses this too.
    def build_loop(
        self,
        init: AstStatement*,
        cond: AstExpression*,
        incr: AstStatement*,
        body: AstBody*,
    ) -> None:
        condblock = self->add_block()  # evaluate condition and go to bodyblock or doneblock
        bodyblock = self->add_block()  # run loop body and go to incrblock
        incrblock = self->add_block()  # run incr and go to condblock
        doneblock = self->add_block()  # rest of the code goes here

        if init != NULL:
            self->build_statement(init)

        # Evaluate condition. Jump to loop body or skip to after loop.
        self->jump(NULL, condblock, condblock, condblock)
        condvar = self->build_expression(cond)
        self->jump(condvar, bodyblock, doneblock, bodyblock)

        # 'break' skips to after loop, 'continue' goes to incr.
        self->breakstack = realloc(self->breakstack, sizeof(self->breakstack[0]) * (self->nloops + 1))
        self->continuestack = realloc(self->continuestack, sizeof(self->continuestack[0]) * (self->nloops + 1))
        assert self->breakstack != NULL
        assert self->continuestack != NULL
        self->breakstack[self->nloops] = doneblock
        self->continuestack[self->nloops] = incrblock
        self->nloops++

        # Run loop body
        self->build_body(body)

        self->nloops--
        assert self->breakstack[self->nloops] == doneblock
        assert self->continuestack[self->nloops] == incrblock

        # Run incr and jump back to condition.
        self->jump(NULL, incrblock, incrblock, incrblock)
        if incr != NULL:
            self->build_statement(incr)
        self->jump(NULL, condblock, condblock, doneblock)

    def build_statement(self, stmt: AstStatement*) -> None:
        match stmt->kind:
            case AstStatementKind.If:
                self->build_if_statement(&stmt->if_statement)
            case AstStatementKind.Assert:
                self->build_assert(stmt->location, &stmt->assertion)
            case AstStatementKind.Pass:
                pass
            case AstStatementKind.WhileLoop:
                self->build_loop(
                    NULL, &stmt->while_loop.condition, NULL,
                    &stmt->while_loop.body)
            case AstStatementKind.ForLoop:
                self->build_loop(
                    stmt->for_loop.init, &stmt->for_loop.cond, stmt->for_loop.incr,
                    &stmt->for_loop.body)
            case AstStatementKind.Match:
                self->build_match_statement(&stmt->match_statement)
            case AstStatementKind.Break:
                assert self->nloops > 0
                self->jump(NULL, self->breakstack[self->nloops - 1], self->breakstack[self->nloops - 1], NULL)
            case AstStatementKind.Continue:
                assert self->nloops > 0
                self->jump(NULL, self->continuestack[self->nloops - 1], self->continuestack[self->nloops - 1], NULL)
            case AstStatementKind.Assign:
                targetexpr = &stmt->assignment.target
                valueexpr = &stmt->assignment.value

                targetvar: LocalVariable* = NULL
                if targetexpr->kind == AstExpressionKind.GetVariable:
                    targetvar = self->find_var(targetexpr->varname)

                if targetvar != NULL:
                    # avoid pointers to help simplify_cfg
                    value = self->build_expression(valueexpr)
                    self->unary_op(stmt->location, CfInstructionKind.VarCpy, value, targetvar)
                else:
                    # TODO: is this evaluation order good?
                    target = self->build_address_of_expression(targetexpr)
                    value = self->build_expression(valueexpr)
                    assert target->type->kind == TypeKind.Pointer
                    self->binary_op(stmt->location, CfInstructionKind.PtrStore, target, value, NULL)

            case (
                AstStatementKind.InPlaceAdd
                | AstStatementKind.InPlaceSub
                | AstStatementKind.InPlaceMul
                | AstStatementKind.InPlaceDiv
                | AstStatementKind.InPlaceMod
            ):
                targetexpr = &stmt->assignment.target
                rhsexpr = &stmt->assignment.value

                targetptr = self->build_address_of_expression(targetexpr)
                rhs = self->build_expression(rhsexpr)
                assert targetptr->type->kind == TypeKind.Pointer
                oldvalue = self->add_var(targetptr->type->value_type)
                self->unary_op(stmt->location, CfInstructionKind.PtrLoad, targetptr, oldvalue)

                match stmt->kind:
                    case AstStatementKind.InPlaceAdd:
                        op = AstExpressionKind.Add
                    case AstStatementKind.InPlaceSub:
                        op = AstExpressionKind.Sub
                    case AstStatementKind.InPlaceMul:
                        op = AstExpressionKind.Mul
                    case AstStatementKind.InPlaceDiv:
                        op = AstExpressionKind.Div
                    case AstStatementKind.InPlaceMod:
                        op = AstExpressionKind.Mod
                    case _:
                        assert False

                newvalue = self->build_binop(op, stmt->location, oldvalue, rhs, targetptr->type->value_type)
                self->binary_op(stmt->location, CfInstructionKind.PtrStore, targetptr, newvalue, NULL)

            case AstStatementKind.Return:
                if stmt->return_value != NULL:
                    retvalue = self->build_expression(stmt->return_value)
                    retvariable = self->find_var("return")
                    assert retvariable != NULL
                    self->unary_op(stmt->location, CfInstructionKind.VarCpy, retvalue, retvariable)

                self->current_block->iftrue = &self->cfg->end_block
                self->current_block->iffalse = &self->cfg->end_block
                self->current_block = self->add_block()  # an unreachable block

            case AstStatementKind.DeclareLocalVar:
                if stmt->var_declaration.value != NULL:
                    v = self->find_var(stmt->var_declaration.name)
                    assert v != NULL
                    cfvar = self->build_expression(stmt->var_declaration.value)
                    self->unary_op(stmt->location, CfInstructionKind.VarCpy, cfvar, v)

            case AstStatementKind.ExpressionStatement:
                self->build_expression(&stmt->expression)

            case _:
                # other statements shouldn't occur inside functions/methods
                assert False

    def build_body(self, body: AstBody*) -> None:
        for i = 0; i < body->nstatements; i++:
            self->build_statement(&body->statements[i])

    def build_function_or_method(self, selfclass: Type*, astfom: AstFunctionOrMethod*) -> CfGraph*:
        # Methods are always public, so that you can call them whenever you have an instance
        if selfclass != NULL:
            assert astfom->public

        assert self->cfg == NULL

        assert self->fomtypes == NULL
        self->fomtypes = &astfom->types

        self->cfg = calloc(1, sizeof *self->cfg)
        self->cfg->public = astfom->public
        self->cfg->signature = self->fomtypes->signature.copy()

        # Copy local variables over from type checking.
        # Ownership of the variables changes, they will be freed when graphs are freed.
        self->cfg->nlocals = self->fomtypes->nlocals
        self->cfg->locals = malloc(self->cfg->nlocals * sizeof(self->cfg->locals[0]))
        assert self->cfg->locals != NULL
        memcpy(self->cfg->locals, self->fomtypes->locals, self->cfg->nlocals * sizeof(self->cfg->locals[0]))

        self->cfg->all_blocks = malloc(2 * sizeof(self->cfg->all_blocks[0]))
        assert self->cfg->all_blocks != NULL
        self->cfg->all_blocks[0] = &self->cfg->start_block
        self->cfg->all_blocks[1] = &self->cfg->end_block
        self->cfg->n_all_blocks = 2

        self->current_block = &self->cfg->start_block

        assert self->nloops == 0
        self->build_body(&astfom->body)
        assert self->nloops == 0

        # Implicit return at the end of the function
        self->current_block->iftrue = &self->cfg->end_block
        self->current_block->iffalse = &self->cfg->end_block

        cfg = self->cfg
        self->fomtypes = NULL
        self->cfg = NULL
        return cfg


# TODO: passing a type context here doesn't really make sense.
# It would be better to pass only the public symbols that have been imported.
@public
def build_control_flow_graphs(ast: AstFile*, filetypes: FileTypes*) -> CfGraphFile:
    result = CfGraphFile{filename = ast->path}
    builder = CfBuilder{filetypes = filetypes}

    for i = 0; i < ast->body.nstatements; i++:
        stmt = &ast->body.statements[i]

        match stmt->kind:
            case AstStatementKind.FunctionDef:
                # TODO: pass in the whole stmt->function
                g = builder.build_function_or_method(NULL, &stmt->function)
                result.graphs = realloc(result.graphs, sizeof(result.graphs[0]) * (result.ngraphs + 1))
                assert result.graphs != NULL
                result.graphs[result.ngraphs++] = g

            case AstStatementKind.Class:
                class_type: Type* = NULL
                for t = filetypes->owned_types; t < &filetypes->owned_types[filetypes->n_owned_types]; t++:
                    if strcmp((*t)->name, stmt->classdef.name) == 0:
                        class_type = *t
                        break
                assert class_type != NULL
                for m = stmt->classdef.members; m < &stmt->classdef.members[stmt->classdef.nmembers]; m++:
                    if m->kind == AstClassMemberKind.Method:
                        # TODO: pass in the whole m->method
                        g = builder.build_function_or_method(class_type, &m->method)
                        result.graphs = realloc(result.graphs, sizeof(result.graphs[0]) * (result.ngraphs + 1))
                        assert result.graphs != NULL
                        result.graphs[result.ngraphs++] = g

            case _:
                pass

    free(builder.breakstack)
    free(builder.continuestack)
    return result
