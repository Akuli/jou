import "stdlib/mem.jou"
import "stdlib/io.jou"

import "./errors_and_warnings.jou"
import "./structs.jou"
import "./print.jou"
import "./free.jou"
import "./types.jou"


class CfStringArray:
    str: byte*
    len: int

enum CfInstructionKind:
    Constant
    SpecialConstant  # e.g. "WINDOWS", unlike CF_Constant this doesn't trigger "this code will never run" warnings
    StringArray
    Call  # function or method call, depending on whether self_type is NULL (see below)
    AddressOfLocalVar
    AddressOfGlobalVar
    SizeOf
    PtrMemsetToZero  # takes one operand, a pointer: memset(ptr, 0, sizeof(*ptr))
    PtrStore  # *op1 = op2 (does not use destvar, takes 2 operands)
    PtrLoad  # aka dereference
    PtrToInt64
    Int64ToPtr
    PtrClassField  # takes 1 operand (pointer), sets destvar to &op->fieldname
    PtrCast
    PtrAddInt
    # Left and right side of number operations must be of the same type (except CfInstructionKind::NumCast).
    NumAdd
    NumSub
    NumMul
    NumDiv
    NumMod
    NumEq
    NumLt
    NumCast
    EnumToInt32
    Int32ToEnum
    BoolNegate  # TODO: get rid of this?
    VarCpy  # similar to assignment statements: var1 = var2

# Control Flow Graph.
# Struct names not prefixed with Cfg because it looks too much like "config" to me
class CfInstruction:
    location: Location
    kind: CfInstructionKind
    union:
        constant: Constant       # CfInstructionKind::Constant
        strarray: CfStringArray  # CfInstructionKind::StringArray
        signature: Signature     # CfInstructionKind::Call
        fieldname: byte[100]     # CfInstructionKind::PtrClassField
        globalname: byte[100]    # CfInstructionKind::AddressOfGlobalVar
        scname: byte[100]        # CfInstructionKind::SpecialConstant
        type: Type*              # CfInstructionKind::SizeOf

    operands: LocalVariable**  # e.g. numbers to add, function arguments
    noperands: int
    destvar: LocalVariable*  # NULL when it doesn't make sense, e.g. functions that return void
    hide_unreachable_warning: bool # usually false, can be set to true to avoid unreachable warning false positives

    # operands should be NULL-terminated array, or NULL for empty
    # TODO: does it ever need to be NULL?
    # TODO: do we need this method at all?
    def set_operands(self, operands: LocalVariable**) -> None:
        self->noperands = 0
        while operands != NULL and operands[self->noperands] != NULL:
            self->noperands++

        nbytes = sizeof(self->operands[0]) * self->noperands
        self->operands = malloc(nbytes)
        assert self->operands != NULL
        memcpy(self->operands, operands, nbytes)

    def free(self) -> None:
        if self->kind == CfInstructionKind::Constant:
            free_constant(&self->constant)
        if self->kind == CfInstructionKind::StringArray:
            free(self->strarray.str)
        if self->kind == CfInstructionKind::Call:
            free_signature(&self->signature)
        free(self->operands)


class CfBlock:
    instructions: CfInstruction*
    ninstructions: int
    branchvar: LocalVariable*  # boolean value used to decide where to jump next

    # iftrue and iffalse are NULL for special end block and after calling a noreturn function.
    # When iftrue and iffalse are the same, the branchvar is not used and may be NULL.
    iftrue: CfBlock*
    iffalse: CfBlock*

    def free(self) -> None:
        for ins = self->instructions; ins < &self->instructions[self->ninstructions]; ins++:
            ins->free()
        free(self->instructions)


class CfGraph:
    signature: Signature
    start_block: CfBlock  # First block
    end_block: CfBlock  # Always empty. Return statement jumps here.
    all_blocks: CfBlock**
    n_all_blocks: int
    locals: LocalVariable**   # First n variables are the function arguments
    nlocals: int

    def free(self) -> None:
        free_signature(&self->signature)
        for b = self->all_blocks; b < &self->all_blocks[self->n_all_blocks]; b++:
            (*b)->free()
            if *b != &self->start_block and *b != &self->end_block:
                free(*b)
        for v = self->locals; v < &self->locals[self->nlocals]; v++:
            free(*v)
        free(self->all_blocks)
        free(self->locals)


class CfGraphFile:
    filename: byte*
    graphs: CfGraph**  # only for defined functions
    ngraphs: int

    def free(self) -> None:
        for cfg = self->graphs; cfg < &self->graphs[self->ngraphs]; cfg++:
            (*cfg)->free()
            free(*cfg)
        free(self->graphs)


def very_short_number_type_description(t: Type*) -> byte*:
    if t->kind == TypeKind::FloatingPoint:
        return "floating"
    if t->kind == TypeKind::SignedInteger:
        return "signed"
    if t->kind == TypeKind::UnsignedInteger:
        return "unsigned"
    assert False


def print_cf_instruction(ins: CfInstruction*) -> None:
    printf("    line %-4d  ", ins->location.lineno)

    if ins->destvar != NULL:
        ins->destvar->print()
        printf(" = ")

    if ins->kind == CfInstructionKind::AddressOfLocalVar:
        printf("address of ")
        ins->operands[0]->print()
        printf(" (local variable)")
    elif ins->kind == CfInstructionKind::AddressOfGlobalVar:
        printf("address of %s (global variable)", ins->globalname)
    elif ins->kind == CfInstructionKind::SizeOf:
        printf("sizeof %s", ins->type->name)
    elif ins->kind == CfInstructionKind::BoolNegate:
        printf("boolean negation of ")
        ins->operands[0]->print()
    elif ins->kind == CfInstructionKind::Call:
        if get_self_class(&ins->signature) != NULL:
            printf("call method %s.", get_self_class(&ins->signature)->name)
        else:
            printf("call function ")
        printf("%s(", ins->signature.name)
        for i = 0; i < ins->noperands; i++:
            if i != 0:
                printf(", ")
            ins->operands[i]->print()
        printf(")")
    elif ins->kind == CfInstructionKind::NumCast:
        printf("number cast ")
        ins->operands[0]->print()
        printf(
            " (%d-bit %s --> %d-bit %s)",
            ins->operands[0]->type->size_in_bits,
            very_short_number_type_description(ins->operands[0]->type),
            ins->destvar->type->size_in_bits,
            very_short_number_type_description(ins->destvar->type),
        )
    elif ins->kind == CfInstructionKind::EnumToInt32:
        printf("cast ")
        ins->operands[0]->print()
        printf(" from enum to 32-bit signed int")
    elif ins->kind == CfInstructionKind::Int32ToEnum:
        printf("cast ")
        ins->operands[0]->print()
        printf(" from 32-bit signed int to enum")
    elif ins->kind == CfInstructionKind::PtrToInt64:
        printf("cast ")
        ins->operands[0]->print()
        printf(" to 64-bit integer")
    elif ins->kind == CfInstructionKind::Int64ToPtr:
        printf("cast ")
        ins->operands[0]->print()
        printf(" from 64-bit integer to pointer")
    elif ins->kind == CfInstructionKind::Constant:
        print_constant(&ins->constant)
    elif ins->kind == CfInstructionKind::SpecialConstant:
        printf("special constant \"%s\"", ins->scname)
    elif ins->kind == CfInstructionKind::StringArray:
        printf("string array ")
        print_string(ins->strarray.str, ins->strarray.len)
    elif (
        ins->kind == CfInstructionKind::NumAdd
        or ins->kind == CfInstructionKind::NumSub
        or ins->kind == CfInstructionKind::NumMul
        or ins->kind == CfInstructionKind::NumDiv
        or ins->kind == CfInstructionKind::NumMod
        or ins->kind == CfInstructionKind::NumEq
        or ins->kind == CfInstructionKind::NumLt
    ):
        if ins->kind == CfInstructionKind::NumAdd:
            printf("num add ")
        elif ins->kind == CfInstructionKind::NumSub:
            printf("num sub ")
        elif ins->kind == CfInstructionKind::NumMul:
            printf("num mul ")
        elif ins->kind == CfInstructionKind::NumDiv:
            printf("num div ")
        elif ins->kind == CfInstructionKind::NumMod:
            printf("num mod ")
        elif ins->kind == CfInstructionKind::NumEq:
            printf("num eq ")
        elif ins->kind == CfInstructionKind::NumLt:
            printf("num lt ")
        else:
            assert False
        ins->operands[0]->print()
        printf(", ")
        ins->operands[1]->print()
    elif ins->kind == CfInstructionKind::PtrLoad:
        # Extra parentheses to make these stand out a bit.
        printf("*(")
        ins->operands[0]->print()
        printf(")")
    elif ins->kind == CfInstructionKind::PtrStore:
        printf("*(")
        ins->operands[0]->print()
        printf(") = ")
        ins->operands[1]->print()
    elif ins->kind == CfInstructionKind::PtrAddInt:
        printf("ptr ")
        ins->operands[0]->print()
        printf(" + integer ")
        ins->operands[1]->print()
    elif ins->kind == CfInstructionKind::PtrClassField:
        ins->operands[0]->print()
        printf(" + offset of field \"%s\"", ins->fieldname)
    elif ins->kind == CfInstructionKind::PtrCast:
        printf("pointer cast ")
        ins->operands[0]->print()
    elif ins->kind == CfInstructionKind::PtrMemsetToZero:
        printf("set value of pointer ")
        ins->operands[0]->print()
        printf(" to zero bytes")
    elif ins->kind == CfInstructionKind::VarCpy:
        ins->operands[0]->print()
    else:
        assert False
    printf("\n")


def print_control_flow_graph(cfg: CfGraph*) -> None:
    printed_varnames_idx = 0

    sigstr: byte* = signature_to_string(&cfg->signature, True, True)
    printf("Function %s\n", sigstr)
    free(sigstr)

    printf("  Variables:\n")
    for var = cfg->locals; var < &cfg->locals[cfg->nlocals]; var++:
        printf("    ")
        (*var)->print()
        # Pad variable names with spaces to align them.
        for i = (*var)->print_width(); i < 20; i++:
            putchar(' ')
        # If variable name is very long, put two spaces even in that case.
        printf("  %s\n", (*var)->type->name)

    for blockidx = 0; blockidx < cfg->n_all_blocks; blockidx++:
        b = cfg->all_blocks[blockidx]

        printf("  Block %d", blockidx)
        #printf(" at %p", b)

        if b == &cfg->start_block:
            printf(" (start block)")
        if b == &cfg->end_block:
            assert b->ninstructions == 0
            printf(" is the end block.\n")
            continue

        printf(":\n")

        for ins = b->instructions; ins < &b->instructions[b->ninstructions]; ins++:
            print_cf_instruction(ins)

        if b == &cfg->end_block:
            assert b->iftrue == NULL
            assert b->iffalse == NULL
        elif b->iftrue == NULL and b->iffalse == NULL:
            printf("    Execution stops here. We have called a noreturn function.\n")
        else:
            trueidx = -1
            falseidx = -1
            for i = 0; i < cfg->n_all_blocks; i++:
                if cfg->all_blocks[i] == b->iftrue:
                    trueidx = i
                if cfg->all_blocks[i]==b->iffalse:
                    falseidx = i
            assert trueidx != -1
            assert falseidx != -1
            if trueidx == falseidx:
                printf("    Jump to block %d.\n", trueidx)
            else:
                assert b->branchvar != NULL
                printf("    If ")
                b->branchvar->print()
                printf(" is True jump to block %d, otherwise block %d.\n", trueidx, falseidx)

    printf("\n")


def print_control_flow_graphs(cfgfile: CfGraphFile*) -> None:
    printf("===== Control Flow Graphs for file \"%s\" =====\n", cfgfile->filename)
    for cfg = cfgfile->graphs; cfg < &cfgfile->graphs[cfgfile->ngraphs]; cfg++:
        print_control_flow_graph(*cfg)

