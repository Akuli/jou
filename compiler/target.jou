# LLVM makes a mess of how to define what kind of computer will run the
# compiled programs. Sometimes it wants a global_compiler_state.target triple, sometimes a
# data layout. Sometimes it wants a string, sometimes an object
# representing the thing.
#
# This file aims to provide everything you may ever need. Hopefully it
# will make the mess slightly less miserable to you. Just use the global
# "global_compiler_state.target" variable, it contains everything you will ever need.

import "stdlib/str.jou"
import "stdlib/io.jou"
import "stdlib/process.jou"

import "./llvm.jou"
import "./state.jou"


@public
class Target:
    ready: bool
    triple: byte[100]
    data_layout: byte[500]
    target: LLVMTarget*
    target_machine: LLVMTargetMachine*
    target_data: LLVMTargetData*


@public
def init_target() -> None:
    # Should be called only once because this affects LLVM's global state and
    # there's no cleanup to some of the things this does.
    assert not global_compiler_state.target.ready

    LLVMInitializeX86TargetInfo()
    LLVMInitializeX86Target()
    LLVMInitializeX86TargetMC()
    LLVMInitializeX86AsmParser()
    LLVMInitializeX86AsmPrinter()

    # Currently aarch64 is needed for:
    #   - new M1 macs
    #   - 64-bit raspberry pi
    if not WINDOWS:
        LLVMInitializeAArch64TargetInfo()
        LLVMInitializeAArch64Target()
        LLVMInitializeAArch64TargetMC()
        LLVMInitializeAArch64AsmParser()
        LLVMInitializeAArch64AsmPrinter()

    if WINDOWS:
        # LLVM's default is x86_64-pc-windows-msvc
        global_compiler_state.target.triple = "x86_64-pc-windows-gnu"
    else:
        triple = LLVMGetDefaultTargetTriple()
        assert strlen(triple) < sizeof global_compiler_state.target.triple
        strcpy(global_compiler_state.target.triple, triple)
        LLVMDisposeMessage(triple)

    error: byte* = NULL
    if LLVMGetTargetFromTriple(global_compiler_state.target.triple, &global_compiler_state.target.target, &error) != 0:
        assert error != NULL
        fprintf(get_stderr(), "LLVMGetTargetFromTriple(\"%s\") failed: %s\n", global_compiler_state.target.triple, error)
        exit(1)
    assert error == NULL
    assert global_compiler_state.target.target != NULL

    global_compiler_state.target.target_machine = LLVMCreateTargetMachine(
        global_compiler_state.target.target,
        global_compiler_state.target.triple,
        "",
        "",
        LLVMCodeGenOptLevel.Default,
        LLVMRelocMode.PIC,
        LLVMCodeModel.Default,
    )
    assert global_compiler_state.target.target_machine != NULL

    global_compiler_state.target.target_data = LLVMCreateTargetDataLayout(global_compiler_state.target.target_machine)
    assert global_compiler_state.target.target_data != NULL

    tmp = LLVMCopyStringRepOfTargetData(global_compiler_state.target.target_data)
    assert strlen(tmp) < sizeof global_compiler_state.target.data_layout
    strcpy(global_compiler_state.target.data_layout, tmp)
    LLVMDisposeMessage(tmp)

    if global_compiler_state.args.verbosity >= 2:
        printf("Target triple: %s\n", global_compiler_state.target.triple)
        printf("Data layout: %s\n", global_compiler_state.target.data_layout)

    global_compiler_state.target.ready = True
