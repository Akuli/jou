# LLVM makes a mess of how to define what kind of computer will run the
# compiled programs. Sometimes it wants a target triple, sometimes a
# data layout. Sometimes it wants a string, sometimes an object
# representing the thing.
#
# This file aims to provide everything you may ever need in one convenient
# struct. Hopefully it will make the mess slightly less miserable to you.

import "stdlib/assert.jou"
import "stdlib/str.jou"
import "stdlib/io.jou"
import "stdlib/process.jou"

import "./llvm.jou"
import "./state.jou"

if WINDOWS:
    const LLVM_HAS_X86: bool = True
    const LLVM_HAS_AARCH64: bool = False
    const LLVM_HAS_ARM: bool = False
    # LLVM's default is x86_64-pc-windows-msvc
    const JOU_TARGET: byte* = "x86_64-pc-windows-gnu"
else:
    import "../config.jou"


@public
class GlobalTarget:
    # Stuff that LLVM wants to share among all threads
    ready: bool
    triple: byte[100]
    target: LLVMTarget*
    data_layout: byte[500]
    feature_flags: byte[100]


@public
class ThreadLocalTarget:
    # Stuff that LLVM wants to be thread local for some reason. If you get this
    # distinction wrong, you will get random crashes that are hard to debug.
    machine: LLVMTargetMachine*
    data: LLVMTargetData*

    @public
    def free(self) -> None:
        LLVMDisposeTargetMachine(self.machine)
        LLVMDisposeTargetData(self.data)


@public
def init_global_target() -> None:
    # This should be called only once because this affects LLVM's global state and
    # there's no cleanup to some of the things this does.
    assert not global_compiler_state.target.ready
    global_compiler_state.target.ready = True


    dummy = LLVM_HAS_X86  # Workaround for useless compiler warning
    if dummy:
        LLVMInitializeX86TargetInfo()
        LLVMInitializeX86Target()
        LLVMInitializeX86TargetMC()
        LLVMInitializeX86AsmParser()
        LLVMInitializeX86AsmPrinter()

    # Currently aarch64 is needed for:
    #   - new M1 macs
    #   - 64-bit raspberry pi

    dummy = LLVM_HAS_AARCH64
    if dummy:
        LLVMInitializeAArch64TargetInfo()
        LLVMInitializeAArch64Target()
        LLVMInitializeAArch64TargetMC()
        LLVMInitializeAArch64AsmParser()
        LLVMInitializeAArch64AsmPrinter()

    dummy = LLVM_HAS_ARM
    if dummy:
        LLVMInitializeARMTargetInfo()
        LLVMInitializeARMTarget()
        LLVMInitializeARMTargetMC()
        LLVMInitializeARMAsmParser()
        LLVMInitializeARMAsmPrinter()


    if JOU_TARGET[0] != '\0':
        triple = JOU_TARGET
        assert strlen(triple) < sizeof global_compiler_state.target.triple
        strcpy(global_compiler_state.target.triple, triple)
    else:
        triple = LLVMGetDefaultTargetTriple()
        assert strlen(triple) < sizeof global_compiler_state.target.triple
        strcpy(global_compiler_state.target.triple, triple)
        LLVMDisposeMessage(triple)

    if (starts_with(global_compiler_state.target.triple, "armv6") and
        ends_with(global_compiler_state.target.triple, "hf")):
        strcpy(global_compiler_state.target.feature_flags, "+vfp2")

    error: byte* = NULL
    if LLVMGetTargetFromTriple(global_compiler_state.target.triple, &global_compiler_state.target.target, &error) != 0:
        assert error != NULL
        fprintf(get_stderr(), "LLVMGetTargetFromTriple(\"%s\") failed: %s\n", global_compiler_state.target.triple, error)
        exit(1)
    assert error == NULL
    assert global_compiler_state.target.target != NULL

    # The data layout is a string, hence always the same in all threads. But to
    # create it, we need an LLVMTargetData which is usually thread specific.
    #
    # LLVM is awesome, isn't it? All this just to get things to work without
    # corner cases where either the compiler or the program crashes...
    dummy_target = init_thread_local_target()
    tmp = LLVMCopyStringRepOfTargetData(dummy_target.data)
    assert strlen(tmp) < sizeof global_compiler_state.target.data_layout
    strcpy(global_compiler_state.target.data_layout, tmp)
    LLVMDisposeMessage(tmp)
    dummy_target.free()

    if global_compiler_state.args.verbosity >= 2:
        printf("Target triple: %s\n", global_compiler_state.target.triple)
        printf("Data layout: %s\n", global_compiler_state.target.data_layout)
        printf("CPU feature flags: %s\n", global_compiler_state.target.feature_flags)


@public
def init_thread_local_target() -> ThreadLocalTarget:
    assert global_compiler_state.target.ready

    machine = LLVMCreateTargetMachine(
        global_compiler_state.target.target,
        global_compiler_state.target.triple,
        "",
        global_compiler_state.target.feature_flags,
        LLVMCodeGenOptLevel.Default,
        LLVMRelocMode.PIC,
        LLVMCodeModel.Default,
    )
    assert machine != NULL

    data = LLVMCreateTargetDataLayout(machine)
    assert data != NULL

    return ThreadLocalTarget{machine = machine, data = data}
