# LLVM makes a mess of how to define what kind of computer will run the
# compiled programs. Sometimes it wants a target triple, sometimes a
# data layout. Sometimes it wants a string, sometimes an object
# representing the thing.
#
# This file aims to provide everything you may ever need in one convenient
# struct. Hopefully it will make the mess slightly less miserable to you.

import "stdlib/assert.jou"
import "stdlib/str.jou"
import "stdlib/io.jou"
import "stdlib/process.jou"

import "./llvm.jou"
import "./state.jou"

if not WINDOWS:
    import "../config.jou"


@public
class Target:
    ready: bool
    triple: byte[100]
    data_layout: byte[500]
    target: LLVMTarget*
    target_machine: LLVMTargetMachine*
    target_data: LLVMTargetData*


@public
def init_target(target: Target*) -> None:
    # This should be called only once because this affects LLVM's global state and
    # there's no cleanup to some of the things this does.
    assert not target.ready

    LLVMInitializeX86TargetInfo()
    LLVMInitializeX86Target()
    LLVMInitializeX86TargetMC()
    LLVMInitializeX86AsmParser()
    LLVMInitializeX86AsmPrinter()

    # Currently aarch64 is needed for:
    #   - new M1 macs
    #   - 64-bit raspberry pi
    if not WINDOWS:
        dummy = LLVM_HAS_AARCH64
        if dummy:
            LLVMInitializeAArch64TargetInfo()
            LLVMInitializeAArch64Target()
            LLVMInitializeAArch64TargetMC()
            LLVMInitializeAArch64AsmParser()
            LLVMInitializeAArch64AsmPrinter()

    if WINDOWS:
        # LLVM's default is x86_64-pc-windows-msvc
        target.triple = "x86_64-pc-windows-gnu"
    else:
        triple = LLVMGetDefaultTargetTriple()
        assert strlen(triple) < sizeof target.triple
        strcpy(target.triple, triple)
        LLVMDisposeMessage(triple)

    error: byte* = NULL
    if LLVMGetTargetFromTriple(target.triple, &target.target, &error) != 0:
        assert error != NULL
        fprintf(get_stderr(), "LLVMGetTargetFromTriple(\"%s\") failed: %s\n", target.triple, error)
        exit(1)
    assert error == NULL
    assert target.target != NULL

    target.target_machine = LLVMCreateTargetMachine(
        target.target,
        target.triple,
        "",
        "",
        LLVMCodeGenOptLevel.Default,
        LLVMRelocMode.PIC,
        LLVMCodeModel.Default,
    )
    assert target.target_machine != NULL

    target.target_data = LLVMCreateTargetDataLayout(target.target_machine)
    assert target.target_data != NULL

    tmp = LLVMCopyStringRepOfTargetData(target.target_data)
    assert strlen(tmp) < sizeof target.data_layout
    strcpy(target.data_layout, tmp)
    LLVMDisposeMessage(tmp)

    if global_compiler_state.args.verbosity >= 2:
        printf("Target triple: %s\n", target.triple)
        printf("Data layout: %s\n", target.data_layout)

    target.ready = True
