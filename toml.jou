# TOML spec: https://toml.io/en/v1.1.0

import "stdlib/ascii.jou"
import "stdlib/assert.jou"
import "stdlib/io.jou"
import "stdlib/list.jou"
import "stdlib/mem.jou"
import "stdlib/str.jou"


class TOMLKeyVal:
    key: byte*
    value: TOMLValue


enum TOMLValueKind:
    Table  # first, so this is the default with zero-init
    String

class TOMLValue:
    kind: TOMLValueKind
    union:
        table: List[TOMLKeyVal]
        string: byte*

    def free(self) -> None:
        match self.kind:
            case TOMLValueKind.String:
                free(self.string)

            case TOMLValueKind.Table:
                for i = 0; i < self.table.len; i++:
                    kv = self.table.ptr[i]
                    free(kv.key)
                    kv.value.free()  # recursive call
                free(self.table.ptr)


class TOMLParser:
    ptr: byte*
    target: TOMLValue*
    error: byte[1024]

    def fail(self) -> noreturn:
        printf("Parser Error at: %s\n", self.ptr)
        assert False  # TODO: propagate errors out with return values, not like this

    # Names of many methods are according to this:
    # https://github.com/toml-lang/toml/blob/bcbbd1c1f03473ffe97b8bf26a0fc945efe2b4a1/toml.abnf

    def toml(self) -> None:
        self.expression()
        while *self.ptr == '\n':
            self.ptr++
            self.expression()
        if *self.ptr != '\0':
            self.fail()

    def expression(self) -> None:
        self.ws()
        match *self.ptr:
            case '[':
                self.table()
                self.ws()
                if *self.ptr == '#':
                    self.comment()
            case '\n' | '\0':
                pass
            case '#':
                self.comment()
            case _:
                self.keyval()
                self.ws()
                if *self.ptr == '#':
                    self.comment()

    def ws(self) -> None:
        while *self.ptr == ' ' or *self.ptr == '\t':
            self.ptr++

#    def newline(self) -> None:
#        if *self.ptr == '\r':
#            self.ptr++
#        if *self.ptr != '\n':
#            self.fail()
#        self.ptr++

    def comment(self) -> None:
        assert *self.ptr == '#'
        while *self.ptr != '\0' and *self.ptr != '\n':
            b = *self.ptr
            if not (b >= 128 or b == '\t' or (32 <= b and b <= 126)):
                self.fail()
            self.ptr++

    def keyval(self) -> None:
        old_target = self.target
        self.key()
        self.ws()
        if *self.ptr != '=':
            self.fail()
        self.ptr++
        self.ws()
        self.val()
        self.target = old_target

    # Not exactly right according to the spec, because this ends with a call to
    # .ws() but a key shouldn't include trailing whitespace. We'll see if that
    # matters, maybe not...
    def key(self) -> None:
        self.simple_key()
        self.ws()
        while *self.ptr == '.':
            self.ptr++
            self.ws()
            self.simple_key()
            self.ws()

    def simple_key(self) -> None:
        key: byte*
        match *self.ptr:
            case '"':
                key = self.basic_string()
            case '\'':
                key = self.literal_string()
            case _:
                n = 0
                while (
                    is_ascii_letter(self.ptr[n])
                    or is_ascii_digit(self.ptr[n])
                    or self.ptr[n] == '-'
                    or self.ptr[n] == '_'
                ):
                    n++
                if n == 0:
                    self.fail()
                key = NULL
                asprintf(&key, "%.*s", n, self.ptr)
                assert key != NULL
                self.ptr = &self.ptr[n]

        if self.target.kind != TOMLValueKind.Table:
            self.fail()

        # Does this key already exists?
        for p = self.target.table.ptr; p < self.target.table.end(); p++:
            if strcmp(p.key, key) == 0:
                # Yes, let's go there
                free(key)
                self.target = &p.value
                return

        # Key not found --> create new table
        self.target.table.append(TOMLKeyVal{key = key})
        self.target = &self.target.table.end()[-1].value

    def val(self) -> None:
        match *self.ptr:
            case '"':
                if starts_with(self.ptr, "\"\"\""):
                    s = self.ml_basic_string()
                else:
                    s = self.basic_string()
                assert s != NULL
                *self.target = TOMLValue{kind = TOMLValueKind.String, string = s}
            case '\'':
                if starts_with(self.ptr, "'''"):
                    s = self.ml_literal_string()
                else:
                    s = self.literal_string()
                assert s != NULL
                *self.target = TOMLValue{kind = TOMLValueKind.String, string = s}
            case _:
                # TODO: support other types of values
                assert False

    def basic_string(self) -> byte*:
        assert *self.ptr == '"'
        self.ptr++

        result = List[byte]{}
        while *self.ptr != '"' and *self.ptr != '\0':
            result.append(self.basic_char())
        self.ptr++

        result.append('\0')
        return result.ptr

    def basic_char(self) -> byte:
        if *self.ptr == '\\':
            return self.escaped()
        else:
            return self.basic_unescaped()

    def basic_unescaped(self) -> byte:
        if (
            *self.ptr == '\t'
            or *self.ptr == ' '
            or *self.ptr == '!'
            or (*self.ptr >= 0x23 and *self.ptr <= 0x5b)
            or (*self.ptr >= 0x5d and *self.ptr <= 0x7e)
            or *self.ptr >= 128  # TODO: reject invalid UTF-8
        ):
            return *self.ptr++
        self.fail()

    def escaped(self) -> byte:
        assert *self.ptr == '\\'
        self.ptr++
        c = *self.ptr++
        match c:
            case '"':
                return '"'
            case '\\':
                return '\\'
            case 'b':
                return 0x08  # Jou doesn't have \b
            case 'e':
                return 0x1b  # Jou doesn't have \e
            case 'f':
                return 0x0c  # Jou doesn't have \f
            case 'n':
                return '\n'
            case 'r':
                return '\r'
            case 't':
                return '\t'
            case 'x':
                assert False  # TODO: \xHH hex escape
            case 'u':
                assert False  # TODO: \uHHHH hex escape
            case 'U':
                assert False  # TODO: \UHHHHHHHH hex escape
            case _:
                self.fail()

    def ml_basic_string(self) -> byte*:
        assert False  # TODO

    def literal_string(self) -> byte*:
        assert *self.ptr == '\''
        self.ptr++
        result = List[byte]{}
        while *self.ptr != '\'':
            result.append(self.literal_char())
        self.ptr++
        result.append('\0')
        return result.ptr

    def literal_char(self) -> byte:
        if (
            *self.ptr == '\t'
            or (0x20 <= *self.ptr and *self.ptr <= 0x26)
            or (0x28 <= *self.ptr and *self.ptr <= 0x7e)
            or *self.ptr >= 128  # TODO: reject invalid UTF-8
        ):
            return *self.ptr++
        self.fail()

    def ml_literal_string(self) -> byte*:
        assert False  # TODO

    def table(self) -> None:
        assert False  # TODO


def print_toml_value(value: TOMLValue, depth: int) -> None:
    match value.kind:
        case TOMLValueKind.Table:
            printf("table:\n")
            for i = 0; i < value.table.len; i++:
                kv = value.table.ptr[i]
                printf("%*s", 2*(depth + 1), "")
                printf("%s = ", kv.key)
                print_toml_value(kv.value, depth + 1)

        case TOMLValueKind.String:
            printf("string: %s\n", value.string)


def main() -> int:
    examples = [
        # These are directly from documentation https://toml.io/en/v1.1.0
        "# This is a full-line comment\nkey = \"value\"  # This is a comment at the end of a line\nanother = \"# This is not a comment\"",
        "key = \"value\"",
        #"key = # INVALID",  # should fail
        #"first = \"Tom\" last = \"Preston-Werner\" # INVALID"  # should fail
        "key = \"value\"\nbare_key = \"value\"\nbare-key = \"value\"\n1234 = \"value\"\n",
        "\"127.0.0.1\" = \"value\"\n\"character encoding\" = \"value\"\n\"ʎǝʞ\" = \"value\"\n'key2' = \"value\"\n'quoted \"value\"' = \"value\"",
    ]

    for i = 0; i < array_count(examples); i++:
        printf("============================== examples[%d] ==============================\n", i)
        result = TOMLValue{}
        parser = TOMLParser{ptr = examples[i], target = &result}
        parser.toml()
        assert result.kind == TOMLValueKind.Table
        print_toml_value(result, 0)
        result.free()
        printf("\n")

    return 0
