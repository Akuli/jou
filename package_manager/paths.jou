import "stdlib/str.jou"
import "stdlib/io.jou"
import "stdlib/mem.jou"

if WINDOWS:
    declare _mkdir(path: byte*) -> int
    declare _chdir(path: byte*) -> int
else:
    declare mkdir(path: byte*, mode: int) -> int
    declare chdir(path: byte*) -> int


@public
def my_mkdir(path: byte*) -> int:
    if WINDOWS:
        return _mkdir(path)
    else:
        return mkdir(path, 0o777)  # this is what mkdir in bash does according to strace


def my_chdir(path: byte*) -> int:
    if WINDOWS:
        return _chdir(path)
    else:
        return chdir(path)


# If joupkg is ran from a subfolder within a project, change to project root
# folder. Basically, this makes joupkg less nit-picky about what directory to
# run it in.
#
# Project root folder is detected based on whether it contains joupkg.toml.
# When running "joupkg install" in a fresh project, joupkg.toml doesn't exist
# yet. In that case we don't change directory at all.
#
# Detecting existence of ".git" or "README.md" or similar would be bad, because
# you may want to have a Jou project as a folder inside a larger repository.
@public
def cd_to_project_root() -> None:
    folders = [
        ".",
        "..",
        "../..",
        "../../..",
        "../../../..",
        "../../../../..",
        "../../../../../..",
        "../../../../../../..",
        "../../../../../../../..",
        "../../../../../../../../..",
    ]
    for i = 0; i < sizeof(folders)/sizeof(folders[0]); i++:
        joupkg_toml_path: byte*
        asprintf(&joupkg_toml_path, "%s/joupkg.toml", folders[i])
        f = fopen(joupkg_toml_path, "r")
        free(joupkg_toml_path)

        if f != NULL:
            fclose(f)
            my_chdir(folders[i])
            return
