# TOML spec: https://toml.io/en/v1.1.0

import "stdlib/ascii.jou"
import "stdlib/process.jou"
import "stdlib/assert.jou"
import "stdlib/io.jou"
import "stdlib/limits.jou"
import "stdlib/list.jou"
import "stdlib/mem.jou"
import "stdlib/str.jou"


class TOMLKeyVal:
    key: byte*
    value: TOMLValue


enum TOMLValueKind:
    Unset  # must be first, so initializes to this
    Table
    String
    Boolean
    Integer

class TOMLValue:
    kind: TOMLValueKind
    union:
        table: List[TOMLKeyVal]
        string: byte*
        boolean: bool
        integer: int64

    def free(self) -> None:
        match self.kind:
            case TOMLValueKind.String:
                free(self.string)
            case TOMLValueKind.Table:
                for i = 0; i < self.table.len; i++:
                    kv = self.table.ptr[i]
                    free(kv.key)
                    kv.value.free()  # recursive call
                free(self.table.ptr)
            case TOMLValueKind.Boolean | TOMLValueKind.Integer | TOMLValueKind.Unset:
                pass

def digit_value(b: byte) -> int:
    if '0' <= b and b <= '9':
        return b - '0'
    if 'A' <= b and b <= 'F':
        return b - 'A'
    if 'a' <= b and b <= 'f':
        return b - 'a'
    return -1


class TOMLParser:
    filename: byte*
    file_content_start: byte*
    ptr: byte*
    target: TOMLValue*
    error: byte[1024]

    def fail(self, message: byte*) -> noreturn:
        # Work out line number
        assert self.ptr >= self.file_content_start
        lineno = 1
        for p = self.ptr; p < self.file_content_start; p++:
            if *p == '\n':
                lineno++

        fprintf(get_stderr(), "invalid TOML syntax in file \"%s\", line %d: %s\n", message)
        exit(1)

    # Names of many methods are according to this:
    # https://github.com/toml-lang/toml/blob/bcbbd1c1f03473ffe97b8bf26a0fc945efe2b4a1/toml.abnf

    def toml(self) -> None:
        self.expression()
        while *self.ptr == '\n':
            self.ptr++
            self.expression()
        if *self.ptr != '\0':
            self.fail("junk at end of line")

    def expression(self) -> None:
        self.ws()
        match *self.ptr:
            case '[':
                self.table()
                self.ws()
                if *self.ptr == '#':
                    self.comment()
            case '\n' | '\0':
                pass
            case '#':
                self.comment()
            case _:
                self.keyval()
                self.ws()
                if *self.ptr == '#':
                    self.comment()

    def ws(self) -> None:
        while *self.ptr == ' ' or *self.ptr == '\t':
            self.ptr++

#    def newline(self) -> None:
#        if *self.ptr == '\r':
#            self.ptr++
#        if *self.ptr != '\n':
#            self.fail()
#        self.ptr++

    def comment(self) -> None:
        assert *self.ptr == '#'
        while *self.ptr != '\0' and *self.ptr != '\n':
            b = *self.ptr
            if not (b >= 128 or b == '\t' or (32 <= b and b <= 126)):
                self.fail("invalid character in comment")
            self.ptr++

    def keyval(self) -> None:
        old_target = self.target
        self.key()
        self.ws()
        if *self.ptr != '=':
            self.fail("there should be '=' after a key")
        self.ptr++
        self.ws()
        self.val()
        self.target = old_target

    # Not exactly right according to the spec, because this ends with a call to
    # .ws() but a key shouldn't include trailing whitespace. We'll see if that
    # matters, maybe not...
    def key(self) -> None:
        self.simple_key()
        self.ws()
        while *self.ptr == '.':
            self.ptr++
            self.ws()
            self.simple_key()
            self.ws()

    def simple_key(self) -> None:
        key: byte*
        match *self.ptr:
            case '"':
                key = self.basic_string()
            case '\'':
                key = self.literal_string()
            case _:
                n = 0
                while (
                    is_ascii_letter(self.ptr[n])
                    or is_ascii_digit(self.ptr[n])
                    or self.ptr[n] == '-'
                    or self.ptr[n] == '_'
                ):
                    n++
                if n == 0:
                    self.fail("failed to parse the key in 'key = value' syntax")
                key = NULL
                asprintf(&key, "%.*s", n, self.ptr)
                assert key != NULL
                self.ptr = &self.ptr[n]

        assert self.target.kind == TOMLValueKind.Table

        # Does this key already exists?
        for p = self.target.table.ptr; p < self.target.table.end(); p++:
            if strcmp(p.key, key) == 0:
                # Yes, let's go there
                free(key)
                self.target = &p.value
                return

        # Key not found --> create new table
        self.target.table.append(TOMLKeyVal{
            key = key,
            value = TOMLValue{kind = TOMLValueKind.Table},
        })
        self.target = &self.target.table.end()[-1].value

    def val(self) -> None:
        # TODO: why is this needed?
        self.target.free()
        *self.target = TOMLValue{}

        match *self.ptr:
            case '"':
                if starts_with(self.ptr, "\"\"\""):
                    s = self.ml_basic_string()
                else:
                    s = self.basic_string()
                assert s != NULL
                *self.target = TOMLValue{kind = TOMLValueKind.String, string = s}
            case '\'':
                if starts_with(self.ptr, "'''"):
                    s = self.ml_literal_string()
                else:
                    s = self.literal_string()
                assert s != NULL
                *self.target = TOMLValue{kind = TOMLValueKind.String, string = s}
            case 't':
                if not starts_with(self.ptr, "true"):
                    self.fail("failed to parse value")
                *self.target = TOMLValue{kind = TOMLValueKind.Boolean, boolean = True}
                self.ptr = &self.ptr[4]
            case '+' | '-' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9':
                n = self.integer()
                *self.target = TOMLValue{kind = TOMLValueKind.Integer, integer = n}
            case _:
                puts(self.ptr)
                # TODO: support other types of values
                assert False

    def unsigned_integer_in_base(self, base: int) -> uint64:
        first_digit_value = digit_value(*self.ptr)
        if first_digit_value != -1 and first_digit_value < base:
            result: uint64 = first_digit_value as uint64
            self.ptr++
            while True:
                if *self.ptr == '_':
                    self.ptr++
                    continue
                v = digit_value(*self.ptr)
                if v == -1:
                    return result
                if v >= base:
                    break  # show error message
                # Don't allow 01, 001 etc
                if base == 10 and first_digit_value == 0:
                    self.fail("integer starts with an unnecessary zero")
                new_result = result*(base as uint64) + (v as uint64)
                if new_result/base != result:
                    # it overflowed
                    return UINT64_MAX
                result = new_result
                self.ptr++

        match base:
            case 2:
                self.fail("invalid binary number")
            case 8:
                self.fail("invalid octal number")
            case 10:
                self.fail("invalid number")
            case 16:
                self.fail("invalid hexadecimal number")
            case _:
                assert False

    def integer(self) -> int64:
        sign = 1
        if starts_with(self.ptr, "0b"):
            base = 2
        elif starts_with(self.ptr, "0o"):
            base = 8
        elif starts_with(self.ptr, "0x"):
            base = 16
        else:
            base = 10
            # Only base 10 numbers can be negative in TOML!
            if *self.ptr == '-':
                sign = -1
            if *self.ptr == '+' or *self.ptr == '-':
                self.ptr++

        if base != 10:
            self.ptr = &self.ptr[2]

        u = self.unsigned_integer_in_base(base)

        # Special casing to make sure the most negative int64 value works.
        # Its absolute value doesn't fit in int64.
        # TODO: this needed?
        if sign == -1 and u == (INT64_MAX as uint64) + 1:
            return INT64_MIN

        if u > INT64_MAX:
            self.fail("integer doesn't fit in a Jou int64")
        return sign*(u as int64)

    def basic_string(self) -> byte*:
        assert *self.ptr == '"'
        self.ptr++

        result = List[byte]{}
        while *self.ptr != '"' and *self.ptr != '\0':
            result.append(self.basic_char())
        self.ptr++

        result.append('\0')
        return result.ptr

    def basic_char(self) -> byte:
        if *self.ptr == '\\':
            return self.escaped()
        else:
            return self.basic_unescaped()

    def basic_unescaped(self) -> byte:
        if (
            *self.ptr == '\t'
            or *self.ptr == ' '
            or *self.ptr == '!'
            or (*self.ptr >= 0x23 and *self.ptr <= 0x5b)
            or (*self.ptr >= 0x5d and *self.ptr <= 0x7e)
            or *self.ptr >= 128  # TODO: reject invalid UTF-8
        ):
            return *self.ptr++
        self.fail("bad character inside string")

    def escaped(self) -> byte:
        assert *self.ptr == '\\'
        self.ptr++
        c = *self.ptr++
        match c:
            case '"':
                return '"'
            case '\\':
                return '\\'
            case 'b':
                return 0x08  # Jou doesn't have \b
            case 'e':
                return 0x1b  # Jou doesn't have \e
            case 'f':
                return 0x0c  # Jou doesn't have \f
            case 'n':
                return '\n'
            case 'r':
                return '\r'
            case 't':
                return '\t'
            case 'x':
                assert False  # TODO: \xHH hex escape
            case 'u':
                assert False  # TODO: \uHHHH hex escape
            case 'U':
                assert False  # TODO: \UHHHHHHHH hex escape
            case _:
                self.fail("bad backslash escape in string")

    def ml_basic_string(self) -> byte*:
        assert False  # TODO

    def literal_string(self) -> byte*:
        assert *self.ptr == '\''
        self.ptr++
        result = List[byte]{}
        while *self.ptr != '\'':
            result.append(self.literal_char())
        self.ptr++
        result.append('\0')
        return result.ptr

    def literal_char(self) -> byte:
        if (
            *self.ptr == '\t'
            or (0x20 <= *self.ptr and *self.ptr <= 0x26)
            or (0x28 <= *self.ptr and *self.ptr <= 0x7e)
            or *self.ptr >= 128  # TODO: reject invalid UTF-8
        ):
            return *self.ptr++
        self.fail("bad character inside string")

    def ml_literal_string(self) -> byte*:
        assert False  # TODO

    def table(self) -> None:
        assert False  # TODO


def print_toml_value(value: TOMLValue, depth: int) -> None:
    match value.kind:
        case TOMLValueKind.Unset:
            puts("UNSET")
        case TOMLValueKind.Table:
            printf("table:\n")
            for i = 0; i < value.table.len; i++:
                kv = value.table.ptr[i]
                printf("%*s", 2*(depth + 1), "")
                printf("%s = ", kv.key)
                print_toml_value(kv.value, depth + 1)
        case TOMLValueKind.String:
            printf("string: %s\n", value.string)
        case TOMLValueKind.Boolean:
            puts("boolean: true" if value.boolean else "boolean: false")
        case TOMLValueKind.Integer:
            printf("integer: %lld\n", value.integer)


def main() -> int:
    examples = [
        # These are directly from documentation https://toml.io/en/v1.1.0
        "# This is a full-line comment\nkey = \"value\"  # This is a comment at the end of a line\nanother = \"# This is not a comment\"",
        "key = \"value\"",
        #"key = # INVALID",  # should fail
        #"first = \"Tom\" last = \"Preston-Werner\" # INVALID",  # should fail
        "key = \"value\"\nbare_key = \"value\"\nbare-key = \"value\"\n1234 = \"value\"\n",
        "\"127.0.0.1\" = \"value\"\n\"character encoding\" = \"value\"\n\"ʎǝʞ\" = \"value\"\n'key2' = \"value\"\n'quoted \"value\"' = \"value\"",
        "name = \"Orange\"\nphysical.color = \"orange\"\nphysical.shape = \"round\"\nsite.\"google.com\" = true\n",
        "fruit.name = \"banana\"       # this is best practice\nfruit. color = \"yellow\"     # same as fruit.color\nfruit . flavor = \"banana\"   # same as fruit.flavor\n",
        # TODO: should be invalid!
        "# DO NOT DO THIS\nname = \"Tom\"\nname = \"Pradyun\"",
        # TODO: should be invalid!
        "# THIS WILL NOT WORK\nspelling = \"favorite\"\n\"spelling\" = \"favourite\"\n",
        "# This makes the key \"fruit\" into a table.\nfruit.apple.smooth = true\n\n# So then you can add to the table \"fruit\" like so:\nfruit.orange = 2",
    ]

    for i = 0; i < array_count(examples); i++:
        printf("============================== examples[%d] ==============================\n", i)
        result = TOMLValue{kind = TOMLValueKind.Table}
        parser = TOMLParser{ptr = examples[i], target = &result}
        parser.toml()
        assert result.kind == TOMLValueKind.Table
        print_toml_value(result, 0)
        result.free()
        printf("\n")

    return 0
