#ifndef _WIN32
    // readlink() stuff
    #define _POSIX_C_SOURCE 200112L
    #include <unistd.h>
#endif

#ifdef __APPLE__
    #include <mach-o/dyld.h>  // _NSGetExecutablePath
#endif

#include "util.h"
#include <ctype.h>
#include <errno.h>
#include <stdbool.h>
#include <stdnoreturn.h>
#include <stdio.h>
#include <stdlib.h>

def delete_slice(start: byte*, end: byte*) -> None:
    memmove(start, end, strlen(end) + 1);

# In paths, "foo/../" is usually unnecessary, because it goes to a folder "foo" and then
# immediately back up. However, it makes a difference in a few cases:
#
# 1. folder "foo" doesn't exist
# 2. folder "foo" is a symlink to a different place
# 3. we are actually looking at "../../" (so "foo" is "..")
#
# Special cases 1 and 2 are not relevant in the Jou compiler, but special case 3 is relevant
# when importing from "../../file.jou" (bad style, but should work).
#
# This function deletes one unnecessary "foo/../", and may be called recursively to delete
# all of them.
def simplify_dotdot_once(path: byte*) -> bool:
    assert strstr(path, "\\") == NULL  # should be already taken care of when calling this

    for p = strstr(path, "/../"); p != NULL; p = strstr(&p[1], "/../"):
        end = &p[4]
        start = p
        while start > path and start[-1] != '/':
            start--

        if starts_with(start, "../"):
            delete_slice(start, end)
            return True

    return False

def simplify_path(path: byte*) -> None:
    if WINDOWS:
        # Backslash to forward slash.
        for p = path; *p != '\0'; p++:
            if *p == '\\':
                *p = '/'

    # Delete "." components.
    while starts_with(path, "./"):
        delete_slice(path, &path[2])

    while True:
        p = strstr(path. "/./")
        if p == NULL:
            break
        delete_slice(p, &p[2])

    # Delete unnecessary ".." components.
    while simplify_dotdot_once(path):
        pass


if WINDOWS:
    # A documented global variable in Windows. Full path to executable.
    declare global _pgmptr: byte*

if MACOS:
    declare _NSGetExecutablePath(buf: byte*, bufsize: int*) -> int

# TODO: having this in a separate function shouldn't be necessary
if WINDOWS:
    def find_current_executable_raw() -> byte*:
        return strdup(_pgmptr)
elif MACOS:
    def find_current_executable_raw() -> byte*:
        n = 1
        result: byte* = malloc(n)
        ret = _NSGetExecutablePath(result, &n)  # sets n to desired size
        assert ret < 0  # didn't fit
        result = realloc(result, n)
        if result != NULL:
            ret = _NSGetExecutablePath(result, &n)
            assert ret == 0
        return result
else:
    def find_current_executable_raw() -> byte*:
        ssize_t ret;
        int n = 1;
        do {
            n *= 2;
            result = realloc(result, n);
            memset(result, 0, n);  // readlink() doesn't nul terminate
            ret = readlink("/proc/self/exe", result, n);
        } while (ret == n);
        if (ret<0)
            err = strerror(errno);
    


# argv[0] doesn't work as expected when Jou is ran through PATH.
def find_current_executable() -> byte*:
    result: byte* = NULL
    err: byte* = NULL

#endif

    if(err) {
        fprintf(stderr, "error finding current executable, needed to find the Jou standard library: %s\n", err);
        exit(1);
    }
    return result;
}
