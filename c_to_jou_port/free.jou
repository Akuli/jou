# Boring boilerplate code to free up data structures used in compilation.

import "./structs.jou"
import "./types.jou"
import "stdlib/mem.jou"

def free_tokens(tokenlist: Token*) -> None:
    for t = tokenlist; t->type != TokenKind::EndOfFile; t++:
        if t->type == TokenKind::String:
            free(t->string_value)
    free(tokenlist)

def free_constant(c: Constant*) -> None:
    if c->kind == ConstantKind::String:
        free(c->str)

def free_ast_type(t: AstType*) -> None:
    if t->kind == AstTypeKind::Array:
        free_expression(t->array.len)
        free(t->array.len)
        free_ast_type(t->array.membertype)
        free(t->array.membertype)
    elif t->kind == AstTypeKind::Pointer:
        free_ast_type(t->valuetype)
        free(t->valuetype)
    elif t->kind == AstTypeKind::Named:
        pass
    else:
        assert False

def free_name_type_value(ntv: AstNameTypeValue*) -> None:
    free_ast_type(&ntv->type)
    if ntv->value != NULL:
        free_expression(ntv->value)
        free(ntv->value)

def free_ast_signature(sig: AstSignature*) -> None:
    for ntv = sig->args; ntv < &sig->args[sig->nargs]; ntv++:
        free_name_type_value(ntv)
    free(sig->args)
    free_ast_type(&sig->returntype)

def free_call(call: AstCall*) -> None:
    for i = 0; i < call->nargs; i++:
        free_expression(&call->args[i])
    free(call->argnames)
    free(call->args)

def free_expression(expr: AstExpression*) -> None:
    if (
        expr->kind == AstExpressionKind::FunctionCall
        or expr->kind == AstExpressionKind::BraceInit
    ):
        free_call(&expr->call)
    elif (
        expr->kind == AstExpressionKind::GetField
        or expr->kind == AstExpressionKind::DerefAndGetField
    ):
        free_expression(expr->classfield.obj)
        free(expr->classfield.obj)
    elif (
        expr->kind == AstExpressionKind::CallMethod
        or expr->kind == AstExpressionKind::DerefAndCallMethod
    ):
        free_expression(expr->methodcall.obj)
        free(expr->methodcall.obj)
        free_call(&expr->methodcall.call)
    elif expr->kind == AstExpressionKind::Array:
        for i = 0; i < expr->array.count; i++:
            free_expression(&expr->array.items[i])
        free(expr->array.items)
    elif (
        expr->kind == AstExpressionKind::Indexing
        or expr->kind == AstExpressionKind::Add
        or expr->kind == AstExpressionKind::Sub
        or expr->kind == AstExpressionKind::Mul
        or expr->kind == AstExpressionKind::Div
        or expr->kind == AstExpressionKind::Mod
        or expr->kind == AstExpressionKind::Eq
        or expr->kind == AstExpressionKind::Ne
        or expr->kind == AstExpressionKind::Gt
        or expr->kind == AstExpressionKind::Ge
        or expr->kind == AstExpressionKind::Lt
        or expr->kind == AstExpressionKind::Le
        or expr->kind == AstExpressionKind::And
        or expr->kind == AstExpressionKind::Or
    ):
        free_expression(&expr->operands[0])
        free_expression(&expr->operands[1])
        free(expr->operands)
    elif (
        expr->kind == AstExpressionKind::Neg
        or expr->kind == AstExpressionKind::Not
        or expr->kind == AstExpressionKind::AddressOf
        or expr->kind == AstExpressionKind::Dereference
        or expr->kind == AstExpressionKind::PreIncrement
        or expr->kind == AstExpressionKind::PreDecrement
        or expr->kind == AstExpressionKind::PostIncrement
        or expr->kind == AstExpressionKind::PostDecrement
        or expr->kind == AstExpressionKind::SizeOf
    ):
        free_expression(&expr->operands[0])
        free(expr->operands)
    elif expr->kind == AstExpressionKind::As:
        free_expression(expr->as_.obj)
        free(expr->as_.obj)
        free_ast_type(&expr->as_.type)
    elif expr->kind == AstExpressionKind::Constant:
        free_constant(&expr->constant)
    elif (
        expr->kind == AstExpressionKind::GetVariable
        or expr->kind == AstExpressionKind::GetEnumMember
    ):
        pass
    else:
        assert False

def free_ast_statement(stmt: AstStatement*) -> None:
    if stmt->kind == AstStatementKind::If:
        for i = 0; i < stmt->ifstatement.n_if_and_elifs; i++:
            free_expression(&stmt->ifstatement.if_and_elifs[i].condition)
            free_ast_body(&stmt->ifstatement.if_and_elifs[i].body)
        free(stmt->ifstatement.if_and_elifs)
        free_ast_body(&stmt->ifstatement.elsebody)
    elif stmt->kind == AstStatementKind::While:
        free_expression(&stmt->whileloop.condition)
        free_ast_body(&stmt->whileloop.body)
    elif stmt->kind == AstStatementKind::For:
        free_ast_statement(stmt->forloop.init)
        free_expression(&stmt->forloop.cond)
        free_ast_statement(stmt->forloop.incr)
        free(stmt->forloop.init)
        free(stmt->forloop.incr)
        free_ast_body(&stmt->forloop.body)
    elif stmt->kind == AstStatementKind::Assert:
        free_expression(&stmt->assertion.condition)
        free(stmt->assertion.condition_str)
    elif stmt->kind == AstStatementKind::ExpressionStatement:
        free_expression(&stmt->expression)
    elif stmt->kind == AstStatementKind::Return:
        if stmt->returnvalue != NULL:
            free_expression(stmt->returnvalue)
            free(stmt->returnvalue)
    elif (
        stmt->kind == AstStatementKind::DeclareLocalVar
        or stmt->kind == AstStatementKind::DeclareGlobalVar
        or stmt->kind == AstStatementKind::DefineGlobalVar
    ):
        free_name_type_value(&stmt->vardecl)
    elif (
        stmt->kind == AstStatementKind::Assign
        or stmt->kind == AstStatementKind::InPlaceAdd
        or stmt->kind == AstStatementKind::InPlaceSub
        or stmt->kind == AstStatementKind::InPlaceMul
        or stmt->kind == AstStatementKind::InPlaceDiv
        or stmt->kind == AstStatementKind::InPlaceMod
    ):
        free_expression(&stmt->assignment.target)
        free_expression(&stmt->assignment.value)
    elif (
        stmt->kind == AstStatementKind::Break
        or stmt->kind == AstStatementKind::Continue
        or stmt->kind == AstStatementKind::Pass
    ):
        pass
    elif stmt->kind == AstStatementKind::Function:
        free_ast_signature(&stmt->function.signature)
        free_ast_body(&stmt->function.body)
    elif stmt->kind == AstStatementKind::DefineClass:
        for m = stmt->classdef.members; m < &stmt->classdef.members[stmt->classdef.nmembers]; m++:
            if m->kind == AstClassMemberKind::Field:
                free_name_type_value(&m->field)
            elif m->kind == AstClassMemberKind::Union:
                for ntv = m->unionfields.fields; ntv < &m->unionfields.fields[m->unionfields.nfields]; ntv++:
                    free_name_type_value(ntv)
                free(m->unionfields.fields)
            elif m->kind == AstClassMemberKind::Method:
                free_ast_signature(&m->method.signature)
                free_ast_body(&m->method.body)
            else:
                assert False
        free(stmt->classdef.members)
    elif stmt->kind == AstStatementKind::DefineEnum:
        free(stmt->enumdef.membernames)
    else:
        assert False

def free_ast_body(body: AstBody*) -> None:
    for i = 0; i < body->nstatements; i++:
        free_ast_statement(&body->statements[i])
    free(body->statements)

def free_ast(ast: AstFile*) -> None:
    for imp = ast->imports; imp < &ast->imports[ast->nimports]; imp++:
        free(imp->specified_path)
        free(imp->resolved_path)
    free(ast->imports)
    free_ast_body(&ast->body)


def free_signature(sig: Signature*) -> None:
    free(sig->argnames)
    free(sig->argtypes)

def free_export_symbol(es: ExportSymbol*) -> None:
    if es->kind == ExportSymbolKind::Function:
        free_signature(&es->funcsignature)

def free_file_types(ft: FileTypes*) -> None:
    for t = ft->owned_types; t < &ft->owned_types[ft->n_owned_types]; t++:
        free_type(*t)
    for func = ft->functions; func < &ft->functions[ft->nfunctions]; func++:
        free_signature(&func->signature)
    for fom = ft->fomtypes; fom < &ft->fomtypes[ft->nfomtypes]; fom++:
        for et = fom->expr_types; et < &fom->expr_types[fom->n_expr_types]; et++:
            free(*et)
        free(fom->expr_types)
        free(fom->locals)  # Don't free individual locals because they're owned by CFG now
        free_signature(&fom->signature)
    free(ft->globals)
    free(ft->types)
    free(ft->owned_types)
    free(ft->functions)
    free(ft->fomtypes)

def free_control_flow_graph_block(cfg: CfGraph*, b: CfBlock*) -> None:
    for ins = b->instructions; ins < &b->instructions[b->ninstructions]; ins++:
        if ins->kind == CfInstructionKind::Constant:
            free_constant(&ins->constant)
        if ins->kind == CfInstructionKind::StringArray:
            free(ins->strarray.str)
        if ins->kind == CfInstructionKind::Call:
            free_signature(&ins->signature)
        free(ins->operands)
    free(b->instructions)
    if b != &cfg->start_block and b != &cfg->end_block:
        free(b)

def free_cfg(cfg: CfGraph*) -> None:
    free_signature(&cfg->signature)

    for b = cfg->all_blocks; b < &cfg->all_blocks[cfg->n_all_blocks]; b++:
        free_control_flow_graph_block(cfg, *b)
    for v = cfg->locals; v < &cfg->locals[cfg->nlocals]; v++:
        free(*v)

    free(cfg->all_blocks)
    free(cfg->locals)
    free(cfg)

def free_control_flow_graphs(cfgfile: CfGraphFile*) -> None:
    for cfg = cfgfile->graphs; cfg < &cfgfile->graphs[cfgfile->ngraphs]; cfg++:
        free_cfg(*cfg)
    free(cfgfile->graphs)
